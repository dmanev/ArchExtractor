###############################################################################
#                                                                             #
# IAR C/C++ Compiler V4.61A/W32 for 78K0 and 78K0S      15/Feb/2011  13:29:03 #
# Copyright 1992-2008 IAR Systems AB.                                         #
#                                                                             #
#    Core         =  78k0                                                     #
#    Code model   =  Standard                                                 #
#                 =                                                           #
#    Source file  =  D:\X90_BCM\DEVELOPMENT\X90_BCM\K0\L7\BUILD\SOURCES\DAT\D #
#                    AT_SBK.C                                                 #
#    Command line =  --code_model standard --core 78k0 -e                     #
#                    -DMEM_TYPE=__banked -DMEM_FAST=__saddr                   #
#                    -DCALLT_TYPE=__callt -DX90_PROJECT                       #
#                    --generate_callt_runtime_library_calls -r -Ohs           #
#                    "-IC:\Program Files\IAR Systems\Embedded Workbench       #
#                    5.0\78k\inc" "-IC:\Program Files\IAR Systems\Embedded    #
#                    Workbench 5.0\78k\inc\clib" -I. -I..\EXE\GEN\            #
#                    -I..\SOURCES\DAT -I..\SOURCES\LAP -I..\SOURCES\LDB_API   #
#                    -I..\SOURCES\LIB -I..\SOURCES\TOS -I.\LDB -DEMUL         #
#                    -DDEBUG -DUSE_LIBSTK -DDONT_KEEP_OLD_TYPE_COMPATIBILITY  #
#                    -l ..\EXE\TARGET_D\DAT_SBK.LST -o                        #
#                    ..\EXE\TARGET_D\DAT_SBK.R26                              #
#                    D:\X90_BCM\DEVELOPMENT\X90_BCM\K0\L7\BUILD\SOURCES\DAT\D #
#                    AT_SBK.C                                                 #
#    List file    =  ..\EXE\TARGET_D\DAT_SBK.LST                              #
#    Object file  =  ..\EXE\TARGET_D\DAT_SBK.R26                              #
#                                                                             #
#                                                                             #
###############################################################################

D:\X90_BCM\DEVELOPMENT\X90_BCM\K0\L7\BUILD\SOURCES\DAT\DAT_SBK.C
      1          /*=========================================================================
      2            Function ........................ DAT
      3            Component ....................... DAT_SBK
      4            PVCS File revision............... :   1.0  $
      5            Last modification date .......... $Modtime:   Apr 25 2009 21:02:24  $
      6            ------------------------------------------------------------------------- 
      7            Copyright ...... This software is JCI property. Duplication or 
      8            disclosure is prohibited without the JCI writen authorization
      9            ------------------------------------------------------------------------- 
     10            DAT_SBK component exported function definition 
     11            
     12            This file DAT_SBK.c is compile and a DAT_SBK.o is generated
     13            The object file includes the functions exported by the component.
     14            
     15            - The macros, constatnts et types wich are not exported are defined in 
     16            this file
     17            - The variables and functions which are not exported are defined in this 
     18            file wich the static key word
     19            
     20            -------------------------------------------------------------------------
     21            Document reference : see the DAT_SBK.h file
     22            ------------------------------------------------------------------------- 
     23            Component presentation : see the DAT_SBK.h file
     24            -------------------------------------------------------------------------
     25            Comments on the component (algorithm, structure, limitations, ...)
     26          
     27            -------------------------------------------------------------------------
     28            DAT_SBK.c file review : 
     29            
     30            21/08/2001 : AV - Alexandre Vion (OW1003)
     31          
     32            =========================================================================*/
     33          
     34          /*-------------------------------------------------------------------------
     35            Body Identification
     36            -------------------------------------------------------------------------*/
     37          
     38          
     39          #define DAT_SBK    "dat_sbk"
     40          
     41          /*-------------------------------------------------------------------------
     42            Included files
     43          
     44            #include <nom_du_ficher_systeme.h>
     45            #include "nom_du_ficher_utilisateur.h"
     46            -------------------------------------------------------------------------*/ 
     47          
     48          
     49          #include "lib.h"              /* defini les types et constantes de bases */
     50          #include "DAT_Sbk.h"
     51          #include "Dat_Eep.h"
     52          
     53          /*-------------------------------------------------------------------------
     54            Local constants
     55          
     56            #define cNomConstante   ValeurDeLaConstante
     57            -------------------------------------------------------------------------*/  
     58          
     59          /////////////////////////////////////////////////////////////////////////////
     60          // Bank flags : Mask definitions
     61          /////////////////////////////////////////////////////////////////////////////
     62          
     63          // ModeFlag ? WriteMode : ReadMode
     64          #define   cFlag_ModeFlag          ((U8) 0x01)
     65          
     66          // ErrorFlag ? WritingError : NoError
     67          #define   cFlag_ErrorFlag         ((U8) 0x02)
     68          
     69          /*-------------------------------------------------------------------------
     70            Local macro
     71          
     72            #define mNomMacro   (DefinitionDeLaMacro)
     73            -------------------------------------------------------------------------*/  
     74          
     75          /////////////////////////////////////////////////////////////////////////////
     76          // Handle conversions (between DAT_SBK and DAT_EEP)
     77          /////////////////////////////////////////////////////////////////////////////
     78          
     79          #define mConv_DatSbkHandle_To_DatEepHandle(HandleSbk)        \
     80                      ((tDATEepProcessHandle)     (HandleSbk + cDATSbkFirstProcessHandle))
     81          
     82          #define mConv_DatEepHandle_To_DatSbkHandle(HandleEep)        \
     83                      ((tDATSbkSingleBankHandle)  (HandleEep - cDATSbkFirstProcessHandle))
     84          
     85          
     86          /////////////////////////////////////////////////////////////////////////////
     87          // Bank flag acces
     88          /////////////////////////////////////////////////////////////////////////////
     89          
     90          // Macro for "Mode" acces
     91          #define   mBankFlag_SetReadMode(SINGLE_BANK_HANDLE)                   \
     92                      { SingleBankFlags[SINGLE_BANK_HANDLE] &= ~cFlag_ModeFlag; } /* Reset    "cFlag_ModeFlag"  */  
     93          
     94          #define   mBankFlag_SetWriteMode(SINGLE_BANK_HANDLE)                  \
     95                      { SingleBankFlags[SINGLE_BANK_HANDLE] |=  cFlag_ModeFlag; }  /* Set      "cFlag_ModeFlag"  */  
     96          
     97          // Macro for "Mode" tests
     98          #define   mBankFlag_IsReadMode(SINGLE_BANK_HANDLE)                    \
     99                      ( mBankFlag_IsWriteMode(SINGLE_BANK_HANDLE) == cFalse)       /* !"cFlag_ModeFlag" ?        */  
    100          
    101          #define   mBankFlag_IsWriteMode(SINGLE_BANK_HANDLE)                   \
    102                      ( SingleBankFlags[SINGLE_BANK_HANDLE] & cFlag_ModeFlag )    /* "cFlag_ModeFlag" ?         */  
    103          
    104          
    105          // Macro for "Error" acces
    106          #define   mBankFlag_SetNoError(SINGLE_BANK_HANDLE)                    \
    107                      { SingleBankFlags[SINGLE_BANK_HANDLE] &= ~cFlag_ErrorFlag; }  /* Reset  "cFlag_ErrorFlag" */
    108          
    109          #define   mBankFlag_SetWritingError(SINGLE_BANK_HANDLE)               \
    110                      { SingleBankFlags[SINGLE_BANK_HANDLE] |=  cFlag_ErrorFlag; }  /* Set    "cFlag_ErrorFlag" */
    111          
    112          // Macro for "Error" test
    113          #define   mBankFlag_IsWritingError(SINGLE_BANK_HANDLE)                  \
    114                      ( SingleBankFlags[SINGLE_BANK_HANDLE] & cFlag_ErrorFlag )     /* "cFlag_ErrorFlag" ?      */
    115          
    116          
    117          /*-------------------------------------------------------------------------
    118            Local type
    119          
    120            struct  sNomStructure { ... };
    121            union   uNomUnion { ... };
    122            enum    eNomEnumeration { ... };
    123            typedef Expression tNomType;
    124            -------------------------------------------------------------------------*/
    125          
    126          // StateChart State's ...
    127          typedef enum
    128          {
    129              cChartState_Wait,
    130              cChartState_Writing,
    131              cChartState_Reading,
    132              cChartState_CompareAfterReading
    133          }     S8tState;
    134          
    135          /*-------------------------------------------------------------------------
    136            Local data
    137          
    138            static  tType   NomVariable;
    139            static  tType*  pNomVariable; 
    140            -------------------------------------------------------------------------*/
    141          
    142          // Bank Flags

   \                                 In  segment NEAR_Z, align 1, align-sorted
    143          static  U8          SingleBankFlags[cNbSbk];
   \                     SingleBankFlags:
   \   0000                  DS 5
   \   0005                  REQUIRE __INIT_NEAR_Z
    144          
    145          // StateChart current state

   \                                 In  segment NEAR_Z, align 1, align-sorted
    146          static  S8tState     ChartState;
   \                     ChartState:
   \   0000                  DS 1
   \   0001                  REQUIRE __INIT_NEAR_Z
    147          
    148          // StateChart current reading retry

   \                                 In  segment NEAR_Z, align 1, align-sorted
    149          static  U8          DatSbk_CurrentNumberOfReadingRetry;
   \                     DatSbk_CurrentNumberOfReadingRetry:
   \   0000                  DS 1
   \   0001                  REQUIRE __INIT_NEAR_Z
    150          
    151          /*-------------------------------------------------------------------------
    152            Constant local Data
    153          
    154            static const tType  NomVariable;
    155            -------------------------------------------------------------------------*/  
    156          
    157          // Structure en ROM qui permet d'acceder aux adresses des SBK

   \                                 In  segment CONST, align 2
    158          const tDATSbkTableBankRom DATSbkTableBankRom [cNbSbk] =
   \                     DATSbkTableBankRom:
   \   0000   ....           DW DATSbkMirrors
   \   0002   0500           DB 5, 0
   \   0004   ....           DW DATSbkMirrors + 0AH
   \   0006   0D00           DB 13, 0
   \   0008   ....           DW DATSbkMirrors + 24H
   \   000A   0100           DB 1, 0
   \   000C   ....           DW DATSbkMirrors + 26H
   \   000E   0A00           DB 10, 0
   \   0010   ....           DW DATSbkMirrors + 3AH
   \   0012   0100           DB 1, 0
    159              {
    160                  mDATSbkInitTableBankROM()
    161              };
    162          
    163          /*-------------------------------------------------------------------------
    164            Exported data
    165          
    166            tType   COMNomVariable;          (COM: 3 lettres identifiant ce composant)
    167            tType*  pCOMNomVariable;         (COM: 3 lettres identifiant ce composant)
    168            -------------------------------------------------------------------------*/ 
    169          
    170          // variable definissant toutes les simples banques en RAM

   \                                 In  segment NEAR_Z, align 2, align-sorted
    171          tDATSbkMirrors    DATSbkMirrors;
   \                     DATSbkMirrors:
   \   0000                  DS 60
   \   003C                  REQUIRE __INIT_NEAR_Z
    172          
    173          /*-------------------------------------------------------------------------
    174            Constant exported data
    175           
    176            const tType   COMNomVariable;    (COM: 3 lettres identifiant ce composant)
    177            -------------------------------------------------------------------------*/ 
    178          
    179          /*-------------------------------------------------------------------------
    180            Local functions prototype
    181            
    182            static tTypeRetour NomFonction(tTypeArgument1 NomArgument1, ... );
    183            -------------------------------------------------------------------------*/
    184          
    185          // 16bits CheckSum (general) Computing function
    186          static  U16 Compute16BitsCheckSum (U16* Buffer, U16 BufferSizeInWords);
    187          
    188          #ifdef X90_PROJECT
    189          static MEM_TYPE void DATSbkCallBackEep_Static( tDATEepProcessHandle DATEepProcessHandle, BOOL DATEepCallBackStatusIsOk );
    190          #endif
    191          
    192          /*.........................................................................
    193            ........................... LOCAL FUNCTIONS..............................
    194            .........................................................................*/
    195          
    196          /*=========================================================================
    197          ! Function .........
    198          ! void DATSbkInit (void)
    199          !--------------------------------------------------------------------------
    200          ! Function purpose :
    201          ! init for DAT_SBK component
    202          !--------------------------------------------------------------------------
    203          ! Precondition (parameters):
    204          !
    205          ! Type            Name                           Min          Max
    206          ! -------------------------------------------------------------------------
    207          !
    208          !--------------------------------------------------------------------------
    209          ! Postcondition (return values):
    210          !
    211          ! Type            Name                           Min          Max
    212          ! -------------------------------------------------------------------------
    213          !
    214          !--------------------------------------------------------------------------
    215          ! Function review:
    216          !
    217          !
    218          !==========================================================================*/
    219          

   \                                 In  segment CODE, align 1, keep-with-next
    220          void DATSbkInit (void)
   \                     DATSbkInit:
    221          {
   \   0000                  ; * Stack frame (at entry) *
   \   0000                  ; Param size: 0
   \   0000   A100           MOV       A,#0
   \   0002   B3             PUSH      BC
   \   0003   B5             PUSH      DE
   \   0004                  ; Total Auto size: 0
    222              // StateChart Reset (very important)
    223              ChartState                          =  cChartState_Wait;
   \   0004   9E....         MOV       ChartState,A
    224          
    225              // Current reading retry reset (not important)
    226              DatSbk_CurrentNumberOfReadingRetry  = 0;
   \   0007   9E....         MOV       DatSbk_CurrentNumberOfReadingRetry,A
    227          
    228              // Single Bank flags reset (not important)
    229              mLIBmemset(SingleBankFlags, 0x00, sizeof(SingleBankFlags));
   \   000A   10....         MOVW      AX,#SingleBankFlags
   \   000D   140500         MOVW      DE,#5
   \   0010   120000         MOVW      BC,#0
   \   0013   9A....         CALL      memset
    230          }
   \   0016   B4             POP       DE
   \   0017   B2             POP       BC
   \   0018   AF             RET       
   \   0019                  REQUIRE ?CL78K_V4_6_L00
    231          
    232          /*=========================================================================
    233          ! Function .........
    234          ! U16 Compute16BitsCheckSum (U16* Buffer, U16 BufferSizeInWords)
    235          !--------------------------------------------------------------------------
    236          ! Function purpose :
    237          ! 16bits CheckSum calculation on a *16bits* buffer 
    238          !
    239          !--------------------------------------------------------------------------
    240          ! Precondition (parameters):
    241          !
    242          ! Type            Name                           Min          Max
    243          ! -------------------------------------------------------------------------
    244          ! U16*        Buffer                         16bits Buffer pointor 
    245          ! U16         BufferSizeInWords              0            ...          
    246          !--------------------------------------------------------------------------
    247          ! Postcondition (return values):
    248          !
    249          ! Type            Name                           Min          Max
    250          ! -------------------------------------------------------------------------
    251          ! U16         CheckSum                        0            0xFFFF
    252          !--------------------------------------------------------------------------
    253          ! Function review:
    254          !
    255          ! Return the sum'inverse
    256          !==========================================================================*/
    257          

   \                                 In  segment CODE, align 1, keep-with-next
    258          U16 Compute16BitsCheckSum (U16* Buffer, U16 BufferSizeInWords)
   \                     Compute16BitsCheckSum:
    259          {
   \   0000                  ; * Stack frame (at entry) *
   \   0000                  ; Param size: 0
   \   0000   B5             PUSH      DE
   \   0001   B3             PUSH      BC
   \   0002                  ; Total Auto size: 2
   \   0002   D4             MOVW      DE,AX
    260              U16 Checksum = 0;
   \   0003   120000         MOVW      BC,#0
    261          
    262              //// Used in debug mode to check param  ////
    263              mLIBassert(Buffer != NULL);
   \   0006   6168           OR        A,X
   \   0008   BD14           BNZ       ??DATSbkCallBackEep_Static_0
   \   000A   9A....         CALL      LIBAssertionFailed
   \   000D   FA0F           BR        ??DATSbkCallBackEep_Static_0
    264          
    265              // Compute the check-sum
    266              while (BufferSizeInWords > 0)
    267              {
    268                  Checksum += *Buffer;
   \                     ??Compute16BitsCheckSum_0:
   \   000F   C4             MOVW      AX,DE
   \   0010   D6             MOVW      HL,AX
   \   0011   87             MOV       A,[HL]
   \   0012   70             MOV       X,A
   \   0013   AE01           MOV       A,[HL+0x01]
   \   0015   30             XCH       A,X
   \   0016   610A           ADD       A,C
   \   0018   30             XCH       A,X
   \   0019   612B           ADDC      A,B
   \   001B   D2             MOVW      BC,AX
    269          
    270                  // Inc./Dec.
    271                  Buffer++;
   \   001C   84             INCW      DE
   \   001D   84             INCW      DE
    272                  BufferSizeInWords--;
    273              }
   \                     ??DATSbkCallBackEep_Static_0:
   \   001E   891C           MOVW      AX,SP
   \   0020   D6             MOVW      HL,AX
   \   0021   87             MOV       A,[HL]
   \   0022   70             MOV       X,A
   \   0023   AE01           MOV       A,[HL+0x01]
   \   0025   90             DECW      AX
   \   0026   30             XCH       A,X
   \   0027   97             MOV       [HL],A
   \   0028   30             XCH       A,X
   \   0029   BE01           MOV       [HL+0x01],A
   \   002B   80             INCW      AX
   \   002C   6168           OR        A,X
   \   002E   BDDF           BNZ       ??Compute16BitsCheckSum_0
    274          
    275              // Return the inverse of the check-sum value
    276              return (~Checksum);
   \   0030   C2             MOVW      AX,BC
   \   0031   30             XCH       A,X
   \   0032   7DFF           XOR       A,#255
   \   0034   30             XCH       A,X
   \   0035   7DFF           XOR       A,#255
   \   0037   B2             POP       BC
   \   0038   B4             POP       DE
   \   0039   AF             RET       
   \   003A                  REQUIRE ?CL78K_V4_6_L00
    277          }
    278          
    279          
    280          
    281          /*.........................................................................
    282            ........................... EXPORTED FUNCTIONS. .........................
    283            .........................................................................*/
    284          
    285          
    286          
    287          
    288          /*=========================================================================
    289          ! Function .........
    290          BOOL DATSbkIsBankProcessing ( tDATSbkSingleBankHandle HandleSbk )
    291          !--------------------------------------------------------------------------
    292          ! Function purpose :
    293          ! check if single bank writing is terminated
    294          !--------------------------------------------------------------------------
    295          ! Precondition (parameters):
    296          !
    297          ! Type            Name                           Min          Max
    298          ! -------------------------------------------------------------------------
    299          !tDATSbkSingleBankHandle HandleSbk                0            cNbSbk-1
    300          !--------------------------------------------------------------------------
    301          ! Postcondition (return values):
    302          !
    303          ! Type            Name                           Min          Max
    304          ! -------------------------------------------------------------------------
    305          ! BOOL    IsBankProcessing                    cFalse        cTrue
    306          !--------------------------------------------------------------------------
    307          ! Function review:
    308          !
    309          !
    310          !==========================================================================*/
    311          

   \                                 In  segment CODE, align 1, keep-with-next
    312          BOOL DATSbkIsBankProcessing ( tDATSbkSingleBankHandle HandleSbk )
   \                     DATSbkIsBankProcessing:
    313          {
   \   0000                  ; * Stack frame (at entry) *
   \   0000                  ; Param size: 0
   \   0000   B3             PUSH      BC
   \   0001                  ; Total Auto size: 0
   \   0001   72             MOV       C,A
    314              /// Used in debug mode to check param  ////
    315              mLIBassert( HandleSbk < cNbSbk );
   \   0002   4D05           CMP       A,#5
   \   0004   8D03           BC        ??DATSbkCallBackEep_Static_1
   \   0006   9A....         CALL      LIBAssertionFailed
    316          
    317              // Return ("HandleSbk" Bank is processing ?)
    318              return DATEepIsActivate (mConv_DatSbkHandle_To_DatEepHandle(HandleSbk));
   \                     ??DATSbkCallBackEep_Static_1:
   \   0009   62             MOV       A,C
   \   000A   9A....         CALL      DATEepIsActivate
   \   000D   B2             POP       BC
   \   000E   AF             RET       
   \   000F                  REQUIRE ?CL78K_V4_6_L00
    319          }
    320          
    321          
    322          /*=========================================================================
    323          ! Function .........
    324          BOOL DATSbkIsProcessing ( void )
    325          !--------------------------------------------------------------------------
    326          ! Function purpose :
    327          ! check if all single bank writing is terminated
    328          !--------------------------------------------------------------------------
    329          ! Precondition (parameters):
    330          !
    331          ! Type            Name                           Min          Max
    332          ! -------------------------------------------------------------------------
    333          !
    334          !--------------------------------------------------------------------------
    335          ! Postcondition (return values):
    336          !
    337          ! Type            Name                           Min          Max
    338          ! -------------------------------------------------------------------------
    339          ! BOOL    IsTerminate                          cFalse        cTrue
    340          !--------------------------------------------------------------------------
    341          ! Function review:
    342          !
    343          !
    344          !==========================================================================*/
    345          

   \                                 In  segment CODE, align 1, keep-with-next
    346          BOOL DATSbkIsProcessing ( void )
   \                     DATSbkIsProcessing:
    347          {
   \   0000                  ; * Stack frame (at entry) *
   \   0000                  ; Param size: 0
   \   0000   B3             PUSH      BC
   \   0001                  ; Total Auto size: 0
    348              tDATSbkSingleBankHandle HandleSbk;
    349              BOOL                IsProcessing = cFalse;
   \   0001   A300           MOV       B,#0
    350          
    351              // Check all banks ...
    352              for (HandleSbk = 0; HandleSbk < cNbSbk; HandleSbk++)
   \   0003   A200           MOV       C,#0
   \                     ??DATSbkIsProcessing_0:
   \   0005   62             MOV       A,C
   \   0006   9A....         CALL      DATEepIsActivate
   \   0009   51             DEC       A
   \   000A   BD04           BNZ       ??DATSbkCallBackEep_Static_2
    353              {
    354                  if (DATSbkIsBankProcessing(HandleSbk) == cTrue)
    355                  {
    356                      /* ok */
    357                      IsProcessing = cTrue;
   \   000C   A301           MOV       B,#1
    358          
    359                      /* Force "End of checking" */
    360                      HandleSbk = cNbSbk;         // <=> break; (in order to avoid a QAC warning)
   \   000E   A205           MOV       C,#5
    361                  }
    362              }
   \                     ??DATSbkCallBackEep_Static_2:
   \   0010   42             INC       C
   \   0011   62             MOV       A,C
   \   0012   4D05           CMP       A,#5
   \   0014   8DEF           BC        ??DATSbkIsProcessing_0
    363          
    364              // Return
    365              return IsProcessing;
   \   0016   63             MOV       A,B
   \   0017   B2             POP       BC
   \   0018   AF             RET       
   \   0019                  REQUIRE ?CL78K_V4_6_L00
    366          }
    367          
    368          /*=========================================================================
    369          ! Function .........
    370          void DATSbkStartReadingAllBanks ( void )
    371          !--------------------------------------------------------------------------
    372          ! Function purpose :
    373          ! reading EEPROM to RAM for all single banks
    374          !--------------------------------------------------------------------------
    375          ! Precondition (parameters):
    376          !
    377          ! Type            Name                           Min          Max
    378          ! -------------------------------------------------------------------------
    379          !
    380          !--------------------------------------------------------------------------
    381          ! Postcondition (return values):
    382          !
    383          ! Type            Name                           Min          Max
    384          ! -------------------------------------------------------------------------
    385          ! 
    386          !--------------------------------------------------------------------------
    387          ! Function review:
    388          !
    389          !
    390          !==========================================================================*/
    391          

   \                                 In  segment CODE, align 1, keep-with-next
    392          void DATSbkStartReadingAllBanks ( void )
   \                     DATSbkStartReadingAllBanks:
    393          {
   \   0000                  ; * Stack frame (at entry) *
   \   0000                  ; Param size: 0
   \   0000   B3             PUSH      BC
   \   0001   B5             PUSH      DE
   \   0002                  ; Total Auto size: 0
    394              tDATSbkSingleBankHandle HandleSbk;
    395          
    396              // Reading request for all banks ...
    397              for (HandleSbk = 0; HandleSbk < cNbSbk; HandleSbk++)
   \   0002   A200           MOV       C,#0
   \   0004   14....         MOVW      DE,#SingleBankFlags
   \                     ??DATSbkStartReadingAllBanks_0:
   \   0007   62             MOV       A,C
   \   0008   9A....         CALL      DATEepIsActivate
   \   000B   4D00           CMP       A,#0
   \   000D   AD03           BZ        ??DATSbkCallBackEep_Static_3
   \   000F   9A....         CALL      LIBAssertionFailed
   \                     ??DATSbkCallBackEep_Static_3:
   \   0012   C4             MOVW      AX,DE
   \   0013   D6             MOVW      HL,AX
   \   0014   62             MOV       A,C
   \   0015   7183           CLR1      [HL].0
   \   0017   9A....         CALL      DATEepProcessRequest
   \   001A   42             INC       C
   \   001B   62             MOV       A,C
   \   001C   84             INCW      DE
   \   001D   4D05           CMP       A,#5
   \   001F   8DE6           BC        ??DATSbkStartReadingAllBanks_0
    398              {
    399                  DATSbkStartReading (HandleSbk);
    400              }
    401          }
   \   0021   B4             POP       DE
   \   0022   B2             POP       BC
   \   0023   AF             RET       
   \   0024                  REQUIRE ?CL78K_V4_6_L00
    402          
    403          /*=========================================================================
    404          ! Function .........
    405          void DATSbkStartReading ( tDATSbkSingleBankHandle Handle )
    406          !--------------------------------------------------------------------------
    407          ! Function purpose :
    408          ! reading EEPROM to RAM for one single bank
    409          !--------------------------------------------------------------------------
    410          ! Precondition (parameters):
    411          !
    412          ! Type            Name                           Min          Max
    413          ! -------------------------------------------------------------------------
    414          !tDATSbkSingleBankHandle HandleSbk                0            cNbSbk-1
    415          !--------------------------------------------------------------------------
    416          ! Postcondition (return values):
    417          !
    418          ! Type            Name                           Min          Max
    419          ! -------------------------------------------------------------------------
    420          ! 
    421          !--------------------------------------------------------------------------
    422          ! Function review:
    423          !
    424          !
    425          !==========================================================================*/
    426          

   \                                 In  segment CODE, align 1, keep-with-next
    427          void DATSbkStartReading ( tDATSbkSingleBankHandle HandleSbk )
   \                     DATSbkStartReading:
    428          {
   \   0000                  ; * Stack frame (at entry) *
   \   0000                  ; Param size: 0
   \   0000   B3             PUSH      BC
   \   0001                  ; Total Auto size: 0
   \   0001   72             MOV       C,A
    429              //// Used in debug mode to check param  ////
    430              mLIBassert( HandleSbk < cNbSbk );
   \   0002   4D05           CMP       A,#5
   \   0004   8D06           BC        ??DATSbkCallBackEep_Static_4
   \   0006   9A....         CALL      LIBAssertionFailed
   \   0009   9A....         CALL      LIBAssertionFailed
   \                     ??DATSbkCallBackEep_Static_4:
   \   000C   62             MOV       A,C
   \   000D   9A....         CALL      DATEepIsActivate
   \   0010   4D00           CMP       A,#0
   \   0012   AD03           BZ        ??DATSbkCallBackEep_Static_5
    431          
    432              //// This assert check that this single-bank is'nt processing yet ////
    433              mLIBassert(DATSbkIsBankProcessing(HandleSbk) == cFalse);
   \   0014   9A....         CALL      LIBAssertionFailed
    434          
    435              //// Starting Reading process ...
    436              mBankFlag_SetReadMode(HandleSbk);
   \                     ??DATSbkCallBackEep_Static_5:
   \   0017   62             MOV       A,C
   \   0018   70             MOV       X,A
   \   0019   A100           MOV       A,#0
   \   001B   CA....         ADDW      AX,#SingleBankFlags
   \   001E   D6             MOVW      HL,AX
   \   001F   62             MOV       A,C
   \   0020   7183           CLR1      [HL].0
    437              DATEepProcessRequest(mConv_DatSbkHandle_To_DatEepHandle(HandleSbk));
   \   0022   9A....         CALL      DATEepProcessRequest
    438          }
   \   0025   B2             POP       BC
   \   0026   AF             RET       
   \   0027                  REQUIRE ?CL78K_V4_6_L00
    439          
    440          
    441          /*=========================================================================
    442          ! Function .........
    443          void DATSbkStartUpdate ( tDATSbkSingleBankHandle HandleSbk )
    444          !--------------------------------------------------------------------------
    445          ! Function purpose :
    446          ! writing RAM to EEPROM for one single bank
    447          !--------------------------------------------------------------------------
    448          ! Precondition (parameters):
    449          !
    450          ! Type            Name                           Min          Max
    451          ! -------------------------------------------------------------------------
    452          !tDATSbkSingleBankHandle HandleSbk                0            cNbSbk-1
    453          !--------------------------------------------------------------------------
    454          ! Postcondition (return values):
    455          !
    456          ! Type            Name                           Min          Max
    457          ! -------------------------------------------------------------------------
    458          ! 
    459          !--------------------------------------------------------------------------
    460          ! Function review:
    461          !
    462          !
    463          !==========================================================================*/
    464          

   \                                 In  segment CODE, align 1, keep-with-next
    465          void DATSbkStartUpdate ( tDATSbkSingleBankHandle HandleSbk )
   \                     DATSbkStartUpdate:
    466          {
   \   0000                  ; * Stack frame (at entry) *
   \   0000                  ; Param size: 0
   \   0000   B3             PUSH      BC
   \   0001                  ; Total Auto size: 0
   \   0001   72             MOV       C,A
    467              //// Used in debug mode to check param  ////
    468              mLIBassert( HandleSbk < cNbSbk );
   \   0002   4D05           CMP       A,#5
   \   0004   8D06           BC        ??DATSbkCallBackEep_Static_6
   \   0006   9A....         CALL      LIBAssertionFailed
   \   0009   9A....         CALL      LIBAssertionFailed
   \                     ??DATSbkCallBackEep_Static_6:
   \   000C   62             MOV       A,C
   \   000D   9A....         CALL      DATEepIsActivate
   \   0010   4D00           CMP       A,#0
   \   0012   AD0B           BZ        ??DATSbkCallBackEep_Static_7
   \   0014   62             MOV       A,C
   \   0015   70             MOV       X,A
   \   0016   A100           MOV       A,#0
   \   0018   CA....         ADDW      AX,#SingleBankFlags
   \   001B   D6             MOVW      HL,AX
   \   001C   318710         BF        [HL].0, ??DATSbkCallBackEep_Static_8
    469          
    470              // If a write request occurs during a read operation,
    471              // this request is ignored.
    472              // This test is a robustness test. The else branch can'not be
    473              // covered in unitary test.
    474              if(  (DATSbkIsBankProcessing(HandleSbk) == cFalse) ||
    475                   (mBankFlag_IsReadMode (HandleSbk)  == cFalse)    )
    476              {
    477                  //// Starting Writing process ...
    478                  mBankFlag_SetWriteMode(HandleSbk);
   \                     ??DATSbkCallBackEep_Static_7:
   \   001F   62             MOV       A,C
   \   0020   70             MOV       X,A
   \   0021   A100           MOV       A,#0
   \   0023   CA....         ADDW      AX,#SingleBankFlags
   \   0026   D6             MOVW      HL,AX
   \   0027   62             MOV       A,C
   \   0028   7182           SET1      [HL].0
    479                  DATEepProcessRequest(mConv_DatSbkHandle_To_DatEepHandle(HandleSbk));
   \   002A   9A....         CALL      DATEepProcessRequest
   \   002D   FA03           BR        ??DATSbkCallBackEep_Static_9
    480              }
    481              else
    482              {
    483                  // The EEPROM users can'not request to write during the reading.
    484                  mLIBassert( cFalse );
   \                     ??DATSbkCallBackEep_Static_8:
   \   002F   9A....         CALL      LIBAssertionFailed
    485              }
    486          }
   \                     ??DATSbkCallBackEep_Static_9:
   \   0032   B2             POP       BC
   \   0033   AF             RET       
   \   0034                  REQUIRE ?CL78K_V4_6_L00
    487          
    488          
    489          /*=========================================================================
    490          ! Function .........
    491          BOOL DATSbkIsWriteOk( tDATSbkSingleBankHandle HandleSbk )
    492          !--------------------------------------------------------------------------
    493          ! Function purpose :
    494          ! check if single bank writing is correctly terminated
    495          !--------------------------------------------------------------------------
    496          ! Precondition (parameters):
    497          !
    498          ! Type            Name                           Min          Max
    499          ! -------------------------------------------------------------------------
    500          !tDATSbkSingleBankHandle HandleSbk                0            cNbSbk-1
    501          !--------------------------------------------------------------------------
    502          ! Postcondition (return values):
    503          !
    504          ! Type            Name                           Min          Max
    505          ! -------------------------------------------------------------------------
    506          ! BOOL        IsWriteOk                        cFalse        cTrue
    507          !--------------------------------------------------------------------------
    508          ! Function review:
    509          !
    510          !
    511          !==========================================================================*/
    512          

   \                                 In  segment CODE, align 1, keep-with-next
    513          BOOL DATSbkIsWriteOk( tDATSbkSingleBankHandle HandleSbk )
   \                     DATSbkIsWriteOk:
    514          {
   \   0000                  ; * Stack frame (at entry) *
   \   0000                  ; Param size: 0
   \   0000   B3             PUSH      BC
   \   0001                  ; Total Auto size: 0
   \   0001   72             MOV       C,A
    515              BOOL IsWriteOk = cFalse;
   \   0002   A300           MOV       B,#0
    516          
    517              //// Used in debug mode to check param  ////
    518              mLIBassert( HandleSbk < cNbSbk );
   \   0004   4D05           CMP       A,#5
   \   0006   8D03           BC        ??DATSbkCallBackEep_Static_10
   \   0008   9A....         CALL      LIBAssertionFailed
    519          
    520              // Check error flag ...
    521              if (mBankFlag_IsWritingError(HandleSbk) == cFalse)
   \                     ??DATSbkCallBackEep_Static_10:
   \   000B   62             MOV       A,C
   \   000C   70             MOV       X,A
   \   000D   A100           MOV       A,#0
   \   000F   CA....         ADDW      AX,#SingleBankFlags
   \   0012   D6             MOVW      HL,AX
   \   0013   319602         BT        [HL].1, ??DATSbkCallBackEep_Static_11
    522              {
    523                  /* ok */
    524                  IsWriteOk = cTrue;
   \   0016   A301           MOV       B,#1
    525              }
    526          
    527              // Return
    528              return IsWriteOk;
   \                     ??DATSbkCallBackEep_Static_11:
   \   0018   63             MOV       A,B
   \   0019   B2             POP       BC
   \   001A   AF             RET       
   \   001B                  REQUIRE ?CL78K_V4_6_L00
    529          }
    530          
    531          
    532          /*=========================================================================
    533          ! Function .........
    534          void DATSbkCallBackEep ( tDATEepProcessHandle DATEepProcessHandle, BOOL DATEepCallBackStatusIsOk )
    535          !--------------------------------------------------------------------------
    536          ! Function purpose :
    537          !  DAT_EEP call this function when previous treatment is terminated
    538          !
    539          !--------------------------------------------------------------------------
    540          ! Precondition (parameters):
    541          !
    542          ! Type            Name                           Min          Max
    543          ! -------------------------------------------------------------------------
    544          !
    545          !--------------------------------------------------------------------------
    546          ! Postcondition (return values):
    547          !
    548          ! Type            Name                           Min          Max
    549          ! -------------------------------------------------------------------------
    550          ! 
    551          !--------------------------------------------------------------------------
    552          ! Function review:
    553          !
    554          ! Callback musn't return before calling DAT_EEP function !
    555          !
    556          !==========================================================================*/
    557          

   \                                 In  segment CODE, align 1, keep-with-next
    558          void DATSbkCallBackEep ( tDATEepProcessHandle DATEepProcessHandle, BOOL DATEepCallBackStatusIsOk )
   \                     DATSbkCallBackEep:
    559          {
   \   0000                  ; * Stack frame (at entry) *
   \   0000                  ; Param size: 0
   \   0000   B5             PUSH      DE
   \   0001                  ; Total Auto size: 0
    560          #ifdef X90_PROJECT
    561              DATSbkCallBackEep_Static(DATEepProcessHandle, DATEepCallBackStatusIsOk);
   \   0001   16....         MOVW      HL,#LWRD(DATSbkCallBackEep_Static)
   \   0004   A4..           MOV       E,#BYTE3(DATSbkCallBackEep_Static)
   \   0006   ..             CALLT     [__T_?FAR_CALL_L07]
    562          }
   \   0007   B4             POP       DE
   \   0008   AF             RET       
   \   0009                  REQUIRE ?CL78K_V4_6_L00
    563          #pragma optimize=no_inline

   \                                 In  segment BCODE, align 1, keep-with-next
    564          static MEM_TYPE void DATSbkCallBackEep_Static( tDATEepProcessHandle DATEepProcessHandle, BOOL DATEepCallBackStatusIsOk )
   \                     DATSbkCallBackEep_Static:
    565          {
   \   0000                  ; * Stack frame (at entry) *
   \   0000                  ; Param size: 0
   \   0000   B3             PUSH      BC
   \   0001                  ; Total Auto size: 4
   \   0001   B7             PUSH      HL
   \   0002   B7             PUSH      HL
   \   0003   72             MOV       C,A
    566          #endif    
    567              tDATSbkSingleBankHandle       HandleSbk;
    568                  
    569              U16*                      Sbk_AddBlockRam;
    570              tDATEepOffset                 Sbk_SizeBlockRam;
    571          
    572              // Get the current Sbk Handle
    573              HandleSbk         = mConv_DatEepHandle_To_DatSbkHandle(DATEepProcessHandle);
    574          
    575              //// Used in debug mode to check param  ////
    576              mLIBassert(HandleSbk < cNbSbk);
   \   0004   4D05           CMP       A,#5
   \   0006   8D03           BC        ??DATSbkCallBackEep_Static_12
   \   0008   9A....         CALL      LIBAssertionFailed
    577          
    578              // Get information on current Sbk bank
    579              Sbk_AddBlockRam   = DATSbkTableBankRom[HandleSbk].AddBlockRam;
   \                     ??DATSbkCallBackEep_Static_12:
   \   000B   62             MOV       A,C
   \   000C   74             MOV       E,A
   \   000D   A500           MOV       D,#0
   \   000F   C4             MOVW      AX,DE
   \   0010   21             CLR1      CY
   \   0011   30             XCH       A,X
   \   0012   27             ROLC      A,0x1
   \   0013   30             XCH       A,X
   \   0014   27             ROLC      A,0x1
   \   0015   30             XCH       A,X
   \   0016   27             ROLC      A,0x1
   \   0017   30             XCH       A,X
   \   0018   27             ROLC      A,0x1
   \   0019   CA....         ADDW      AX,#DATSbkTableBankRom
   \   001C   D6             MOVW      HL,AX
   \   001D   87             MOV       A,[HL]
   \   001E   70             MOV       X,A
   \   001F   AE01           MOV       A,[HL+0x01]
   \   0021   D6             MOVW      HL,AX
   \   0022   891C           MOVW      AX,SP
   \   0024   E6             XCHW      AX,HL
   \   0025   BE03           MOV       [HL+0x03],A
   \   0027   60             MOV       A,X
   \   0028   BE02           MOV       [HL+0x02],A
    580              Sbk_SizeBlockRam  = DATSbkTableBankRom[HandleSbk].SizeBlockRam;
   \   002A   C4             MOVW      AX,DE
   \   002B   21             CLR1      CY
   \   002C   30             XCH       A,X
   \   002D   27             ROLC      A,0x1
   \   002E   30             XCH       A,X
   \   002F   27             ROLC      A,0x1
   \   0030   30             XCH       A,X
   \   0031   27             ROLC      A,0x1
   \   0032   30             XCH       A,X
   \   0033   27             ROLC      A,0x1
   \   0034   CA....         ADDW      AX,#DATSbkTableBankRom+2
   \   0037   D6             MOVW      HL,AX
   \   0038   87             MOV       A,[HL]
   \   0039   77             MOV       H,A
   \   003A   891C           MOVW      AX,SP
   \   003C   E6             XCHW      AX,HL
   \   003D   97             MOV       [HL],A
    581          
    582              ///////////////////////////////////////////////////////////////////////
    583              // State Mate :)
    584              // (Continue treatment routine ...)
    585              ///////////////////////////////////////////////////////////////////////
    586              switch (ChartState)
   \   003E   8E....         MOV       A,ChartState
   \   0041   4D00           CMP       A,#0
   \   0043   AD15           BZ        ??DATSbkCallBackEep_Static_13
   \   0045   4D01           CMP       A,#1
   \   0047   AD6F           BZ        ??DATSbkCallBackEep_Static_14
   \   0049   4D02           CMP       A,#2
   \   004B   BD03           BNZ       $+5
   \   004D   9B....         BR        N:??DATSbkCallBackEep_Static_15
   \   0050   4D03           CMP       A,#3
   \   0052   BD03           BNZ       $+5
   \   0054   9B....         BR        N:??DATSbkCallBackEep_Static_16
   \   0057   9B....         BR        N:??DATSbkCallBackEep_Static_17
    587              {
    588          
    589                  ///////////////////////////////////////////////////////////////////////
    590                  // Waiting for the activated process ?
    591                  ///////////////////////////////////////////////////////////////////////
    592              case cChartState_Wait:
    593          
    594                  ////////////////////////////////////////////////////
    595                  // Performe a writing operation ?
    596                  ////////////////////////////////////////////////////
    597                  if (mBankFlag_IsWriteMode(HandleSbk) == cTrue)
   \                     ??DATSbkCallBackEep_Static_13:
   \   005A   C4             MOVW      AX,DE
   \   005B   CA....         ADDW      AX,#SingleBankFlags
   \   005E   D6             MOVW      HL,AX
   \   005F   31873B         BF        [HL].0, ??DATSbkCallBackEep_Static_18
    598                  {
    599                      // >>> Get ready for "Writing" <<<
    600                      ChartState = cChartState_Writing;
   \   0062   A101           MOV       A,#1
   \   0064   9E....         MOV       ChartState,A
    601          
    602                      // Store data into DAT_EEP buffer
    603                      // (keep one 16bits-word for check-sum at the buffer'top)
    604                      mLIBmemcpy ((U8 *) (DATEepBuffer + 1),
    605                                  (U8 *) (Sbk_AddBlockRam), Sbk_SizeBlockRam * sizeof(U16));
   \   0067   891C           MOVW      AX,SP
   \   0069   D6             MOVW      HL,AX
   \   006A   87             MOV       A,[HL]
   \   006B   A002           MOV       X,#2
   \   006D   3188           MULU      X
   \   006F   D4             MOVW      DE,AX
   \   0070   AE02           MOV       A,[HL+0x02]
   \   0072   70             MOV       X,A
   \   0073   AE03           MOV       A,[HL+0x03]
   \   0075   D2             MOVW      BC,AX
   \   0076   10....         MOVW      AX,#DATEepBuffer+2
   \   0079   9A....         CALL      memcpy
    606          
    607                      // Compute the 16bits check-sum (of DAT_EEP)
    608                      // and store it at the DAT_EEP buffer'top
    609                      DATEepBuffer[0] = Compute16BitsCheckSum (DATEepBuffer+1, Sbk_SizeBlockRam);
   \   007C   891C           MOVW      AX,SP
   \   007E   D6             MOVW      HL,AX
   \   007F   87             MOV       A,[HL]
   \   0080   72             MOV       C,A
   \   0081   10....         MOVW      AX,#DATEepBuffer+2
   \   0084   A300           MOV       B,#0
   \   0086   9A....         CALL      Compute16BitsCheckSum
   \   0089   03....         MOVW      DATEepBuffer,AX
    610          
    611          
    612                      // Now, let's go for writing operation by the way of DAT_EEP
    613                      DATEepWrite (DATEepBuffer, (tDATEepOffset)0, (tDATEepOffset)(1 + Sbk_SizeBlockRam));
   \   008C   891C           MOVW      AX,SP
   \   008E   D6             MOVW      HL,AX
   \   008F   87             MOV       A,[HL]
   \   0090   41             INC       A
   \   0091   72             MOV       C,A
   \   0092   10....         MOVW      AX,#DATEepBuffer
   \   0095   A300           MOV       B,#0
   \   0097   9A....         CALL      DATEepWrite
   \   009A   9B....         BR        N:??DATSbkCallBackEep_Static_19
    614                      // NOTA : "+1" is for the 16bits check-sum (at the top of the bank)
    615                  }
    616                  else
    617                      ////////////////////////////////////////////////////
    618                      // or Performe a reading operation ?
    619                      ////////////////////////////////////////////////////
    620                  {
    621                      // >>> Get ready for "Reading" state <<<
    622                      ChartState = cChartState_Reading;
   \                     ??DATSbkCallBackEep_Static_18:
   \   009D   A102           MOV       A,#2
   \   009F   9E....         MOV       ChartState,A
    623          
    624                      // Reset "current number of reading retry"
    625                      DatSbk_CurrentNumberOfReadingRetry = 0;
   \   00A2   A100           MOV       A,#0
   \   00A4   9E....         MOV       DatSbk_CurrentNumberOfReadingRetry,A
    626          
    627                      // Now, let's go for reading operation by the way of DAT_EEP
    628                      DATEepRead(DATEepBuffer, (tDATEepOffset)0, (tDATEepOffset)(1 + Sbk_SizeBlockRam));
   \   00A7   891C           MOVW      AX,SP
   \   00A9   D6             MOVW      HL,AX
   \   00AA   87             MOV       A,[HL]
   \   00AB   41             INC       A
   \   00AC   72             MOV       C,A
   \   00AD   10....         MOVW      AX,#DATEepBuffer
   \   00B0   A300           MOV       B,#0
   \   00B2   9A....         CALL      DATEepRead
   \   00B5   9B....         BR        N:??DATSbkCallBackEep_Static_19
    629                      // NOTA : "+1" is for the 16bits check-sum (at the top of the bank)
    630                  }
    631          
    632          
    633          
    634                  break;
    635          
    636          
    637                  ///////////////////////////////////////////////////////////////////////
    638                  // Waiting for the terminated writing process ?
    639                  ///////////////////////////////////////////////////////////////////////
    640              case cChartState_Writing:
    641          
    642                  // Writing process is done (bye bye)
    643                  ChartState = cChartState_Wait;
   \                     ??DATSbkCallBackEep_Static_14:
   \   00B8   A100           MOV       A,#0
   \   00BA   9E....         MOV       ChartState,A
    644                  DATEepTerminateProcess();
   \   00BD   9A....         CALL      DATEepTerminateProcess
    645          
    646                  // Check for error reporting
    647                  if (DATEepCallBackStatusIsOk == cTrue)
   \   00C0   63             MOV       A,B
   \   00C1   51             DEC       A
   \   00C2   C4             MOVW      AX,DE
   \   00C3   BD09           BNZ       ??DATSbkCallBackEep_Static_20
    648                  {
    649                      /* No error detected */
    650                      mBankFlag_SetNoError(HandleSbk);
   \   00C5   CA....         ADDW      AX,#SingleBankFlags
   \   00C8   D6             MOVW      HL,AX
   \   00C9   7193           CLR1      [HL].1
   \   00CB   9B....         BR        N:??DATSbkCallBackEep_Static_19
    651                  }
    652                  else
    653                  {
    654                      /* Write Error detected ! */
    655                      mBankFlag_SetWritingError(HandleSbk);
   \                     ??DATSbkCallBackEep_Static_20:
   \   00CE   CA....         ADDW      AX,#SingleBankFlags
   \   00D1   D6             MOVW      HL,AX
   \   00D2   62             MOV       A,C
   \   00D3   7192           SET1      [HL].1
    656                      DATPeeSingleBankErrorIndication(HandleSbk, cDATSbkErrorWriting);
   \   00D5   A301           MOV       B,#1
   \   00D7   16....         MOVW      HL,#LWRD(DATPeeSingleBankErrorIndication)
   \   00DA   A4..           MOV       E,#BYTE3(DATPeeSingleBankErrorIndication)
   \   00DC   ..             CALLT     [__T_?FAR_CALL_L07]
   \   00DD   9B....         BR        N:??DATSbkCallBackEep_Static_19
    657                  }
    658          
    659                  break;
    660          
    661          
    662                  ///////////////////////////////////////////////////////////////////////
    663                  // Waiting for the terminated reading process ?
    664                  ///////////////////////////////////////////////////////////////////////
    665              case cChartState_Reading:
    666          
    667                  // Make a copy of DAT_EEP buffer into DAT_SBK current ram buffer (without the 16bits check-sum)...
    668                  mLIBmemcpy ((U8 *) (Sbk_AddBlockRam),
    669                              (U8 *) (DATEepBuffer + 1), Sbk_SizeBlockRam * sizeof(U16));
   \                     ??DATSbkCallBackEep_Static_15:
   \   00E0   87             MOV       A,[HL]
   \   00E1   A002           MOV       X,#2
   \   00E3   3188           MULU      X
   \   00E5   D4             MOVW      DE,AX
   \   00E6   12....         MOVW      BC,#DATEepBuffer+2
   \   00E9   AE02           MOV       A,[HL+0x02]
   \   00EB   70             MOV       X,A
   \   00EC   AE03           MOV       A,[HL+0x03]
   \   00EE   9A....         CALL      memcpy
    670          
    671          
    672                  // Check the 16bits check-sum (locate at the bank'top) ...
    673                  if (Compute16BitsCheckSum(DATEepBuffer + 1, Sbk_SizeBlockRam) == DATEepBuffer[0])
   \   00F1   891C           MOVW      AX,SP
   \   00F3   D6             MOVW      HL,AX
   \   00F4   87             MOV       A,[HL]
   \   00F5   72             MOV       C,A
   \   00F6   10....         MOVW      AX,#DATEepBuffer+2
   \   00F9   A300           MOV       B,#0
   \   00FB   9A....         CALL      Compute16BitsCheckSum
   \   00FE   30             XCH       A,X
   \   00FF   18....         SUB       A,DATEepBuffer
   \   0102   30             XCH       A,X
   \   0103   38....         SUBC      A,DATEepBuffer+1
   \   0106   6168           OR        A,X
   \   0108   BD0A           BNZ       ??DATSbkCallBackEep_Static_21
    674                  {
    675                      // The Reading process is done (bye bye)
    676                      ChartState = cChartState_Wait;
   \   010A   A100           MOV       A,#0
   \   010C   9E....         MOV       ChartState,A
    677                      DATEepTerminateProcess();
   \   010F   9A....         CALL      DATEepTerminateProcess
   \   0112   FA60           BR        ??DATSbkCallBackEep_Static_19
    678                  }
    679                  else  // Error detected, start "Compare" process
    680                  {
    681                      // >>> Get ready for "Compare" state <<<
    682                      ChartState = cChartState_CompareAfterReading;
   \                     ??DATSbkCallBackEep_Static_21:
   \   0114   A103           MOV       A,#3
   \   0116   9E....         MOV       ChartState,A
    683          
    684                      // Now, let's go for compare operation by the way of DAT_EEP
    685                      DATEepCompare(DATEepBuffer, (tDATEepOffset)0, (tDATEepOffset)(1 + Sbk_SizeBlockRam));
   \   0119   891C           MOVW      AX,SP
   \   011B   D6             MOVW      HL,AX
   \   011C   87             MOV       A,[HL]
   \   011D   41             INC       A
   \   011E   72             MOV       C,A
   \   011F   10....         MOVW      AX,#DATEepBuffer
   \   0122   A300           MOV       B,#0
   \   0124   9A....         CALL      DATEepCompare
   \   0127   FA4B           BR        ??DATSbkCallBackEep_Static_19
    686                      // NOTA : "+1" is for the 16bits check-sum (at the top of the bank)
    687                  }
    688          
    689                  break;
    690          
    691          
    692                  ///////////////////////////////////////////////////////////////////////
    693                  // Waiting for the terminated "Compare After Reading" process ?
    694                  ///////////////////////////////////////////////////////////////////////
    695              case cChartState_CompareAfterReading:
    696          
    697                  // Check compare error status (Compare Ok ?)
    698                  if (DATEepCallBackStatusIsOk == cTrue)
   \                     ??DATSbkCallBackEep_Static_16:
   \   0129   63             MOV       A,B
   \   012A   51             DEC       A
   \   012B   BD11           BNZ       ??DATSbkCallBackEep_Static_22
    699                  {
    700                      // Compare process is done (bye bye)
    701                      ChartState = cChartState_Wait;
   \   012D   A100           MOV       A,#0
   \   012F   9E....         MOV       ChartState,A
    702                      DATEepTerminateProcess();
   \   0132   9A....         CALL      DATEepTerminateProcess
    703          
    704                      // Compare Ok => bank is broken (this bank must be rebuild par DAT_PEE)
    705                      DATPeeRebuildSingleBank(HandleSbk);
   \                     ??DATSbkCallBackEep_Static_23:
   \   0135   62             MOV       A,C
   \   0136   16....         MOVW      HL,#LWRD(DATPeeRebuildSingleBank)
   \   0139   A4..           MOV       E,#BYTE3(DATPeeRebuildSingleBank)
   \   013B   ..             CALLT     [__T_?FAR_CALL_L07]
   \   013C   FA36           BR        ??DATSbkCallBackEep_Static_19
    706                  }
    707                  else  // Noisy reading => re-start reading process !
    708                  {
    709                      // Can we re-start reading process ?
    710                      if (DatSbk_CurrentNumberOfReadingRetry < cSbk_NbRetryReadDatEepMax)
   \                     ??DATSbkCallBackEep_Static_22:
   \   013E   8E....         MOV       A,DatSbk_CurrentNumberOfReadingRetry
   \   0141   4D64           CMP       A,#100
   \   0143   9D19           BNC       ??DATSbkCallBackEep_Static_24
    711                      {
    712                          // >>> Get ready for "Reading" state <<<
    713                          ChartState = cChartState_Reading;
   \   0145   A102           MOV       A,#2
   \   0147   9E....         MOV       ChartState,A
    714          
    715                          // Now, let's go for retry reading operation
    716                          DatSbk_CurrentNumberOfReadingRetry++;
   \   014A   8E....         MOV       A,DatSbk_CurrentNumberOfReadingRetry
   \   014D   41             INC       A
   \   014E   9E....         MOV       DatSbk_CurrentNumberOfReadingRetry,A
    717                          DATEepRead(DATEepBuffer, (tDATEepOffset)0, (tDATEepOffset)(1 + Sbk_SizeBlockRam));
   \   0151   87             MOV       A,[HL]
   \   0152   41             INC       A
   \   0153   72             MOV       C,A
   \   0154   10....         MOVW      AX,#DATEepBuffer
   \   0157   A300           MOV       B,#0
   \   0159   9A....         CALL      DATEepRead
   \   015C   FA16           BR        ??DATSbkCallBackEep_Static_19
    718                          // NOTA : "+1" is for the 16bits check-sum (at the top of the bank)
    719          
    720                      } else  // Max retry reached !
    721                      {
    722                          // Compare process is done (bye bye)
    723                          ChartState = cChartState_Wait;
   \                     ??DATSbkCallBackEep_Static_24:
   \   015E   A100           MOV       A,#0
   \   0160   9E....         MOV       ChartState,A
    724                          DATEepTerminateProcess();
   \   0163   9A....         CALL      DATEepTerminateProcess
    725          
    726                          /* Write Error reporting (external only) and
    727                             Inform the DAT_PEE compoment in order to rebuild the current bank */
    728                          DATPeeSingleBankErrorIndication(HandleSbk, cDATSbkErrorReading);
   \   0166   62             MOV       A,C
   \   0167   A300           MOV       B,#0
   \   0169   16....         MOVW      HL,#LWRD(DATPeeSingleBankErrorIndication)
   \   016C   A4..           MOV       E,#BYTE3(DATPeeSingleBankErrorIndication)
   \   016E   ..             CALLT     [__T_?FAR_CALL_L07]
    729                          DATPeeRebuildSingleBank(HandleSbk);
   \   016F   FAC4           BR        ??DATSbkCallBackEep_Static_23
    730                      }
    731                  }
    732          
    733                  break;
    734          
    735          
    736                  ///////////////////////////////////////////////////////////////////////
    737                  // Default/Error State
    738                  ///////////////////////////////////////////////////////////////////////
    739              default:
    740                  mLIBassert(cFalse);    /* error report */
   \                     ??DATSbkCallBackEep_Static_17:
   \   0171   9A....         CALL      LIBAssertionFailed
    741                  break;
    742              }
    743          }
   \                     ??DATSbkCallBackEep_Static_19:
   \   0174   B0             POP       AX
   \   0175   B0             POP       AX
   \   0176   B2             POP       BC
   \   0177   AF             RET       
   \   0178                  REQUIRE ?CL78K_V4_6_L00

   \                                 In  segment CLTVEC, align 2
   \                     __T_?FAR_CALL_L07:
   \   0000   ....           DW       ?FAR_CALL_L07
    744          
    745          

   Segment part sizes:

     Function/Label                 Bytes
     --------------                 -----
     SingleBankFlags                   5
     ChartState                        1
     DatSbk_CurrentNumberOfReadingRetry
                                       1
     DATSbkTableBankRom               20
     DATSbkMirrors                    60
     DATSbkInit                       25
     Compute16BitsCheckSum            58
     DATSbkIsBankProcessing           15
     DATSbkIsProcessing               25
     DATSbkStartReadingAllBanks       36
     DATSbkStartReading               39
     DATSbkStartUpdate                52
     DATSbkIsWriteOk                  27
     DATSbkCallBackEep                 9
     DATSbkCallBackEep_Static        376
     __T_?FAR_CALL_L07                 2

 
 376 bytes in segment BCODE
   2 bytes in segment CLTVEC
 286 bytes in segment CODE
  20 bytes in segment CONST
  67 bytes in segment NEAR_Z
 
 662 bytes of CODE  memory (+ 2 bytes shared)
  20 bytes of CONST memory
  67 bytes of DATA  memory

Errors: none
Warnings: none
