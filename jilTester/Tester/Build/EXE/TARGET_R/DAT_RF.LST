###############################################################################
#                                                                             #
# IAR C/C++ Compiler V4.61A/W32 for 78K0 and 78K0S      15/Feb/2011  13:26:37 #
# Copyright 1992-2008 IAR Systems AB.                                         #
#                                                                             #
#    Core         =  78k0                                                     #
#    Code model   =  Standard                                                 #
#                 =                                                           #
#    Source file  =  D:\X90_BCM\DEVELOPMENT\X90_BCM\K0\L7\BUILD\SOURCES\DAT\D #
#                    AT_RF.C                                                  #
#    Command line =  --code_model standard --core 78k0 -e                     #
#                    -DMEM_TYPE=__banked -DMEM_FAST=__saddr                   #
#                    -DCALLT_TYPE=__callt -DX90_PROJECT                       #
#                    --generate_callt_runtime_library_calls -Ohs              #
#                    "-IC:\Program Files\IAR Systems\Embedded Workbench       #
#                    5.0\78k\inc" "-IC:\Program Files\IAR Systems\Embedded    #
#                    Workbench 5.0\78k\inc\clib" -I. -I..\EXE\GEN\            #
#                    -I..\SOURCES\DAT -I..\SOURCES\LAP -I..\SOURCES\LDB_API   #
#                    -I..\SOURCES\LIB -I..\SOURCES\TOS -I.\LDB -DROM          #
#                    -DUSE_LIBSTK -DDONT_KEEP_OLD_TYPE_COMPATIBILITY -l       #
#                    ..\EXE\TARGET_R\DAT_RF.LST -o                            #
#                    ..\EXE\TARGET_R\DAT_RF.R26 D:\X90_BCM\DEVELOPMENT\X90_BC #
#                    M\K0\L7\BUILD\SOURCES\DAT\DAT_RF.C                       #
#    List file    =  ..\EXE\TARGET_R\DAT_RF.LST                               #
#    Object file  =  ..\EXE\TARGET_R\DAT_RF.R26                               #
#                                                                             #
#                                                                             #
###############################################################################

D:\X90_BCM\DEVELOPMENT\X90_BCM\K0\L7\BUILD\SOURCES\DAT\DAT_RF.C
      1          //******************************************************************************
      2          // Company:      Johnson Controls Inc.
      3          // -----------------------------------------------------------------------------
      4          // Copyright:    This software is JCI property.
      5          //               Duplication or disclosure without JCI written authorization
      6          //               is prohibited.
      7          // -----------------------------------------------------------------------------
      8          // Project:      X90_BCM
      9          // Language:     ANSI-C
     10          // -----------------------------------------------------------------------------
     11          // Component:    DAT_RF
     12          // -----------------------------------------------------------------------------
     13          // $Date:   May 26 2010 09:21:44  $
     14          // $Archive::   J:/_PVCSRoot/Renault/X90_BCM/SOFTWARE/PVCS/archives/DEVELOPMENT/X90_BCM/K0/L7/CMP/DAT/DAT_RF/Dat_RF.c-arc  $
     15          // $Revision:   1.16  $
     16          // -----------------------------------------------------------------------------
     17          // $Log::   J:/_PVCSRoot/Renault/X90_BCM/SOFTWARE/PVCS/archives/DEVELOPMENT/X90_BCM/K0/L7/CMP/DAT/DAT_RF/Dat_RF.c-arc  $
     18          // 
     19          //    Rev 1.16   May 26 2010 09:21:44   adzhelp
     20          // Cm008663: Long push events not stored
     21          // 
     22          //    Rev 1.15   May 20 2010 15:56:30   adzhelp
     23          // Cm008663: No binary change: correction for 'passing RF'
     24          // 
     25          //    Rev 1.14   Mar 09 2010 11:37:06   adzhelp
     26          // Cm007542:  Code review corrections
     27          // 
     28          //    Rev 1.13   Feb 22 2010 16:18:04   adzhelp
     29          // Cm007542:  TRF_RECU in frame $21$DB can be on when no frame is detected
     30          // 
     31          //    Rev 1.12   Feb 03 2010 12:14:38   adzhelp
     32          // Cm005245: Control of LIB_PCF refresh
     33          // 
     34          //    Rev 1.11   Dec 04 2009 16:48:58   adzhelp
     35          // Cm006719: Added counter for RC blocks with correct CRC
     36          // 
     37          //    Rev 1.10   Oct 07 2009 11:41:26   adzhelp
     38          // Cm006427: Functions moved to banked area
     39          // 
     40          //    Rev 1.9   Oct 06 2009 17:36:56   akodzhh
     41          // Cm006427: DATRfPushMemorized is now updated for UnlockDrDoor, UnlockAll and LockAll trough LAP_DLK(SDO).
     42          // 
     43          //    Rev 1.8   Sep 21 2009 13:29:20   adzhelp
     44          // Cm005180: Control cLDBRfDeactivateStrobe sent when RF channel disabled
     45          // 
     46          //    Rev 1.7   Sep 09 2009 14:20:38   ailievb
     47          // Cm005180: RKE: According to CLR#105 RKE operation has to be managed by AUTRECRF
     48          // 
     49          //    Rev 1.6   Sep 01 2009 14:05:10   amanevd
     50          // Cm005142: Status of Confidential Diagnostic routines included
     51          // 
     52          //    Rev 1.5   Aug 31 2009 16:13:42   amanevd
     53          // Cm005142: Transfer of Confidential Diagnostic to LIB_CFD
     54          // 
     55          //    Rev 1.4   May 25 2009 14:00:38   ailievb
     56          // Cm003265: Implementation of the Remote Keyless Entry functionality - CCover justifications
     57          // 
     58          //    Rev 1.3   May 07 2009 16:32:40   amanevd
     59          // Cm004915 - Second key learning causes problem
     60          // 
     61          //    Rev 1.2   May 04 2009 17:11:10   akodzhh
     62          // Cm004910: In $21 $DB diag request, TRF_OUV_COND, TRF_OUV are inverted.
     63          // 
     64          //    Rev 1.1   Apr 28 2009 10:55:06   adzhelp
     65          // Cm003276: Implementation of RF sleep mode management
     66          // 
     67          //    Rev 1.0   Apr 17 2009 10:37:04   ailievb
     68          // Initial revision.
     69          // 
     70          //******************************************************************************
     71          
     72          //--------------------------------------------------------------------------
     73          //  Body Identification
     74          //--------------------------------------------------------------------------
     75          
     76          #define dat_rf  "dat_rf"
     77          //--------------------------------------------------------------------------
     78          //  Included files
     79          //
     80          //  #include <system_file_name.h>
     81          //  #include "project_file_name.h"
     82          //--------------------------------------------------------------------------
     83          #include "lib.h"
     84          #include "tos.h"
     85          #include "dat.h"
     86          #include "dat_rf.h"
     87          #include "dat_rf.hgr"

   \                                 In  segment CONST, align 2
   \   tTOSSeqRuleType const __near DATRfReceptionManagement[4]
   \                     DATRfReceptionManagement:
   \   0000   ........       DW DATRfWakeUpBlockReceived, DATRfArmRCReceptionTimer
   \   0004   FF01           DB 255, 1
   \   0006   ........       DW DATRfNewRcBlockReceived, DATRfShortPushDetectedAndArmLongPushTimer
   \   000A   0201           DB 2, 1
   \   000C   ....           DW DATRfSiBlockReceivedAndLongPushWaitTimeElapsed
   \   000E   ....           DW DATRfLongPushDetected
   \   0010   0300           DB 3, 0
   \   0012   ....           DW DATRfRCReceptionTimeElapsedOrLongPushReceiveTimeElapsed
   \   0014   ....           DW DATRfSearchWakeUpBlock
   \   0016   FF00           DB 255, 0
     88          
     89          #include "lib_pcf.h"
     90          
     91          //--------------------------------------------------------------------------
     92          // Local constants
     93          //
     94          //  #define cConstantName   ((tType) ConstantValue)
     95          //--------------------------------------------------------------------------
     96          #define cSearchFramePeriodMs                                               \
     97            ((U8)(cDATRfLDBSearchFramePeriodMs/cDATCpuSleepGraphEnginePeriodMs))
     98          #define cRCReceptionTimeOut                                               \
     99            ((U8)(cDATRfRCReceptionTimeOut/cDATCpuSleepGraphEnginePeriodMs))
    100          #define cLongPushWaitTimeOut                                               \
    101            ((U8)(cDATRfLongPushWaitTimeOut/cDATCpuSleepGraphEnginePeriodMs))
    102          #define cLongPushReceiveTimeOut                                            \
    103            ((U8)(cDATRfLongPushReceiveTimeOut/cDATCpuSleepGraphEnginePeriodMs))
    104          #define cDiagMemorizationTime                                              \
    105            ((U8)(cDATRfDiagMemorizationTime/cDATCpuSleepGraphEnginePeriodMs))
    106          
    107          #define cDATCpuSleepGraphEnginePeriodMs ((U8)20)
    108          
    109          #define cNbMaxStockedInByte            ((U8)255)
    110          #define cNoPushedButton                ((U8)0)
    111          #define cButtonIsPushed                ((U8)1)
    112                                                 
    113          #define cRCFrame                       ((U8)1)
    114          #define cSIFrame                       ((U8)2)
    115          #define cNbBytesRCFrame                ((U8)11)
    116          #define cNbBytesSIFrame                ((U8)2)
    117                                                
    118          #define cIndiceKeyRf0                  ((U8)0)  // Key number used (Max = 3)
    119          #define cIndiceKeyRf1                  ((U8)1)  
    120          #define cIndiceKeyRf2                  ((U8)2)  
    121          #define cIndiceKeyRf3                  ((U8)3)
    122                                                 
    123          #define cNbBytesRemoteSK               ((U8)6)
    124          #define cNbBitsCryptage                ((U8)32)
    125          
    126          #ifdef _DIAGNOSTIC_MEMO_    //For Diagnostic   
    127              #define cNbCodeDiagMemorized         ((U8)8)
    128              //Diagnostic codes and constant values
    129              #define cDiagLongPressButton1        ((U8)0x01)
    130              #define cDiagShortPressButton2       ((U8)0x02)
    131              #define cDiagShortPressButton1       ((U8)0x04)
    132              #define cDiagLongPressButton2        ((U8)0x08)
    133              #define cDiagRfFrameReceived         ((U8)0x10)
    134              #define cDiagRfFrameReceivedAndValid ((U8)0x20)
    135              #define cDiagShortPressButton3       ((U8)0x40)
    136              #define cDiagLongPressButton3        ((U8)0x80)
    137          #endif
    138          
    139          //for graph motor                    
    140          #define cDATRfEnd                      ((U8)0xFF)
    141          //--------------------------------------------------------------------------
    142          //  Local macros
    143          //
    144          //  #define mMacroName   (MacroDefinition)
    145          //--------------------------------------------------------------------------
    146          
    147          //--------------------------------------------------------------------------
    148          //  Local types
    149          //
    150          //  struct  sStructureName { ... };
    151          //  union   uUnionName { ... };
    152          //  enum    eEnumerationName { ... };
    153          //  typedef Expression tTypeName;
    154          //--------------------------------------------------------------------------
    155          
    156          typedef union
    157          {
    158              U16 Format16Bit;
    159              struct
    160              {
    161                  U8 F8Bit1;
    162                  U8 F8Bit2;
    163              } Format8Bit;
    164          }tMot16Bit;
    165          
    166          //--------------------------------------------------------------------------
    167          //  Local data
    168          //
    169          //  static  tType   VariableName;
    170          //  static  tType*  pVariableName; 
    171          //--------------------------------------------------------------------------

   \                                 In  segment NEAR_Z, align 1, align-sorted
    172          static  BOOL  SearchFrameInCourse;    //Flag positioned by LDBCallBack
   \                     SearchFrameInCourse:
   \   0000                  DS 1
   \   0001                  REQUIRE __INIT_NEAR_Z

   \                                 In  segment NEAR_Z, align 1, align-sorted
    173          static  BOOL  WakeUpBlockReceived;    //Flag positioned by LDBCallBack                      
   \                     WakeUpBlockReceived:
   \   0000                  DS 1
   \   0001                  REQUIRE __INIT_NEAR_Z

   \                                 In  segment NEAR_Z, align 1, align-sorted
    174          static  BOOL  RCFrameReceived;        //Flag positioned by LDBCallBack                          
   \                     RCFrameReceived:
   \   0000                  DS 1
   \   0001                  REQUIRE __INIT_NEAR_Z

   \                                 In  segment NEAR_Z, align 1, align-sorted
    175          static  BOOL  SIFrameReceived;        //Flag positioned by LDBCallBack    
   \                     SIFrameReceived:
   \   0000                  DS 1
   \   0001                  REQUIRE __INIT_NEAR_Z
    176                          

   \                                 In  segment NEAR_Z, align 1, align-sorted
    177          static  BOOL  RCReceptionTimeOutIsActive;  
   \                     RCReceptionTimeOutIsActive:
   \   0000                  DS 1
   \   0001                  REQUIRE __INIT_NEAR_Z

   \                                 In  segment NEAR_Z, align 1, align-sorted
    178          static  BOOL  LongPushTimeOutIsActive;    
   \                     LongPushTimeOutIsActive:
   \   0000                  DS 1
   \   0001                  REQUIRE __INIT_NEAR_Z
    179          

   \                                 In  segment NEAR_Z, align 1, align-sorted
    180          static  U8    ButtonPushed;           //State of each button on the keyfob
   \                     ButtonPushed:
   \   0000                  DS 1
   \   0001                  REQUIRE __INIT_NEAR_Z
    181                                                    //  Bit0 represents the first button short push
    182                                                    //  Bit1 ---------- --- second button short push
    183                                                    //  ...
    184                                                    //  Bit3 ---------- --- fourth button short push
    185                                                    //  Bit4 represents the first button long push
    186                                                    //  ...
    187                                                    //Each bit = 0 indicates the button is not pushed
    188                                                    //---- --- = 1 indicates the button is pushed
    189          

   \                                 In  segment NEAR_Z, align 1, align-sorted
    190          static  U8    IndiceKeyRf;            // Key number used
   \                     IndiceKeyRf:
   \   0000                  DS 1
   \   0001                  REQUIRE __INIT_NEAR_Z
    191                                                    // Min = 0, Max = 3
    192          
    193          #ifdef _DIAGNOSTIC_MEMO_ //for Diagnostic   
    194            // Extern dat

   \                                 In  segment NEAR_Z, align 2, align-sorted
    195              U32 DATRfRCFrameIDEReceived;// RC frame Identifier received (extern for Diagnostic)
   \                     DATRfRCFrameIDEReceived:
   \   0000                  DS 4
   \   0004                  REQUIRE __INIT_NEAR_Z
    196          #else
    197              static U32   DATRfRCFrameIDEReceived;// RC frame Identifier received (extern for Diagnostic)
    198          #endif
    199          

   \                                 In  segment NEAR_Z, align 2, align-sorted
    200          static U16   RCFrameSIReceived;      // RC frame Sequence Increment received  
   \                     RCFrameSIReceived:
   \   0000                  DS 2
   \   0002                  REQUIRE __INIT_NEAR_Z

   \                                 In  segment NEAR_Z, align 1, align-sorted
    201          static U8    RCFrameCIDReceived;     // RC frame Command ID received 
   \                     RCFrameCIDReceived:
   \   0000                  DS 1
   \   0001                  REQUIRE __INIT_NEAR_Z
    202          

   \                                 In  segment NEAR_Z, align 1, align-sorted
    203          static U8    DataRCFrameReceived[cNbBytesRCFrame]; 
   \                     DataRCFrameReceived:
   \   0000                  DS 11
   \   000B                  REQUIRE __INIT_NEAR_Z

   \                                 In  segment NEAR_Z, align 1, align-sorted
    204          static U8    DataSIFrameReceived[cNbBytesSIFrame];    
   \                     DataSIFrameReceived:
   \   0000                  DS 2
   \   0002                  REQUIRE __INIT_NEAR_Z
    205          

   \                                 In  segment NEAR_Z, align 2, align-sorted
    206          static U32   SI28BitsLastRCFrameKnown;
   \                     SI28BitsLastRCFrameKnown:
   \   0000                  DS 4
   \   0004                  REQUIRE __INIT_NEAR_Z
    207          

   \                                 In  segment NEAR_Z, align 1, align-sorted
    208          static U8    TempoSearchFramePeriod;
   \                     TempoSearchFramePeriod:
   \   0000                  DS 1
   \   0001                  REQUIRE __INIT_NEAR_Z
    209          

   \                                 In  segment NEAR_Z, align 1, align-sorted
    210          static U8    TempoAlarmITForRCReceptionTimeOut;         //to manage a RCReception "timer"
   \                     TempoAlarmITForRCReceptionTimeOut:
   \   0000                  DS 1
   \   0001                  REQUIRE __INIT_NEAR_Z

   \                                 In  segment NEAR_Z, align 1, align-sorted
    211          static U8    TempoAlarmITForLongPushWaitTimeOut;        //to manage a SIWait "timer"
   \                     TempoAlarmITForLongPushWaitTimeOut:
   \   0000                  DS 1
   \   0001                  REQUIRE __INIT_NEAR_Z

   \                                 In  segment NEAR_Z, align 1, align-sorted
    212          static U8    TempoAlarmITForLongPushReceiveTimeOut;     //to manage a SIReceive "timer"
   \                     TempoAlarmITForLongPushReceiveTimeOut:
   \   0000                  DS 1
   \   0001                  REQUIRE __INIT_NEAR_Z
    213          
    214          #ifdef _DIAGNOSTIC_MEMO_    //for Diagnostic   

   \                                 In  segment NEAR_Z, align 1, align-sorted
    215              static U8  TempoAlarmITForDiag[cNbCodeDiagMemorized]; //to manage a Diag "timer"
   \                     TempoAlarmITForDiag:
   \   0000                  DS 8
   \   0008                  REQUIRE __INIT_NEAR_Z
    216          #endif
    217          
    218          #ifdef _PASSING_RF_
    219              static U8  TempoAlarmITForPassingRf;
    220          #endif
    221          
    222          //--------------------------------------------------------------------------
    223          //  Local function prototypes
    224          //  
    225          //  static tTypeRetour FunctionName(tTypeArgument1 ArgumentName1, ... );
    226          //--------------------------------------------------------------------------
    227          static void       RfPeriodicTask(void);
    228          
    229          static void       CallBckReceptionRCFrame(tAddress Adresse, tStatus Statut, tMsg * pMsg);
    230          static MEM_TYPE void       ExtractDataFromRCFrameReceived(void);
    231          static MEM_TYPE U32    BuildingSI28BitsTheoric(U32 SIStartValue);
    232          static MEM_TYPE U32    CalculRollingCodeTheoreticRCFrame(tDatRfMot32Bit Challenge);
    233          static void       UpdateKeyResynchronisation(void);
    234                            
    235          static void       CallBckReceptionSIFrame(tAddress Adresse, tStatus Statut, tMsg * pMsg);
    236                            
    237          #ifdef _DIAGNOSTIC_MEMO_    //For Diagnostic   
    238              static MEM_TYPE void     ArmerNbAlarmITForDiag(const U8 DiagnosticCode); //to arm a Diag "timer"
    239          #endif
    240          
    241          #ifdef X90_PROJECT
    242          static MEM_TYPE void DATRfLongPushDetected_Static(void);
    243          #endif
    244          
    245          //--------------------------------------------------------------------------
    246          //  Constant local Data
    247          //
    248          //  static const tType  VariableName;
    249          //--------------------------------------------------------------------------
    250          //--------------------------------------------------------------------------
    251          //  Exported data
    252          //
    253          //  tType   CMPVariableName;      (CMP: 3 characters to identify this component)
    254          //  tType*  pCMPVariableName;     (CMP: 3 characters to identify this component)
    255          //--------------------------------------------------------------------------
    256          #ifdef _DIAGNOSTIC_MEMO_ //for Diagnostic   

   \                                 In  segment NEAR_Z, align 1, align-sorted
    257              U8  DATRfPushMemorized; 
   \                     DATRfPushMemorized:
   \   0000                  DS 1
   \   0001                  REQUIRE __INIT_NEAR_Z
    258          #endif
    259          
    260          #ifdef _TEST_RF_  //counters used for RF hardware testing   

   \                                 In  segment NEAR_Z, align 1, align-sorted
    261              U8  DATRfNbWakeUpBlocksReceived;
   \                     DATRfNbWakeUpBlocksReceived:
   \   0000                  DS 1
   \   0001                  REQUIRE __INIT_NEAR_Z

   \                                 In  segment NEAR_Z, align 1, align-sorted
    262              U8  DATRfNbRCBlocksReceived;
   \                     DATRfNbRCBlocksReceived:
   \   0000                  DS 1
   \   0001                  REQUIRE __INIT_NEAR_Z

   \                                 In  segment NEAR_Z, align 1, align-sorted
    263              U8  DATRfNbRCBlocksReceivedAndOK;
   \                     DATRfNbRCBlocksReceivedAndOK:
   \   0000                  DS 1
   \   0001                  REQUIRE __INIT_NEAR_Z

   \                                 In  segment NEAR_Z, align 1, align-sorted
    264              U8  DATRfNbRCBlocksReceivedCrcOK;
   \                     DATRfNbRCBlocksReceivedCrcOK:
   \   0000                  DS 1
   \   0001                  REQUIRE __INIT_NEAR_Z

   \                                 In  segment NEAR_Z, align 1, align-sorted
    265              U8  DATRfNbSIBlocksReceived;
   \                     DATRfNbSIBlocksReceived:
   \   0000                  DS 1
   \   0001                  REQUIRE __INIT_NEAR_Z

   \                                 In  segment NEAR_Z, align 1, align-sorted
    266              U8  DATRfNbSIBlocksReceivedAndOK;
   \                     DATRfNbSIBlocksReceivedAndOK:
   \   0000                  DS 1
   \   0001                  REQUIRE __INIT_NEAR_Z
    267          #endif
    268          

   \                                 In  segment NEAR_Z, align 2, align-sorted
    269          tDatRfMot32Bit DATRfRCFrameSRReceived;
   \                     DATRfRCFrameSRReceived:
   \   0000                  DS 4
   \   0004                  REQUIRE __INIT_NEAR_Z
    270          //--------------------------------------------------------------------------
    271          //  Constant exported data
    272          // 
    273          //  const tType   CMPVariableName;(CMP: 3 characters to identify this component)
    274          //--------------------------------------------------------------------------

   \                                 In  segment CONST, align 2
    275          const tRxSpontWithAddr DATRfRxSpontTable[] = //tableau de pointeurs de fonctions
   \                     DATRfRxSpontTable:
   \   0000   ....0100       DW CallBckReceptionRCFrame, 1, CallBckReceptionSIFrame, 2
   \          ....0200
    276          {
    277              {CallBckReceptionRCFrame,       cRCFrame},
    278              {CallBckReceptionSIFrame,       cSIFrame},
    279          };
    280          
    281          #ifdef X90_PROJECT
    282          static MEM_TYPE void DATRfInit_Static(void);
    283          static MEM_TYPE void DATRfShortPushDetectedAndArmLongPushTimer_Static(void);
    284          static MEM_TYPE BOOL DATRfSiBlockReceivedAndLongPushWaitTimeElapsed_Static(void);
    285          static MEM_TYPE BOOL DATRfNewRcBlockReceived_Static(void);
    286          #endif
    287          
    288          //==============================================================================
    289          //*...........................................................................*
    290          //*............................ LOCAL FUNCTIONS ..............................*
    291          //*...........................................................................*
    292          //==============================================================================/
    293          //==============================================================================
    294          //  DESCRIPTION : ArmerNbAlarmITForDiag
    295          //  
    296          //  PARAMETERS (Type,Name,Min,Max) :
    297          //
    298          //  RETURN VALUE :   none
    299          // 
    300          //  DESIGN INFORMATION : Rearms "timer" to cDATRfDiagMemorizationTime
    301          //     
    302          //==============================================================================
    303          #ifdef _DIAGNOSTIC_MEMO_    //For Diagnostic   

   \                                 In  segment BCODE, align 1, keep-with-next
    304          static MEM_TYPE void   ArmerNbAlarmITForDiag(const U8 DiagnosticCode) //to set a Diag "timer"
   \                     ArmerNbAlarmITForDiag:
    305          {
   \   0000                  ; * Stack frame (at entry) *
   \   0000                  ; Param size: 0
   \   0000   B3             PUSH      BC
   \   0001                  ; Total Auto size: 0
   \   0001   73             MOV       B,A
    306              U8 Counter;
    307          
    308              DATRfPushMemorized |= DiagnosticCode; 
   \   0002   8E....         MOV       A,DATRfPushMemorized
   \   0005   616B           OR        A,B
   \   0007   9E....         MOV       DATRfPushMemorized,A
    309              for (Counter = 0; Counter<cNbCodeDiagMemorized ; Counter++)
   \   000A   A200           MOV       C,#0
   \   000C   14....         MOVW      DE,#TempoAlarmITForDiag
    310              {
    311                  if(DiagnosticCode == (0x01<<Counter))
   \                     ??ArmerNbAlarmITForDiag_0:
   \   000F   100100         MOVW      AX,#1
   \   0012   ..             CALLT     [__T_?I_LSH_L02]
   \   0013   D6             MOVW      HL,AX
   \   0014   63             MOV       A,B
   \   0015   A000           MOV       X,#0
   \   0017   611E           SUB       A,L
   \   0019   30             XCH       A,X
   \   001A   613F           SUBC      A,H
   \   001C   6168           OR        A,X
   \   001E   BD05           BNZ       ??DATRfArmerNbAlarmITForDiag_0
    312                  {
    313                      TempoAlarmITForDiag[Counter] = cDiagMemorizationTime;
   \   0020   A164           MOV       A,#100
   \   0022   B5             PUSH      DE
   \   0023   B6             POP       HL
   \   0024   97             MOV       [HL],A
    314                  }
    315              }
   \                     ??DATRfArmerNbAlarmITForDiag_0:
   \   0025   42             INC       C
   \   0026   62             MOV       A,C
   \   0027   B5             PUSH      DE
   \   0028   B6             POP       HL
   \   0029   86             INCW      HL
   \   002A   B7             PUSH      HL
   \   002B   B4             POP       DE
   \   002C   4D08           CMP       A,#8
   \   002E   8DDF           BC        ??ArmerNbAlarmITForDiag_0
    316          }
   \   0030   B2             POP       BC
   \   0031   AF             RET       
   \   0032                  REQUIRE ?CL78K_V4_6_L00
    317          #endif
    318          
    319          //==============================================================================
    320          //  DESCRIPTION : CallBckReceptionRCFrame
    321          //  
    322          //  PARAMETERS (Type,Name,Min,Max) :
    323          //    (tAddress Adresse, tStatus Statut, tMsg * pMsg)
    324          //
    325          //  RETURN VALUE :   none
    326          // 
    327          //  DESIGN INFORMATION :   
    328          //  Fonction called by LDB part to do a copy of the received RC frame
    329          //     
    330          //==============================================================================*/

   \                                 In  segment CODE, align 1, keep-with-next
    331          static void CallBckReceptionRCFrame(tAddress Adresse, tStatus Statut, tMsg * pMsg)
   \                     CallBckReceptionRCFrame:
    332          {
   \   0000                  ; * Stack frame (at entry) *
   \   0000                  ; Param size: 0
   \   0000                  ; Total Auto size: 0
    333              //Copy contents in DataRCFrameReceived
    334              mLIBmemcpy ((U8*)DataRCFrameReceived, pMsg->pBuffer, cNbBytesRCFrame);
   \   0000   C4             MOVW      AX,DE
   \   0001   D6             MOVW      HL,AX
   \   0002   87             MOV       A,[HL]
   \   0003   70             MOV       X,A
   \   0004   AE01           MOV       A,[HL+0x01]
   \   0006   D4             MOVW      DE,AX
   \   0007   16....         MOVW      HL,#DataRCFrameReceived
   \   000A   A30B           MOV       B,#11
   \                     ??CallBckReceptionRCFrame_0:
   \   000C   85             MOV       A,[DE]
   \   000D   97             MOV       [HL],A
   \   000E   86             INCW      HL
   \   000F   84             INCW      DE
   \   0010   8BFA           DBNZ      B, ??CallBckReceptionRCFrame_0
    335          
    336          #ifdef _PASSING_RF_
    337              {
    338                  if (TempoAlarmITForPassingRf == 0)
    339                  {
    340                      TempoAlarmITForPassingRf = cRCReceptionTimeOut;
    341                      RCFrameReceived = cTrue;  
    342                  }
    343                  else
    344                  {} //wait RCReceptionTimeOut
    345            }
    346          #else
    347              //Flag to signal: RC frame received
    348              RCFrameReceived = cTrue;  
   \   0012   A101           MOV       A,#1
   \   0014   9E....         MOV       RCFrameReceived,A
    349          #endif
    350          
    351          #ifdef _TEST_RF_ //update counters used for RF hardware testing   
    352              if (DATRfNbRCBlocksReceived < cNbMaxStockedInByte)
   \   0017   8E....         MOV       A,DATRfNbRCBlocksReceived
   \   001A   4DFF           CMP       A,#255
   \   001C   AD04           BZ        ??DATRfArmerNbAlarmITForDiag_33
    353              {
    354                  DATRfNbRCBlocksReceived++;
   \   001E   41             INC       A
   \   001F   9E....         MOV       DATRfNbRCBlocksReceived,A
    355              }
    356              else
    357              {} //nothing to do
    358          #endif
    359          }
   \                     ??DATRfArmerNbAlarmITForDiag_33:
   \   0022   AF             RET       
   \   0023                  REQUIRE ?CL78K_V4_6_L00
    360          
    361          //=============================================================================
    362          //  DESCRIPTION : ExtractDataFromRCFrameReceived
    363          //  
    364          //  PARAMETERS (Type,Name,Min,Max) :   none
    365          //
    366          //  RETURN VALUE :   none
    367          // 
    368          //  DESIGN INFORMATION : Extract useful data from incoming RfFrame
    369          //     
    370          //==============================================================================

   \                                 In  segment BCODE, align 1, keep-with-next
    371          static MEM_TYPE void ExtractDataFromRCFrameReceived(void)
   \                     ExtractDataFromRCFrameReceived:
    372          {
   \   0000                  ; * Stack frame (at entry) *
   \   0000                  ; Param size: 0
   \   0000   B3             PUSH      BC
   \   0001                  ; Total Auto size: 12
   \   0001   ..             CALLT     [__T_?FUNC_ENTER_L06]
   \   0002   0C00           DW        0xC
    373          #ifdef _TEST_RF_ //initialize RC frame emitted when testing RF hardware
    374              U8 DataRCFrameEmitted[cNbBytesRCFrame] = mInitValueOfRCFrameEmitted();
   \   0004   891C           MOVW      AX,SP
   \   0006   D4             MOVW      DE,AX
   \   0007   16....         MOVW      HL,#`?<Constant {194, 240, 165, 194, 129, 179, 64, `
   \   000A   120B00         MOVW      BC,#11
   \   000D   9A....         CALL      ?MOVE_LONG_L06
    375              U8 NbByte;
    376          #endif
    377          
    378              // Extract the key's Identifier transmitted from the RC frame received
    379              DATRfRCFrameIDEReceived =
    380                (  ( ((U32)(DataRCFrameReceived[0]) << 24) & (U32)0xFF000000UL )
    381                 + ( ((U32)(DataRCFrameReceived[1]) << 16) & (U32)0x00FF0000 )
    382                 + ( ((U32)(DataRCFrameReceived[2]) <<  8) & (U32)0x0000FF00 )
    383                 + ( ((U32)(DataRCFrameReceived[3])      ) & (U32)0x000000FF )  );
   \   0010   8E....         MOV       A,DataRCFrameReceived+3
   \   0013   74             MOV       E,A
   \   0014   A500           MOV       D,#0
   \   0016   160000         MOVW      HL,#0
   \   0019   B7             PUSH      HL
   \   001A   B5             PUSH      DE
   \   001B   8E....         MOV       A,DataRCFrameReceived+2
   \   001E   A200           MOV       C,#0
   \   0020   70             MOV       X,A
   \   0021   63             MOV       A,B
   \   0022   E2             XCHW      AX,BC
   \   0023   E2             XCHW      AX,BC
   \   0024   60             MOV       A,X
   \   0025   A000           MOV       X,#0
   \   0027   B3             PUSH      BC
   \   0028   B1             PUSH      AX
   \   0029   8E....         MOV       A,DataRCFrameReceived+1
   \   002C   70             MOV       X,A
   \   002D   63             MOV       A,B
   \   002E   D2             MOVW      BC,AX
   \   002F   70             MOV       X,A
   \   0030   B3             PUSH      BC
   \   0031   B1             PUSH      AX
   \   0032   8E....         MOV       A,DataRCFrameReceived
   \   0035   73             MOV       B,A
   \   0036   67             MOV       A,H
   \   0037   72             MOV       C,A
   \   0038   891C           MOVW      AX,SP
   \   003A   E6             XCHW      AX,HL
   \   003B   E2             XCHW      AX,BC
   \   003C   30             XCH       A,X
   \   003D   0902           ADD       A,[HL+0x02]
   \   003F   30             XCH       A,X
   \   0040   E2             XCHW      AX,BC
   \   0041   B6             POP       HL
   \   0042   B6             POP       HL
   \   0043   D6             MOVW      HL,AX
   \   0044   891C           MOVW      AX,SP
   \   0046   E6             XCHW      AX,HL
   \   0047   0901           ADD       A,[HL+0x01]
   \   0049   E2             XCHW      AX,BC
   \   004A   E2             XCHW      AX,BC
   \   004B   B6             POP       HL
   \   004C   B6             POP       HL
   \   004D   77             MOV       H,A
   \   004E   891C           MOVW      AX,SP
   \   0050   E6             XCHW      AX,HL
   \   0051   30             XCH       A,X
   \   0052   0F             ADD       A,[HL]
   \   0053   30             XCH       A,X
   \   0054   E2             XCHW      AX,BC
   \   0055   E2             XCHW      AX,BC
   \   0056   B6             POP       HL
   \   0057   B6             POP       HL
   \   0058   03....         MOVW      DATRfRCFrameIDEReceived,AX
   \   005B   C2             MOVW      AX,BC
   \   005C   03....         MOVW      DATRfRCFrameIDEReceived+2,AX
    384          
    385              // Extract Sequence Increment Field from the RC frame received 
    386              RCFrameSIReceived =
    387                (  ( (((U16)DataRCFrameReceived[5]) >> 2) & (U16)0x003F ) //All bits to 0 except 1st 6 
    388                 + ( (((U16)DataRCFrameReceived[4]) << 6) & (U16)0x03C0 )  );
   \   005F   8E....         MOV       A,DataRCFrameReceived+4
   \   0062   A040           MOV       X,#64
   \   0064   3188           MULU      X
   \   0066   5D03           AND       A,#3
   \   0068   D6             MOVW      HL,AX
   \   0069   8E....         MOV       A,DataRCFrameReceived+5
   \   006C   25             RORC      A,0x1
   \   006D   21             CLR1      CY
   \   006E   25             RORC      A,0x1
   \   006F   74             MOV       E,A
   \   0070   67             MOV       A,H
   \   0071   30             XCH       A,X
   \   0072   610C           ADD       A,E
   \   0074   30             XCH       A,X
   \   0075   2D00           ADDC      A,#0
   \   0077   03....         MOVW      RCFrameSIReceived,AX
    389          
    390              // Extract Rolling Code from the RC frame received
    391              DATRfRCFrameSRReceived.Format32Bit =   (U32)(((DataRCFrameReceived[8] << 6)& 0xFF) 
    392                            | (DataRCFrameReceived[9] >> 2));
    393              DATRfRCFrameSRReceived.Format32Bit = (DATRfRCFrameSRReceived.Format32Bit <<8) 
    394                            | (U32)(((DataRCFrameReceived[7] << 6)& 0xFF) | (DataRCFrameReceived[8] >> 2));
    395              DATRfRCFrameSRReceived.Format32Bit = (DATRfRCFrameSRReceived.Format32Bit <<8) 
    396                            | (U32)(((DataRCFrameReceived[6] << 6)& 0xFF) | (DataRCFrameReceived[7] >> 2));
    397              DATRfRCFrameSRReceived.Format32Bit = (DATRfRCFrameSRReceived.Format32Bit <<8) 
    398                            | (U32)(((DataRCFrameReceived[5] << 6)& 0xFF) | (DataRCFrameReceived[6] >> 2));
   \   007A   8E....         MOV       A,DataRCFrameReceived+6
   \   007D   25             RORC      A,0x1
   \   007E   21             CLR1      CY
   \   007F   25             RORC      A,0x1
   \   0080   76             MOV       L,A
   \   0081   8E....         MOV       A,DataRCFrameReceived+5
   \   0084   A040           MOV       X,#64
   \   0086   3188           MULU      X
   \   0088   60             MOV       A,X
   \   0089   A000           MOV       X,#0
   \   008B   616E           OR        A,L
   \   008D   30             XCH       A,X
   \   008E   120000         MOVW      BC,#0
   \   0091   317F01         BF        A.7, ??DATRfArmerNbAlarmITForDiag_1
   \   0094   92             DECW      BC
   \                     ??DATRfArmerNbAlarmITForDiag_1:
   \   0095   B3             PUSH      BC
   \   0096   B1             PUSH      AX
   \   0097   8E....         MOV       A,DataRCFrameReceived+7
   \   009A   21             CLR1      CY
   \   009B   25             RORC      A,0x1
   \   009C   21             CLR1      CY
   \   009D   25             RORC      A,0x1
   \   009E   76             MOV       L,A
   \   009F   8E....         MOV       A,DataRCFrameReceived+6
   \   00A2   A040           MOV       X,#64
   \   00A4   3188           MULU      X
   \   00A6   60             MOV       A,X
   \   00A7   A000           MOV       X,#0
   \   00A9   616E           OR        A,L
   \   00AB   30             XCH       A,X
   \   00AC   120000         MOVW      BC,#0
   \   00AF   317F01         BF        A.7, ??DATRfArmerNbAlarmITForDiag_2
   \   00B2   92             DECW      BC
   \                     ??DATRfArmerNbAlarmITForDiag_2:
   \   00B3   B3             PUSH      BC
   \   00B4   B1             PUSH      AX
   \   00B5   8E....         MOV       A,DataRCFrameReceived+8
   \   00B8   21             CLR1      CY
   \   00B9   25             RORC      A,0x1
   \   00BA   21             CLR1      CY
   \   00BB   25             RORC      A,0x1
   \   00BC   76             MOV       L,A
   \   00BD   8E....         MOV       A,DataRCFrameReceived+7
   \   00C0   A040           MOV       X,#64
   \   00C2   3188           MULU      X
   \   00C4   60             MOV       A,X
   \   00C5   A000           MOV       X,#0
   \   00C7   616E           OR        A,L
   \   00C9   30             XCH       A,X
   \   00CA   120000         MOVW      BC,#0
   \   00CD   317F01         BF        A.7, ??DATRfArmerNbAlarmITForDiag_3
   \   00D0   92             DECW      BC
   \                     ??DATRfArmerNbAlarmITForDiag_3:
   \   00D1   B3             PUSH      BC
   \   00D2   B1             PUSH      AX
   \   00D3   8E....         MOV       A,DataRCFrameReceived+9
   \   00D6   21             CLR1      CY
   \   00D7   25             RORC      A,0x1
   \   00D8   21             CLR1      CY
   \   00D9   25             RORC      A,0x1
   \   00DA   76             MOV       L,A
   \   00DB   8E....         MOV       A,DataRCFrameReceived+8
   \   00DE   A040           MOV       X,#64
   \   00E0   3188           MULU      X
   \   00E2   30             XCH       A,X
   \   00E3   616E           OR        A,L
   \   00E5   30             XCH       A,X
   \   00E6   120000         MOVW      BC,#0
   \   00E9   317F01         BF        A.7, ??DATRfArmerNbAlarmITForDiag_4
   \   00EC   92             DECW      BC
   \                     ??DATRfArmerNbAlarmITForDiag_4:
   \   00ED   E2             XCHW      AX,BC
   \   00EE   60             MOV       A,X
   \   00EF   E2             XCHW      AX,BC
   \   00F0   72             MOV       C,A
   \   00F1   60             MOV       A,X
   \   00F2   A000           MOV       X,#0
   \   00F4   9A....         CALL      ?L_IOR_L03
   \   00F7   E2             XCHW      AX,BC
   \   00F8   60             MOV       A,X
   \   00F9   E2             XCHW      AX,BC
   \   00FA   72             MOV       C,A
   \   00FB   60             MOV       A,X
   \   00FC   A000           MOV       X,#0
   \   00FE   9A....         CALL      ?L_IOR_L03
   \   0101   E2             XCHW      AX,BC
   \   0102   60             MOV       A,X
   \   0103   E2             XCHW      AX,BC
   \   0104   72             MOV       C,A
   \   0105   60             MOV       A,X
   \   0106   A000           MOV       X,#0
   \   0108   9A....         CALL      ?L_IOR_L03
   \   010B   03....         MOVW      DATRfRCFrameSRReceived,AX
   \   010E   C2             MOVW      AX,BC
   \   010F   03....         MOVW      DATRfRCFrameSRReceived+2,AX
    399          
    400              // Extract the pushed button from the RC frame received
    401              RCFrameCIDReceived = (U8)(DataRCFrameReceived[4] >> 4) & (U8)0x0F;
   \   0112   8E....         MOV       A,DataRCFrameReceived+4
   \   0115   24             ROR       A,0x1
   \   0116   25             RORC      A,0x1
   \   0117   25             RORC      A,0x1
   \   0118   25             RORC      A,0x1
   \   0119   5D0F           AND       A,#15
   \   011B   9E....         MOV       RCFrameCIDReceived,A
    402          
    403          
    404          
    405          #ifdef _TEST_RF_ //update counters used for RF hardware testing   
    406              for(NbByte = 0;
   \   011E   A000           MOV       X,#0
   \   0120   14....         MOVW      DE,#DataRCFrameReceived
   \   0123   D6             MOVW      HL,AX
   \   0124   891C           MOVW      AX,SP
   \   0126   E6             XCHW      AX,HL
   \                     ??ExtractDataFromRCFrameReceived_0:
   \   0127   87             MOV       A,[HL]
   \   0128   72             MOV       C,A
   \   0129   85             MOV       A,[DE]
   \   012A   614A           CMP       A,C
   \   012C   BD08           BNZ       ??DATRfArmerNbAlarmITForDiag_5
    407                  ( (NbByte<cNbBytesRCFrame) && (DataRCFrameReceived[NbByte] == DataRCFrameEmitted[NbByte]) ); 
    408                   NbByte++)
   \   012E   40             INC       X
   \   012F   60             MOV       A,X
   \   0130   86             INCW      HL
   \   0131   84             INCW      DE
   \   0132   4D0B           CMP       A,#11
   \   0134   8DF1           BC        ??ExtractDataFromRCFrameReceived_0
    409              {} //compare contents
    410          
    411              if((NbByte == cNbBytesRCFrame) && (DATRfNbRCBlocksReceivedAndOK < cNbMaxStockedInByte))
   \                     ??DATRfArmerNbAlarmITForDiag_5:
   \   0136   60             MOV       A,X
   \   0137   4D0B           CMP       A,#11
   \   0139   BD0B           BNZ       ??DATRfArmerNbAlarmITForDiag_6
   \   013B   8E....         MOV       A,DATRfNbRCBlocksReceivedAndOK
   \   013E   4DFF           CMP       A,#255
   \   0140   AD04           BZ        ??DATRfArmerNbAlarmITForDiag_6
    412              {
    413                  DATRfNbRCBlocksReceivedAndOK++;
   \   0142   41             INC       A
   \   0143   9E....         MOV       DATRfNbRCBlocksReceivedAndOK,A
    414              }
    415              else
    416              {} //nothing to do
    417          
    418              if (DATRfNbRCBlocksReceivedCrcOK < cNbMaxStockedInByte)
   \                     ??DATRfArmerNbAlarmITForDiag_6:
   \   0146   8E....         MOV       A,DATRfNbRCBlocksReceivedCrcOK
   \   0149   4DFF           CMP       A,#255
   \   014B   AD04           BZ        ??DATRfArmerNbAlarmITForDiag_7
    419              {
    420                  DATRfNbRCBlocksReceivedCrcOK++;
   \   014D   41             INC       A
   \   014E   9E....         MOV       DATRfNbRCBlocksReceivedCrcOK,A
    421              }
    422          
    423          #endif
    424          }
   \                     ??DATRfArmerNbAlarmITForDiag_7:
   \   0151   ..             CALLT     [__T_?FUNC_DEALL_L06]
   \   0152   0C00           DW        0xC
   \   0154   B2             POP       BC
   \   0155   AF             RET       
   \   0156                  REQUIRE ?CL78K_V4_6_L00
    425          
    426          //==============================================================================
    427          //   Function Name : 
    428          //     static void UpdateKeyResynchronisation( void )
    429          //----------------------------------------------------------------------------
    430          //   Function Role  :
    431          //     allows to update if current Key needs to be resynchronise
    432          //   Parameters Meaning :
    433          //     
    434          //   Result Meaning :
    435          //     
    436          //   Function  Description :
    437          //     
    438          //==============================================================================

   \                                 In  segment CODE, align 1, keep-with-next
    439          static void UpdateKeyResynchronisation( void )
   \                     UpdateKeyResynchronisation:
    440          {
   \   0000                  ; * Stack frame (at entry) *
   \   0000                  ; Param size: 0
   \   0000   B3             PUSH      BC
   \   0001                  ; Total Auto size: 0
    441              U8 KeyNeedResync;
    442          
    443              KeyNeedResync = mDATRead (U8Bit, ResynchroRequest, Default);
    444                            //1 decal de: la position de la cl
    445              KeyNeedResync |= (U8)(1 << IndiceKeyRf);
   \   0001   8E....         MOV       A,IndiceKeyRf
   \   0004   72             MOV       C,A
   \   0005   100100         MOVW      AX,#1
   \   0008   ..             CALLT     [__T_?I_LSH_L02]
   \   0009   60             MOV       A,X
   \   000A   68....         OR        A,DATDbkMirrors+208
   \   000D   70             MOV       X,A
    446              mDATWrite (U8Bit, ResynchroRequest, KeyNeedResync, Default);
   \   000E   8E....         MOV       A,DATDbkMirrors+208
   \   0011   6148           CMP       A,X
   \   0013   AD09           BZ        ??DATRfArmerNbAlarmITForDiag_34
   \   0015   60             MOV       A,X
   \   0016   9E....         MOV       DATDbkMirrors+208,A
   \   0019   A104           MOV       A,#4
   \   001B   9A....         CALL      DATDbkStartUpdate
    447          }
   \                     ??DATRfArmerNbAlarmITForDiag_34:
   \   001E   B2             POP       BC
   \   001F   AF             RET       
   \   0020                  REQUIRE ?CL78K_V4_6_L00
    448          
    449          //==============================================================================
    450          //   Function Name : 
    451          //     static U32 ReBuildSI28Bits(U16 SI10BitsReceived, U32 SI28Bits)
    452          //----------------------------------------------------------------------------
    453          //   Function Role  :
    454          //     
    455          //   Parameters Meaning :
    456          //      U16 SI10BitsReceived :  SI10Bits received
    457          //      U32 SI28Bits :          Last SI28Bits saved.
    458          //   Result Meaning :
    459          //     
    460          //   Function  Description :
    461          //    SI10BitsReceived : 10 low bits of the SI28Bits used in the transponder to     
    462          //    calculate the encryption.
    463          //    This SI28Bits is increased when a key is pressed 
    464          //    SI28Bits : enregistration in EEPROM of last SI28bits
    465          //==============================================================================

   \                                 In  segment BCODE, align 1, keep-with-next
    466          static MEM_TYPE U32 ReBuildSI28Bits(U16 SI10BitsReceived, U32 SI28Bits)
   \                     ReBuildSI28Bits:
    467          {
   \   0000                  ; * Stack frame (at entry) *
   \   0000                  ; Param size: 4
   \   0000   B1             PUSH      AX
   \   0001                  ; Total Auto size: 6
   \   0001   B7             PUSH      HL
   \   0002   B7             PUSH      HL
   \   0003   891C           MOVW      AX,SP
   \   0005   CA0C00         ADDW      AX,#12
   \   0008   D6             MOVW      HL,AX
   \   0009   AE02           MOV       A,[HL+0x02]
   \   000B   72             MOV       C,A
   \   000C   AE03           MOV       A,[HL+0x03]
   \   000E   73             MOV       B,A
   \   000F   87             MOV       A,[HL]
   \   0010   70             MOV       X,A
   \   0011   AE01           MOV       A,[HL+0x01]
    468              U16  SI10BitsPrevious;
    469              U32  SI28BitsPrevious; // SI28Bits of the last correct RC frame of this key
    470              U32  SI28BitsCalculated;
    471           
    472            
    473              SI28BitsPrevious = (SI28Bits & (U32)0x0FFFFFFF);    //force to 0 all bits except 28first
   \   0013   D6             MOVW      HL,AX
   \   0014   891C           MOVW      AX,SP
   \   0016   E6             XCHW      AX,HL
   \   0017   14FF0F         MOVW      DE,#4095
   \   001A   B5             PUSH      DE
   \   001B   A5FF           MOV       D,#255
   \   001D   B5             PUSH      DE
   \   001E   9A....         CALL      ?L_AND_L03
   \   0021   BE01           MOV       [HL+0x01],A
   \   0023   60             MOV       A,X
   \   0024   97             MOV       [HL],A
   \   0025   C2             MOVW      AX,BC
   \   0026   BE03           MOV       [HL+0x03],A
   \   0028   60             MOV       A,X
   \   0029   BE02           MOV       [HL+0x02],A
    474              SI10BitsPrevious = ((U16)SI28BitsPrevious) & 0x03FF;//force to 0 all bits except 10first
    475          
    476          
    477              // le SI28Bits calculed is the sum of :
    478              //                 - previous SI28bits which has its 10 low bits masked 
    479              //                 - SI10Bits received (sent to BCM in true value)
    480              //                 - potential carry over of 0x400
    481          
    482              if (SI10BitsPrevious < SI10BitsReceived) //less than 1024 pushes were done
   \   002B   AE04           MOV       A,[HL+0x04]
   \   002D   70             MOV       X,A
   \   002E   AE05           MOV       A,[HL+0x05]
   \   0030   D4             MOVW      DE,AX
   \   0031   87             MOV       A,[HL]
   \   0032   70             MOV       X,A
   \   0033   AE01           MOV       A,[HL+0x01]
   \   0035   5D03           AND       A,#3
   \   0037   30             XCH       A,X
   \   0038   611C           SUB       A,E
   \   003A   60             MOV       A,X
   \   003B   613D           SUBC      A,D
   \   003D   10FF0F         MOVW      AX,#4095
   \   0040   160000         MOVW      HL,#0
   \   0043   9D29           BNC       ??DATRfArmerNbAlarmITForDiag_8
    483              {
    484                  SI28BitsCalculated = (SI28BitsPrevious & (U32)0x0FFFFC00) //force to 0 last 10 bits
    485                                       + (U32)SI10BitsReceived;            //paste 10 SIbits received
   \   0045   B7             PUSH      HL
   \   0046   B5             PUSH      DE
   \   0047   B1             PUSH      AX
   \   0048   1000FC         MOVW      AX,#64512
   \   004B   B1             PUSH      AX
   \   004C   891C           MOVW      AX,SP
   \   004E   CA0800         ADDW      AX,#8
   \   0051   D6             MOVW      HL,AX
   \   0052   87             MOV       A,[HL]
   \   0053   70             MOV       X,A
   \   0054   AE01           MOV       A,[HL+0x01]
   \   0056   9A....         CALL      ?L_AND_L03
   \   0059   D6             MOVW      HL,AX
   \   005A   891C           MOVW      AX,SP
   \   005C   E6             XCHW      AX,HL
   \   005D   30             XCH       A,X
   \   005E   0F             ADD       A,[HL]
   \   005F   30             XCH       A,X
   \   0060   0901           ADD       A,[HL+0x01]
   \   0062   E2             XCHW      AX,BC
   \   0063   30             XCH       A,X
   \   0064   2902           ADDC      A,[HL+0x02]
   \   0066   30             XCH       A,X
   \   0067   2903           ADDC      A,[HL+0x03]
   \   0069   E2             XCHW      AX,BC
   \   006A   B6             POP       HL
   \   006B   B6             POP       HL
   \   006C   FA31           BR        ??DATRfArmerNbAlarmITForDiag_9
    486              }
    487              else 
    488              {
    489                  SI28BitsCalculated = (SI28BitsPrevious & (U32)0x0FFFFC00)  
    490                                       + (U32)SI10BitsReceived
    491                                       + (U32)0x400;
   \                     ??DATRfArmerNbAlarmITForDiag_8:
   \   006E   B7             PUSH      HL
   \   006F   B5             PUSH      DE
   \   0070   B1             PUSH      AX
   \   0071   1000FC         MOVW      AX,#64512
   \   0074   B1             PUSH      AX
   \   0075   891C           MOVW      AX,SP
   \   0077   CA0800         ADDW      AX,#8
   \   007A   D6             MOVW      HL,AX
   \   007B   87             MOV       A,[HL]
   \   007C   70             MOV       X,A
   \   007D   AE01           MOV       A,[HL+0x01]
   \   007F   9A....         CALL      ?L_AND_L03
   \   0082   D6             MOVW      HL,AX
   \   0083   891C           MOVW      AX,SP
   \   0085   E6             XCHW      AX,HL
   \   0086   30             XCH       A,X
   \   0087   0F             ADD       A,[HL]
   \   0088   30             XCH       A,X
   \   0089   0901           ADD       A,[HL+0x01]
   \   008B   E2             XCHW      AX,BC
   \   008C   30             XCH       A,X
   \   008D   2902           ADDC      A,[HL+0x02]
   \   008F   30             XCH       A,X
   \   0090   2903           ADDC      A,[HL+0x03]
   \   0092   E2             XCHW      AX,BC
   \   0093   B6             POP       HL
   \   0094   B6             POP       HL
   \   0095   0D04           ADD       A,#4
   \   0097   E2             XCHW      AX,BC
   \   0098   30             XCH       A,X
   \   0099   2D00           ADDC      A,#0
   \   009B   30             XCH       A,X
   \   009C   2D00           ADDC      A,#0
   \   009E   E2             XCHW      AX,BC
    492              }
    493              SI28BitsCalculated &= (U32)0x0FFFFFFF;  // to cancel a potential carry over on the bit 29.
    494          
    495              return ((U32)SI28BitsCalculated);   
   \                     ??DATRfArmerNbAlarmITForDiag_9:
   \   009F   16FF0F         MOVW      HL,#4095
   \   00A2   B7             PUSH      HL
   \   00A3   A7FF           MOV       H,#255
   \   00A5   B7             PUSH      HL
   \   00A6   9A....         CALL      ?L_AND_L03
   \   00A9   B4             POP       DE
   \   00AA   B4             POP       DE
   \   00AB   B4             POP       DE
   \   00AC   ..             CALLT     [__T_?FUNC_LEAVE_L06]
   \   00AD   0480           DW        0x8004
   \   00AF                  REQUIRE ?CL78K_V4_6_L00
    496          }
    497          
    498          //==============================================================================
    499          //   Function Name : 
    500          //     static U32 BuildingSI28BitsTheoric( U32 StartValue )
    501          //----------------------------------------------------------------------------
    502          //   Function Role  :
    503          //     Allows to calculate the theoretical SI28Bits
    504          //   Parameters Meaning :
    505          //     
    506          //   Result Meaning :
    507          //     
    508          //   Function  Description :
    509          //     
    510          //==============================================================================

   \                                 In  segment BCODE, align 1, keep-with-next
    511          static MEM_TYPE U32 BuildingSI28BitsTheoric(U32 SIStartValue)
   \                     BuildingSI28BitsTheoric:
    512          {
   \   0000                  ; * Stack frame (at entry) *
   \   0000                  ; Param size: 0
   \   0000                  ; Total Auto size: 0
    513              tDatRfMot32Bit Challenge; //New challenge calculated from SI10Bits and CID received
    514          
    515              //Building expected SI28Bits 
    516              SI28BitsLastRCFrameKnown = ReBuildSI28Bits(RCFrameSIReceived, (SIStartValue));
   \   0000   B3             PUSH      BC
   \   0001   B1             PUSH      AX
   \   0002   02....         MOVW      AX,RCFrameSIReceived
   \   0005   16....         MOVW      HL,#LWRD(ReBuildSI28Bits)
   \   0008   A4..           MOV       E,#BYTE3(ReBuildSI28Bits)
   \   000A   ..             CALLT     [__T_?FAR_FAST_CALL_L07]
   \   000B   03....         MOVW      SI28BitsLastRCFrameKnown,AX
   \   000E   C2             MOVW      AX,BC
   \   000F   03....         MOVW      SI28BitsLastRCFrameKnown+2,AX
    517          
    518              //SR frame: SI + CID
    519              Challenge.Format32Bit 
    520                 = (SI28BitsLastRCFrameKnown << 4) | (U8)(RCFrameCIDReceived & 0x0F);
   \   0012   8E....         MOV       A,RCFrameCIDReceived
   \   0015   5D0F           AND       A,#15
   \   0017   74             MOV       E,A
   \   0018   A500           MOV       D,#0
   \   001A   160000         MOVW      HL,#0
   \   001D   B7             PUSH      HL
   \   001E   B5             PUSH      DE
   \   001F   A404           MOV       E,#4
   \   0021   02....         MOVW      AX,SI28BitsLastRCFrameKnown
   \   0024   9A....         CALL      ?L_LSH_L03
   \   0027   9A....         CALL      ?L_IOR_L03
    521          
    522              return( CalculRollingCodeTheoreticRCFrame(Challenge) );
   \   002A   16....         MOVW      HL,#LWRD(CalculRollingCodeTheoreticRCFrame)
   \   002D   A4..           MOV       E,#BYTE3(CalculRollingCodeTheoreticRCFrame)
   \   002F   ..             CALLT     [__T_?FAR_FAST_CALL_L07]
   \   0030   AF             RET       
   \   0031                  REQUIRE ?CL78K_V4_6_L00
    523          }
    524          
    525          //==============================================================================
    526          //   Function Name : 
    527          //     static U32 CalculRollingCodeTheoreticRCFrame(tDatRfMot32Bit Challenge)
    528          //----------------------------------------------------------------------------
    529          //   Function Role  :
    530          //     
    531          //   Parameters Meaning :
    532          //     
    533          //   Result Meaning :
    534          //     
    535          //   Function  Description :
    536          //     
    537          //==============================================================================

   \                                 In  segment BCODE, align 1, keep-with-next
    538          static MEM_TYPE U32 CalculRollingCodeTheoreticRCFrame(tDatRfMot32Bit Challenge)
   \                     CalculRollingCodeTheoreticRCFrame:
    539          {
   \   0000                  ; * Stack frame (at entry) *
   \   0000                  ; Param size: 0
   \   0000   B3             PUSH      BC
   \   0001   B1             PUSH      AX
   \   0002                  ; Total Auto size: 14
   \   0002   ..             CALLT     [__T_?FUNC_ENTER_L06]
   \   0003   0A00           DW        0xA
    540              tDatRfMot32Bit KeyIdentifier;
    541              U8 I;
    542              U8 BuffRemoteSecretKey[cNbBytesRemoteSK];
    543          
    544          #ifdef _QAC_
    545              // Disabled  QAC warning QC3715: Implicit cast : unsigned char to int
    546              // Cause switch structure 
    547              #pragma PRQA_MESSAGES_OFF 3715
    548          #endif
    549          
    550              switch (IndiceKeyRf) //Read enregistered RSK
   \   0005   8E....         MOV       A,IndiceKeyRf
   \   0008   4D00           CMP       A,#0
   \   000A   AD0F           BZ        ??DATRfArmerNbAlarmITForDiag_10
   \   000C   4D01           CMP       A,#1
   \   000E   AD2C           BZ        ??DATRfArmerNbAlarmITForDiag_11
   \   0010   4D02           CMP       A,#2
   \   0012   AD49           BZ        ??DATRfArmerNbAlarmITForDiag_12
   \   0014   4D03           CMP       A,#3
   \   0016   AD66           BZ        ??DATRfArmerNbAlarmITForDiag_13
   \   0018   9B....         BR        N:??DATRfArmerNbAlarmITForDiag_14
    551              {
    552                  case cIndiceKeyRf0:
    553                      for (I=0; I<cNbBytesRemoteSK; I++)
   \                     ??DATRfArmerNbAlarmITForDiag_10:
   \   001B   D6             MOVW      HL,AX
   \   001C   891C           MOVW      AX,SP
   \   001E   CA0400         ADDW      AX,#4
   \   0021   E6             XCHW      AX,HL
   \   0022   12....         MOVW      BC,#DATDbkMirrors
   \   0025   A006           MOV       X,#6
    554                      {
    555                          BuffRemoteSecretKey[I] = mDATReadTable (U8Bit, TableOfRemoteSecretKey1, I, Default);
   \                     ??CalculRollingCodeTheoreticRCFrame_0:
   \   0027   B3             PUSH      BC
   \   0028   B4             POP       DE
   \   0029   E4             XCHW      AX,DE
   \   002A   CA7000         ADDW      AX,#112
   \   002D   E4             XCHW      AX,DE
   \   002E   85             MOV       A,[DE]
   \   002F   97             MOV       [HL],A
    556                      }
   \   0030   B3             PUSH      BC
   \   0031   B4             POP       DE
   \   0032   84             INCW      DE
   \   0033   B5             PUSH      DE
   \   0034   B2             POP       BC
   \   0035   86             INCW      HL
   \   0036   50             DEC       X
   \   0037   60             MOV       A,X
   \   0038   AD63           BZ        ??DATRfArmerNbAlarmITForDiag_14
   \   003A   FAEB           BR        ??CalculRollingCodeTheoreticRCFrame_0
    557                  break;
    558          
    559                  case cIndiceKeyRf1:
    560                      for (I=0; I<cNbBytesRemoteSK; I++)
   \                     ??DATRfArmerNbAlarmITForDiag_11:
   \   003C   D6             MOVW      HL,AX
   \   003D   891C           MOVW      AX,SP
   \   003F   CA0400         ADDW      AX,#4
   \   0042   E6             XCHW      AX,HL
   \   0043   12....         MOVW      BC,#DATDbkMirrors
   \   0046   A006           MOV       X,#6
    561                      {
    562                           BuffRemoteSecretKey[I] = mDATReadTable (U8Bit, TableOfRemoteSecretKey2, I, Default);
   \                     ??CalculRollingCodeTheoreticRCFrame_1:
   \   0048   B3             PUSH      BC
   \   0049   B4             POP       DE
   \   004A   E4             XCHW      AX,DE
   \   004B   CA7600         ADDW      AX,#118
   \   004E   E4             XCHW      AX,DE
   \   004F   85             MOV       A,[DE]
   \   0050   97             MOV       [HL],A
    563                      }
   \   0051   B3             PUSH      BC
   \   0052   B4             POP       DE
   \   0053   84             INCW      DE
   \   0054   B5             PUSH      DE
   \   0055   B2             POP       BC
   \   0056   86             INCW      HL
   \   0057   50             DEC       X
   \   0058   60             MOV       A,X
   \   0059   AD42           BZ        ??DATRfArmerNbAlarmITForDiag_14
   \   005B   FAEB           BR        ??CalculRollingCodeTheoreticRCFrame_1
    564                  break;
    565          
    566                  case cIndiceKeyRf2:
    567                      for (I=0; I<cNbBytesRemoteSK; I++)
   \                     ??DATRfArmerNbAlarmITForDiag_12:
   \   005D   D6             MOVW      HL,AX
   \   005E   891C           MOVW      AX,SP
   \   0060   CA0400         ADDW      AX,#4
   \   0063   E6             XCHW      AX,HL
   \   0064   12....         MOVW      BC,#DATDbkMirrors
   \   0067   A006           MOV       X,#6
    568                      {
    569                           BuffRemoteSecretKey[I] = mDATReadTable (U8Bit, TableOfRemoteSecretKey3, I, Default);
   \                     ??CalculRollingCodeTheoreticRCFrame_2:
   \   0069   B3             PUSH      BC
   \   006A   B4             POP       DE
   \   006B   E4             XCHW      AX,DE
   \   006C   CA7C00         ADDW      AX,#124
   \   006F   E4             XCHW      AX,DE
   \   0070   85             MOV       A,[DE]
   \   0071   97             MOV       [HL],A
    570                      }
   \   0072   B3             PUSH      BC
   \   0073   B4             POP       DE
   \   0074   84             INCW      DE
   \   0075   B5             PUSH      DE
   \   0076   B2             POP       BC
   \   0077   86             INCW      HL
   \   0078   50             DEC       X
   \   0079   60             MOV       A,X
   \   007A   AD21           BZ        ??DATRfArmerNbAlarmITForDiag_14
   \   007C   FAEB           BR        ??CalculRollingCodeTheoreticRCFrame_2
    571                  break;
    572          
    573                  case cIndiceKeyRf3:
    574                      for (I=0; I<cNbBytesRemoteSK; I++)
   \                     ??DATRfArmerNbAlarmITForDiag_13:
   \   007E   D6             MOVW      HL,AX
   \   007F   891C           MOVW      AX,SP
   \   0081   CA0400         ADDW      AX,#4
   \   0084   E6             XCHW      AX,HL
   \   0085   12....         MOVW      BC,#DATDbkMirrors
   \   0088   A006           MOV       X,#6
    575                      {
    576                           BuffRemoteSecretKey[I] = mDATReadTable (U8Bit, TableOfRemoteSecretKey4, I, Default);
   \                     ??CalculRollingCodeTheoreticRCFrame_3:
   \   008A   B3             PUSH      BC
   \   008B   B4             POP       DE
   \   008C   E4             XCHW      AX,DE
   \   008D   CA8200         ADDW      AX,#130
   \   0090   E4             XCHW      AX,DE
   \   0091   85             MOV       A,[DE]
   \   0092   97             MOV       [HL],A
    577                      }
   \   0093   B3             PUSH      BC
   \   0094   B4             POP       DE
   \   0095   84             INCW      DE
   \   0096   B5             PUSH      DE
   \   0097   B2             POP       BC
   \   0098   86             INCW      HL
   \   0099   50             DEC       X
   \   009A   60             MOV       A,X
   \   009B   BDED           BNZ       ??CalculRollingCodeTheoreticRCFrame_3
    578                  break;
    579          
    580                  //CCOV: ailievb: Cannot be covered because this default case rises explicit assert
    581                  default:
    582                      mLIBassert(cFalse);
    583                  break;
    584              }
    585          
    586          #ifdef _QAC_
    587              #pragma PRQA_MESSAGES_ON 3715
    588          #endif
    589          
    590              KeyIdentifier.Format32Bit = mDATReadTable (U32Bit, TableOfKeyIdentifier, IndiceKeyRf, Default);
   \                     ??DATRfArmerNbAlarmITForDiag_14:
   \   009D   891C           MOVW      AX,SP
   \   009F   D6             MOVW      HL,AX
   \   00A0   B7             PUSH      HL
   \   00A1   B4             POP       DE
   \   00A2   8E....         MOV       A,IndiceKeyRf
   \   00A5   A004           MOV       X,#4
   \   00A7   3188           MULU      X
   \   00A9   CA....         ADDW      AX,#DATDbkMirrors+70
   \   00AC   D6             MOVW      HL,AX
   \   00AD   87             MOV       A,[HL]
   \   00AE   70             MOV       X,A
   \   00AF   AE01           MOV       A,[HL+0x01]
   \   00B1   D2             MOVW      BC,AX
   \   00B2   100000         MOVW      AX,#0
   \   00B5   B3             PUSH      BC
   \   00B6   B1             PUSH      AX
   \   00B7   8E....         MOV       A,IndiceKeyRf
   \   00BA   A004           MOV       X,#4
   \   00BC   3188           MULU      X
   \   00BE   CA....         ADDW      AX,#DATDbkMirrors+68
   \   00C1   D6             MOVW      HL,AX
   \   00C2   87             MOV       A,[HL]
   \   00C3   70             MOV       X,A
   \   00C4   AE01           MOV       A,[HL+0x01]
   \   00C6   120000         MOVW      BC,#0
   \   00C9   D6             MOVW      HL,AX
   \   00CA   891C           MOVW      AX,SP
   \   00CC   E6             XCHW      AX,HL
   \   00CD   E2             XCHW      AX,BC
   \   00CE   0902           ADD       A,[HL+0x02]
   \   00D0   30             XCH       A,X
   \   00D1   0903           ADD       A,[HL+0x03]
   \   00D3   E2             XCHW      AX,BC
   \   00D4   B6             POP       HL
   \   00D5   B6             POP       HL
   \   00D6   B5             PUSH      DE
   \   00D7   B6             POP       HL
   \   00D8   BE01           MOV       [HL+0x01],A
   \   00DA   60             MOV       A,X
   \   00DB   97             MOV       [HL],A
   \   00DC   C2             MOVW      AX,BC
   \   00DD   BE03           MOV       [HL+0x03],A
   \   00DF   60             MOV       A,X
   \   00E0   BE02           MOV       [HL+0x02],A
    591              pLIBPcfIdentifier = (U8*)(&KeyIdentifier.Format32Bit);  //Init variable for TAG function
   \   00E2   891C           MOVW      AX,SP
   \   00E4   99..           MOVW      S:pLIBPcfIdentifier,AX
    592          
    593              // Inversion of high bits to low bits to have an intel format.
    594              Challenge.Format32Bit
    595                = (((U32)(Challenge.Format8Bit.F8Bit1) << 24) & (U32)0xFF000000UL) 
    596                 + (((U32)(Challenge.Format8Bit.F8Bit2) << 16) & (U32)0x00FF0000)
    597                 + (((U32)(Challenge.Format8Bit.F8Bit3) << 8)  & (U32)0x0000FF00)
    598                 + ((U32)(Challenge.Format8Bit.F8Bit4)        & (U32)0x000000FF);
    599              LIBPcfRandomNumber = Challenge.Format32Bit;  //Init variable for TAG function
   \   00E6   AE0D           MOV       A,[HL+0x0D]
   \   00E8   74             MOV       E,A
   \   00E9   A500           MOV       D,#0
   \   00EB   160000         MOVW      HL,#0
   \   00EE   B7             PUSH      HL
   \   00EF   B5             PUSH      DE
   \   00F0   891C           MOVW      AX,SP
   \   00F2   D6             MOVW      HL,AX
   \   00F3   AE10           MOV       A,[HL+0x10]
   \   00F5   120000         MOVW      BC,#0
   \   00F8   70             MOV       X,A
   \   00F9   63             MOV       A,B
   \   00FA   E2             XCHW      AX,BC
   \   00FB   E2             XCHW      AX,BC
   \   00FC   60             MOV       A,X
   \   00FD   A000           MOV       X,#0
   \   00FF   B3             PUSH      BC
   \   0100   B1             PUSH      AX
   \   0101   891C           MOVW      AX,SP
   \   0103   D6             MOVW      HL,AX
   \   0104   AE13           MOV       A,[HL+0x13]
   \   0106   70             MOV       X,A
   \   0107   63             MOV       A,B
   \   0108   D2             MOVW      BC,AX
   \   0109   70             MOV       X,A
   \   010A   B3             PUSH      BC
   \   010B   B1             PUSH      AX
   \   010C   891C           MOVW      AX,SP
   \   010E   D6             MOVW      HL,AX
   \   010F   AE16           MOV       A,[HL+0x16]
   \   0111   73             MOV       B,A
   \   0112   100000         MOVW      AX,#0
   \   0115   72             MOV       C,A
   \   0116   D6             MOVW      HL,AX
   \   0117   891C           MOVW      AX,SP
   \   0119   E6             XCHW      AX,HL
   \   011A   E2             XCHW      AX,BC
   \   011B   30             XCH       A,X
   \   011C   0902           ADD       A,[HL+0x02]
   \   011E   30             XCH       A,X
   \   011F   E2             XCHW      AX,BC
   \   0120   B6             POP       HL
   \   0121   B6             POP       HL
   \   0122   D6             MOVW      HL,AX
   \   0123   891C           MOVW      AX,SP
   \   0125   E6             XCHW      AX,HL
   \   0126   0901           ADD       A,[HL+0x01]
   \   0128   E2             XCHW      AX,BC
   \   0129   E2             XCHW      AX,BC
   \   012A   B6             POP       HL
   \   012B   B6             POP       HL
   \   012C   77             MOV       H,A
   \   012D   891C           MOVW      AX,SP
   \   012F   E6             XCHW      AX,HL
   \   0130   30             XCH       A,X
   \   0131   0F             ADD       A,[HL]
   \   0132   30             XCH       A,X
   \   0133   E2             XCHW      AX,BC
   \   0134   E2             XCHW      AX,BC
   \   0135   B6             POP       HL
   \   0136   B6             POP       HL
   \   0137   99..           MOVW      S:LIBPcfRandomNumber,AX
   \   0139   C2             MOVW      AX,BC
   \   013A   99..           MOVW      S:LIBPcfRandomNumber+2,AX
    600          
    601              KeyIdentifier.Format32Bit
    602                =   (((U32)(KeyIdentifier.Format8Bit.F8Bit1) << 24) & (U32)0xFF000000UL) 
    603                   + (((U32)(KeyIdentifier.Format8Bit.F8Bit2) << 16) & (U32)0x00FF0000)
    604                   + (((U32)(KeyIdentifier.Format8Bit.F8Bit3) << 8)  & (U32)0x0000FF00)
    605                   +  ((U32)(KeyIdentifier.Format8Bit.F8Bit4)        & (U32)0x000000FF);
   \   013C   891C           MOVW      AX,SP
   \   013E   D6             MOVW      HL,AX
   \   013F   B7             PUSH      HL
   \   0140   B4             POP       DE
   \   0141   AE03           MOV       A,[HL+0x03]
   \   0143   70             MOV       X,A
   \   0144   A100           MOV       A,#0
   \   0146   120000         MOVW      BC,#0
   \   0149   B3             PUSH      BC
   \   014A   B1             PUSH      AX
   \   014B   891C           MOVW      AX,SP
   \   014D   D6             MOVW      HL,AX
   \   014E   AE06           MOV       A,[HL+0x06]
   \   0150   70             MOV       X,A
   \   0151   63             MOV       A,B
   \   0152   E2             XCHW      AX,BC
   \   0153   E2             XCHW      AX,BC
   \   0154   60             MOV       A,X
   \   0155   A000           MOV       X,#0
   \   0157   B3             PUSH      BC
   \   0158   B1             PUSH      AX
   \   0159   891C           MOVW      AX,SP
   \   015B   D6             MOVW      HL,AX
   \   015C   AE09           MOV       A,[HL+0x09]
   \   015E   70             MOV       X,A
   \   015F   63             MOV       A,B
   \   0160   D2             MOVW      BC,AX
   \   0161   70             MOV       X,A
   \   0162   B3             PUSH      BC
   \   0163   B1             PUSH      AX
   \   0164   891C           MOVW      AX,SP
   \   0166   D6             MOVW      HL,AX
   \   0167   AE0C           MOV       A,[HL+0x0C]
   \   0169   73             MOV       B,A
   \   016A   100000         MOVW      AX,#0
   \   016D   72             MOV       C,A
   \   016E   D6             MOVW      HL,AX
   \   016F   891C           MOVW      AX,SP
   \   0171   E6             XCHW      AX,HL
   \   0172   E2             XCHW      AX,BC
   \   0173   30             XCH       A,X
   \   0174   0902           ADD       A,[HL+0x02]
   \   0176   30             XCH       A,X
   \   0177   E2             XCHW      AX,BC
   \   0178   B6             POP       HL
   \   0179   B6             POP       HL
   \   017A   D6             MOVW      HL,AX
   \   017B   891C           MOVW      AX,SP
   \   017D   E6             XCHW      AX,HL
   \   017E   0901           ADD       A,[HL+0x01]
   \   0180   E2             XCHW      AX,BC
   \   0181   E2             XCHW      AX,BC
   \   0182   B6             POP       HL
   \   0183   B6             POP       HL
   \   0184   77             MOV       H,A
   \   0185   891C           MOVW      AX,SP
   \   0187   E6             XCHW      AX,HL
   \   0188   30             XCH       A,X
   \   0189   0F             ADD       A,[HL]
   \   018A   30             XCH       A,X
   \   018B   E2             XCHW      AX,BC
   \   018C   E2             XCHW      AX,BC
   \   018D   B6             POP       HL
   \   018E   B6             POP       HL
   \   018F   B5             PUSH      DE
   \   0190   B6             POP       HL
   \   0191   BE01           MOV       [HL+0x01],A
   \   0193   60             MOV       A,X
   \   0194   97             MOV       [HL],A
   \   0195   C2             MOVW      AX,BC
   \   0196   BE03           MOV       [HL+0x03],A
   \   0198   60             MOV       A,X
   \   0199   BE02           MOV       [HL+0x02],A
    606          
    607              pLIBPcfSecretKey = BuffRemoteSecretKey;   // Init variable for TAG function
   \   019B   891C           MOVW      AX,SP
   \   019D   CA0400         ADDW      AX,#4
   \   01A0   99..           MOVW      S:pLIBPcfSecretKey,AX
    608              LIBPcfCipheredData = (U32)0;             // Init variable for TAG function
   \   01A2   EE..0000       MOVW      S:LIBPcfCipheredData,#0
   \   01A6   EE..0000       MOVW      S:LIBPcfCipheredData+2,#0
    609              LIBPcfInitialize();
   \   01AA   16....         MOVW      HL,#LWRD(LIBPcfInitialize)
   \   01AD   A4..           MOV       E,#BYTE3(LIBPcfInitialize)
   \   01AF   ..             CALLT     [__T_?FAR_CALL_L07]
    610              LIBPcfCipherFunction(cNbBitsCryptage);       // Fill LIBPcfCipheredData
   \   01B0   A120           MOV       A,#32
   \   01B2   16....         MOVW      HL,#LWRD(LIBPcfCipherFunction)
   \   01B5   A4..           MOV       E,#BYTE3(LIBPcfCipherFunction)
   \   01B7   ..             CALLT     [__T_?FAR_CALL_L07]
    611            
    612              return ((U32)LIBPcfCipheredData);
   \   01B8   89..           MOVW      AX,S:LIBPcfCipheredData+2
   \   01BA   D2             MOVW      BC,AX
   \   01BB   89..           MOVW      AX,S:LIBPcfCipheredData
   \   01BD   ..             CALLT     [__T_?FUNC_DEALL_L06]
   \   01BE   0E00           DW        0xE
   \   01C0   AF             RET       
   \   01C1                  REQUIRE ?CL78K_V4_6_L00
    613          }
    614          
    615          //=============================================================================
    616          //  DESCRIPTION : CallBckReceptionSIFrame
    617          //  
    618          //  PARAMETERS (Type,Name,Min,Max) : 
    619          //    (tAddress Adresse, tStatus Statut, tMsg * pMsg)
    620          //
    621          //  RETURN VALUE :   none
    622          // 
    623          //  DESIGN INFORMATION : 
    624          //    Fonction called by LDB part to do a copy of the received SI frame
    625          //     
    626          //==============================================================================

   \                                 In  segment CODE, align 1, keep-with-next
    627          static void CallBckReceptionSIFrame(tAddress Adresse, tStatus Statut, tMsg * pMsg)
   \                     CallBckReceptionSIFrame:
    628          {
   \   0000                  ; * Stack frame (at entry) *
   \   0000                  ; Param size: 0
   \   0000                  ; Total Auto size: 0
    629              mLIBmemcpy ((U8*)DataSIFrameReceived, pMsg->pBuffer, cNbBytesSIFrame);
   \   0000   C4             MOVW      AX,DE
   \   0001   D6             MOVW      HL,AX
   \   0002   87             MOV       A,[HL]
   \   0003   70             MOV       X,A
   \   0004   AE01           MOV       A,[HL+0x01]
   \   0006   D4             MOVW      DE,AX
   \   0007   16....         MOVW      HL,#DataSIFrameReceived
   \   000A   A302           MOV       B,#2
   \                     ??CallBckReceptionSIFrame_0:
   \   000C   85             MOV       A,[DE]
   \   000D   97             MOV       [HL],A
   \   000E   86             INCW      HL
   \   000F   84             INCW      DE
   \   0010   8BFA           DBNZ      B, ??CallBckReceptionSIFrame_0
    630              SIFrameReceived = cTrue; //Flag to signal: SI frame received
   \   0012   A101           MOV       A,#1
   \   0014   9E....         MOV       SIFrameReceived,A
    631          
    632          #ifdef _TEST_RF_ //update counters used for RF hardware testing   
    633              if (DATRfNbSIBlocksReceived < cNbMaxStockedInByte)
   \   0017   8E....         MOV       A,DATRfNbSIBlocksReceived
   \   001A   4DFF           CMP       A,#255
   \   001C   AD04           BZ        ??DATRfArmerNbAlarmITForDiag_35
    634              {
    635                  DATRfNbSIBlocksReceived++;
   \   001E   41             INC       A
   \   001F   9E....         MOV       DATRfNbSIBlocksReceived,A
    636              }
    637              else
    638              {} //nothing to do
    639          #endif
    640          }
   \                     ??DATRfArmerNbAlarmITForDiag_35:
   \   0022   AF             RET       
   \   0023                  REQUIRE ?CL78K_V4_6_L00
    641          
    642          //==============================================================================
    643          //  DESCRIPTION : RfPeriodicTask
    644          //  
    645          //  PARAMETERS (Type,Name,Min,Max) : 
    646          //    (tAddress Adresse, tStatus Statut, tMsg * pMsg)
    647          //
    648          //  RETURN VALUE :   none
    649          // 
    650          //  DESIGN INFORMATION : 
    651          //    Fonction called by LDB part to do a copy of the received SI frame
    652          //     
    653          //==============================================================================

   \                                 In  segment CODE, align 1, keep-with-next
    654          static void RfPeriodicTask(void)
   \                     RfPeriodicTask:
    655          {
   \   0000                  ; * Stack frame (at entry) *
   \   0000                  ; Param size: 0
   \   0000   B3             PUSH      BC
   \   0001                  ; Total Auto size: 0
    656              //---- Update all counter ----
    657              if (TempoSearchFramePeriod > 0)
   \   0001   8E....         MOV       A,TempoSearchFramePeriod
   \   0004   4D00           CMP       A,#0
   \   0006   AD04           BZ        ??DATRfArmerNbAlarmITForDiag_36
    658              {
    659                  TempoSearchFramePeriod--;
   \   0008   51             DEC       A
   \   0009   9E....         MOV       TempoSearchFramePeriod,A
    660              }
    661          
    662              if (TempoAlarmITForRCReceptionTimeOut > 0)
   \                     ??DATRfArmerNbAlarmITForDiag_36:
   \   000C   8E....         MOV       A,TempoAlarmITForRCReceptionTimeOut
   \   000F   4D00           CMP       A,#0
   \   0011   AD04           BZ        ??DATRfArmerNbAlarmITForDiag_37
    663              {
    664                  TempoAlarmITForRCReceptionTimeOut--;
   \   0013   51             DEC       A
   \   0014   9E....         MOV       TempoAlarmITForRCReceptionTimeOut,A
    665              }
    666          
    667              if (TempoAlarmITForLongPushWaitTimeOut > 0)
   \                     ??DATRfArmerNbAlarmITForDiag_37:
   \   0017   8E....         MOV       A,TempoAlarmITForLongPushWaitTimeOut
   \   001A   4D00           CMP       A,#0
   \   001C   AD04           BZ        ??DATRfArmerNbAlarmITForDiag_38
    668              {
    669                  TempoAlarmITForLongPushWaitTimeOut--;
   \   001E   51             DEC       A
   \   001F   9E....         MOV       TempoAlarmITForLongPushWaitTimeOut,A
    670              }
    671          
    672              if (TempoAlarmITForLongPushReceiveTimeOut > 0)
   \                     ??DATRfArmerNbAlarmITForDiag_38:
   \   0022   8E....         MOV       A,TempoAlarmITForLongPushReceiveTimeOut
   \   0025   4D00           CMP       A,#0
   \   0027   AD04           BZ        ??DATRfArmerNbAlarmITForDiag_39
    673              {
    674                  TempoAlarmITForLongPushReceiveTimeOut--;
   \   0029   51             DEC       A
   \   002A   9E....         MOV       TempoAlarmITForLongPushReceiveTimeOut,A
    675              }
    676          
    677          #ifdef _DIAGNOSTIC_MEMO_    //For Diagnostic   
    678              {
    679                  U8 Counter;
    680                  //---------------------------------------------------------------------------
    681                  for (Counter=0; Counter<cNbCodeDiagMemorized; Counter++)
   \                     ??DATRfArmerNbAlarmITForDiag_39:
   \   002D   A200           MOV       C,#0
   \   002F   16....         MOVW      HL,#TempoAlarmITForDiag
    682                  {
    683                      if ((DATRfPushMemorized & (U8)(0x01 << Counter)) != 0)
   \                     ??RfPeriodicTask_0:
   \   0032   100100         MOVW      AX,#1
   \   0035   ..             CALLT     [__T_?I_LSH_L02]
   \   0036   60             MOV       A,X
   \   0037   58....         AND       A,DATRfPushMemorized
   \   003A   AD12           BZ        ??DATRfArmerNbAlarmITForDiag_40
    684                      { // memorization activated
    685                          TempoAlarmITForDiag[Counter]--;
   \   003C   87             MOV       A,[HL]
   \   003D   51             DEC       A
   \   003E   97             MOV       [HL],A
    686                          if (TempoAlarmITForDiag[Counter] == 0) // 2s elapsed 
   \   003F   BD0D           BNZ       ??DATRfArmerNbAlarmITForDiag_40
    687                          {
    688                              DATRfPushMemorized &= (U8)(~(U8)(0x01 << Counter)); //Reset Diag flag
   \   0041   100100         MOVW      AX,#1
   \   0044   ..             CALLT     [__T_?I_LSH_L02]
   \   0045   60             MOV       A,X
   \   0046   7DFF           XOR       A,#255
   \   0048   58....         AND       A,DATRfPushMemorized
   \   004B   9E....         MOV       DATRfPushMemorized,A
    689                          }
    690                      }
    691                  }  //-------------------------------------------------------------------------
   \                     ??DATRfArmerNbAlarmITForDiag_40:
   \   004E   42             INC       C
   \   004F   62             MOV       A,C
   \   0050   86             INCW      HL
   \   0051   4D08           CMP       A,#8
   \   0053   8DDD           BC        ??RfPeriodicTask_0
    692              }
    693          #endif
    694          
    695          #ifdef _PASSING_RF_
    696              if (TempoAlarmITForPassingRf>0) 
    697              {
    698                  TempoAlarmITForPassingRf--; //rearm "timer"
    699              }
    700              else
    701              {} //nothing to do
    702          #endif
    703          }
   \   0055   B2             POP       BC
   \   0056   AF             RET       
   \   0057                  REQUIRE ?CL78K_V4_6_L00
    704          /* [LOCAL_FUNCTIONS_END] */
    705          
    706          
    707          //==============================================================================
    708          //...........................................................................
    709          //.......................... EXPORTED FUNCTIONS.............................
    710          //...........................................................................
    711          //==============================================================================
    712          //==============================================================================
    713          //  DESCRIPTION : DATRfWakeUpBlockReceived
    714          //  
    715          //  PARAMETERS (Type,Name,Min,Max) :   none
    716          //
    717          //  RETURN VALUE : True if a Rf WakeUp frame is received
    718          // 
    719          //  DESIGN INFORMATION :   refer to Detailed Design Document
    720          //     
    721          //==============================================================================

   \                                 In  segment CODE, align 1, keep-with-next
    722          BOOL DATRfWakeUpBlockReceived(void)
   \                     DATRfWakeUpBlockReceived:
    723          {
   \   0000                  ; * Stack frame (at entry) *
   \   0000                  ; Param size: 0
   \   0000   B5             PUSH      DE
   \   0001                  ; Total Auto size: 0
    724              // Execute periodic task
    725              RfPeriodicTask();
   \   0001   9A....         CALL      RfPeriodicTask
    726          
    727              //--------------------------------------------------------------
    728              // To launch the LDB_RF layer every cDATRfLDBSearchFramePeriodMs
    729              //--------------------------------------------------------------
    730              mLIBassert(RCReceptionTimeOutIsActive == cFalse);
    731              mLIBassert(LongPushTimeOutIsActive == cFalse);
    732          
    733              if (mDATRead(U1Bit, EEP_AUTRECRF, Default) == cTrue)
   \   0004   16....         MOVW      HL,#DATDbkMirrors+27
   \   0007   31D715         BF        [HL].5, ??DATRfArmerNbAlarmITForDiag_41
    734              {
    735                  if (TempoSearchFramePeriod == 0)
   \   000A   8E....         MOV       A,TempoSearchFramePeriod
   \   000D   4D00           CMP       A,#0
   \   000F   BD16           BNZ       ??DATRfArmerNbAlarmITForDiag_42
    736                  {
    737                      SearchFrameInCourse = cTrue;
   \   0011   A101           MOV       A,#1
   \   0013   9E....         MOV       SearchFrameInCourse,A
    738                      TempoSearchFramePeriod = cSearchFramePeriodMs; // tempo shall be updated before LDB control
   \   0016   A102           MOV       A,#2
   \   0018   9E....         MOV       TempoSearchFramePeriod,A
    739                      LDBControl(cLDBChannelRf,cLDBRfSearchFrame); 
   \   001B   A100           MOV       A,#0
   \   001D   FA02           BR        ??DATRfArmerNbAlarmITForDiag_43
    740                  }
    741              }
    742              else
    743              {
    744                  LDBControl(cLDBChannelRf, cLDBRfDeactivateStrobe); // Prevent from HW activation
   \                     ??DATRfArmerNbAlarmITForDiag_41:
   \   001F   A105           MOV       A,#5
   \                     ??DATRfArmerNbAlarmITForDiag_43:
   \   0021   16....         MOVW      HL,#LWRD(LDBRfControl)
   \   0024   A4..           MOV       E,#BYTE3(LDBRfControl)
   \   0026   ..             CALLT     [__T_?FAR_CALL_L07]
    745              }
    746              return (WakeUpBlockReceived);
   \                     ??DATRfArmerNbAlarmITForDiag_42:
   \   0027   8E....         MOV       A,WakeUpBlockReceived
   \   002A   B4             POP       DE
   \   002B   AF             RET       
   \   002C                  REQUIRE ?CL78K_V4_6_L00
    747          }
    748          
    749          //==============================================================================
    750          //  DESCRIPTION : DATRfArmRCReceptionTimer
    751          //  
    752          //  PARAMETERS (Type,Name,Min,Max) :   none
    753          //
    754          //  RETURN VALUE :   none
    755          // 
    756          //  DESIGN INFORMATION :   refer to Detailed Design Document
    757          //     
    758          //==============================================================================

   \                                 In  segment CODE, align 1, keep-with-next
    759          void DATRfArmRCReceptionTimer(void)
   \                     DATRfArmRCReceptionTimer:
    760          {
   \   0000                  ; * Stack frame (at entry) *
   \   0000                  ; Param size: 0
   \   0000                  ; Total Auto size: 0
    761              //WakeUpBlock detection flag  is consumed
    762              WakeUpBlockReceived = cFalse;
   \   0000   A100           MOV       A,#0
   \   0002   9E....         MOV       WakeUpBlockReceived,A
    763              SIFrameReceived     = cFalse; //Flag positioned by LDBCallBack
   \   0005   9E....         MOV       SIFrameReceived,A
    764          
    765              //An internal counter is used to generate the timer because timing TOS
    766              //functions are only available when BCM is awake
    767              TempoAlarmITForRCReceptionTimeOut = cRCReceptionTimeOut;
   \   0008   A109           MOV       A,#9
   \   000A   9E....         MOV       TempoAlarmITForRCReceptionTimeOut,A
    768              RCReceptionTimeOutIsActive        = cTrue;    //flag
   \   000D   A101           MOV       A,#1
   \   000F   9E....         MOV       RCReceptionTimeOutIsActive,A
    769              LongPushTimeOutIsActive           = cFalse;   //flag
   \   0012   A100           MOV       A,#0
   \   0014   9E....         MOV       LongPushTimeOutIsActive,A
    770          }
   \   0017   AF             RET       
   \   0018                  REQUIRE ?CL78K_V4_6_L00
    771          
    772          //==============================================================================
    773          //  DESCRIPTION : DATRfNewRcBlockReceived
    774          //  
    775          //  PARAMETERS (Type,Name,Min,Max) :   none
    776          //
    777          //  RETURN VALUE :   none
    778          // 
    779          //  DESIGN INFORMATION :   refer to Detailed Design Document
    780          //     
    781          //==============================================================================

   \                                 In  segment CODE, align 1, keep-with-next
    782          BOOL DATRfNewRcBlockReceived(void)
   \                     DATRfNewRcBlockReceived:
    783          {
   \   0000                  ; * Stack frame (at entry) *
   \   0000                  ; Param size: 0
   \   0000   B5             PUSH      DE
   \   0001                  ; Total Auto size: 0
    784          #ifdef X90_PROJECT
    785              return DATRfNewRcBlockReceived_Static();
   \   0001   16....         MOVW      HL,#LWRD(DATRfNewRcBlockReceived_Static)
   \   0004   A4..           MOV       E,#BYTE3(DATRfNewRcBlockReceived_Static)
   \   0006   ..             CALLT     [__T_?FAR_CALL_L07]
   \   0007   B4             POP       DE
   \   0008   AF             RET       
   \   0009                  REQUIRE ?CL78K_V4_6_L00
    786          }
    787          #pragma optimize=no_inline

   \                                 In  segment BCODE, align 1, keep-with-next
    788          static MEM_TYPE BOOL DATRfNewRcBlockReceived_Static(void)
   \                     DATRfNewRcBlockReceived_Static:
    789          {
   \   0000                  ; * Stack frame (at entry) *
   \   0000                  ; Param size: 0
   \   0000   B3             PUSH      BC
   \   0001                  ; Total Auto size: 4
   \   0001   B7             PUSH      HL
   \   0002   B7             PUSH      HL
    790          #endif
    791              BOOL RCBlockReceivedIsOK;
    792          
    793          #ifdef _PASSING_RF_
    794          #else
    795              BOOL NewKeyPressAndIdentifierOk;
    796              U32  KeyIdentifier;
    797              U32  RollingCodeCalculated;
    798          #endif
    799              U8   ParityCodeCalculated;
    800              U8   i;
    801          
    802              // Execute periodic task
    803              RfPeriodicTask();
   \   0003   9A....         CALL      RfPeriodicTask
    804          
    805              //Default value (function return value)
    806              RCBlockReceivedIsOK = cFalse;
   \   0006   891C           MOVW      AX,SP
   \   0008   D6             MOVW      HL,AX
   \   0009   A100           MOV       A,#0
   \   000B   97             MOV       [HL],A
    807          
    808              if(RCFrameReceived == cTrue) //A RC frame has been received
   \   000C   8E....         MOV       A,RCFrameReceived
   \   000F   51             DEC       A
   \   0010   AD03           BZ        $+5
   \   0012   9B....         BR        N:??DATRfArmerNbAlarmITForDiag_15
    809              {  
    810                  RCFrameReceived = cFalse; //Received frame flag is consumed
   \   0015   A100           MOV       A,#0
   \   0017   9E....         MOV       RCFrameReceived,A
    811          
    812          #ifndef X90_PROJECT // Cm007542: TRF_RECU is on when no frame detected
    813          #ifdef _DIAGNOSTIC_MEMO_    //For Diagnostic   
    814              ArmerNbAlarmITForDiag(cDiagRfFrameReceived);
    815          #endif
    816          #endif
    817                  //Verify Parity
    818                  //-------------
    819                  //Check RCframe data by calculating PARity byte and comparing it with PARity byte received
    820                  ParityCodeCalculated = 0;
   \   001A   70             MOV       X,A
    821                  for (i=0; i<(cNbBytesRCFrame-1); i++) //For each byte in block RC
   \   001B   16....         MOVW      HL,#DataRCFrameReceived
   \   001E   A20A           MOV       C,#10
    822                  {  
    823                       ParityCodeCalculated = (U8)(ParityCodeCalculated ^ DataRCFrameReceived[i]);
   \                     ??DATRfNewRcBlockReceived_Static_0:
   \   0020   87             MOV       A,[HL]
   \   0021   6170           XOR       X,A
    824                  }
   \   0023   86             INCW      HL
   \   0024   52             DEC       C
   \   0025   BDF9           BNZ       ??DATRfNewRcBlockReceived_Static_0
    825          
    826                  if (ParityCodeCalculated == DataRCFrameReceived[cNbBytesRCFrame - 1]) // Parity is Ok
   \   0027   60             MOV       A,X
   \   0028   48....         CMP       A,DataRCFrameReceived+10
   \   002B   AD03           BZ        $+5
   \   002D   9B....         BR        N:??DATRfArmerNbAlarmITForDiag_16
    827                  { 
    828                      ExtractDataFromRCFrameReceived(); //Extract all data contained in the RC frame received
   \   0030   16....         MOVW      HL,#LWRD(ExtractDataFromRCFrameReceived)
   \   0033   A4..           MOV       E,#BYTE3(ExtractDataFromRCFrameReceived)
   \   0035   ..             CALLT     [__T_?FAR_FAST_CALL_L07]
    829          
    830          #ifdef X90_PROJECT // Cm007542: TRF_RECU is on when no frame detected
    831          #ifdef _DIAGNOSTIC_MEMO_    //For Diagnostic (both for normal and passing RF mode)  
    832                  ArmerNbAlarmITForDiag(cDiagRfFrameReceived);
   \   0036   A110           MOV       A,#16
   \   0038   16....         MOVW      HL,#LWRD(ArmerNbAlarmITForDiag)
   \   003B   A4..           MOV       E,#BYTE3(ArmerNbAlarmITForDiag)
   \   003D   ..             CALLT     [__T_?FAR_FAST_CALL_L07]
    833          #endif
    834          #endif
    835          
    836          #ifdef _PASSING_RF_
    837                  RCBlockReceivedIsOK = cTrue; //RC frame is accepted 
    838          #else
    839          
    840                      //Verify IDE & SI
    841                      //---------------
    842                      // Test if this is a new key press 
    843                      NewKeyPressAndIdentifierOk = cFalse;
   \   003E   891C           MOVW      AX,SP
   \   0040   80             INCW      AX
   \   0041   80             INCW      AX
   \   0042   D6             MOVW      HL,AX
   \   0043   A100           MOV       A,#0
   \   0045   97             MOV       [HL],A
    844                      for (i=0; ((i<4) && (NewKeyPressAndIdentifierOk == cFalse)) ;i++)
   \   0046   891C           MOVW      AX,SP
   \   0048   80             INCW      AX
   \   0049   D6             MOVW      HL,AX
   \   004A   A100           MOV       A,#0
   \   004C   97             MOV       [HL],A
   \   004D   14....         MOVW      DE,#DATDbkMirrors
    845                      {
    846                          KeyIdentifier = mDATReadTable (U32Bit, TableOfKeyIdentifier, i, Default);
    847          
    848                          // IF (the KeyIdentifier is correct) AND (KeyIdentifier is knew) 
    849                          // THEN NewKeyPressAndIdentifierOk = cTrue
    850                          if (   (DATRfRCFrameIDEReceived == KeyIdentifier) 
    851                              && (RCFrameSIReceived
    852                              != ((U16)(mDATReadTable (U32Bit, TableOfCurrentResynchroValue, i, Default)) & 0x03FF)))
   \                     ??DATRfNewRcBlockReceived_Static_1:
   \   0050   C4             MOVW      AX,DE
   \   0051   D6             MOVW      HL,AX
   \   0052   AE46           MOV       A,[HL+0x46]
   \   0054   70             MOV       X,A
   \   0055   AE47           MOV       A,[HL+0x47]
   \   0057   D2             MOVW      BC,AX
   \   0058   100000         MOVW      AX,#0
   \   005B   B3             PUSH      BC
   \   005C   B1             PUSH      AX
   \   005D   AE44           MOV       A,[HL+0x44]
   \   005F   70             MOV       X,A
   \   0060   AE45           MOV       A,[HL+0x45]
   \   0062   120000         MOVW      BC,#0
   \   0065   D6             MOVW      HL,AX
   \   0066   891C           MOVW      AX,SP
   \   0068   E6             XCHW      AX,HL
   \   0069   E2             XCHW      AX,BC
   \   006A   0902           ADD       A,[HL+0x02]
   \   006C   30             XCH       A,X
   \   006D   0903           ADD       A,[HL+0x03]
   \   006F   E2             XCHW      AX,BC
   \   0070   B6             POP       HL
   \   0071   B6             POP       HL
   \   0072   B3             PUSH      BC
   \   0073   B1             PUSH      AX
   \   0074   02....         MOVW      AX,DATRfRCFrameIDEReceived+2
   \   0077   D2             MOVW      BC,AX
   \   0078   02....         MOVW      AX,DATRfRCFrameIDEReceived
   \   007B   D6             MOVW      HL,AX
   \   007C   891C           MOVW      AX,SP
   \   007E   E6             XCHW      AX,HL
   \   007F   B5             PUSH      DE
   \   0080   D4             MOVW      DE,AX
   \   0081   64             MOV       A,E
   \   0082   1F             SUB       A,[HL]
   \   0083   70             MOV       X,A
   \   0084   65             MOV       A,D
   \   0085   3901           SUBC      A,[HL+0x01]
   \   0087   6160           OR        X,A
   \   0089   62             MOV       A,C
   \   008A   3902           SUBC      A,[HL+0x02]
   \   008C   6160           OR        X,A
   \   008E   63             MOV       A,B
   \   008F   3903           SUBC      A,[HL+0x03]
   \   0091   6160           OR        X,A
   \   0093   B4             POP       DE
   \   0094   B6             POP       HL
   \   0095   B6             POP       HL
   \   0096   BD23           BNZ       ??DATRfArmerNbAlarmITForDiag_17
   \   0098   C4             MOVW      AX,DE
   \   0099   D6             MOVW      HL,AX
   \   009A   AE90           MOV       A,[HL+0x90]
   \   009C   70             MOV       X,A
   \   009D   AE91           MOV       A,[HL+0x91]
   \   009F   5D03           AND       A,#3
   \   00A1   D6             MOVW      HL,AX
   \   00A2   02....         MOVW      AX,RCFrameSIReceived
   \   00A5   30             XCH       A,X
   \   00A6   611E           SUB       A,L
   \   00A8   30             XCH       A,X
   \   00A9   613F           SUBC      A,H
   \   00AB   6168           OR        A,X
   \   00AD   AD0C           BZ        ??DATRfArmerNbAlarmITForDiag_17
    853                          {
    854                          IndiceKeyRf = i;
   \   00AF   891C           MOVW      AX,SP
   \   00B1   80             INCW      AX
   \   00B2   D6             MOVW      HL,AX
   \   00B3   87             MOV       A,[HL]
   \   00B4   9E....         MOV       IndiceKeyRf,A
    855                          NewKeyPressAndIdentifierOk = cTrue;
   \   00B7   A101           MOV       A,#1
   \   00B9   86             INCW      HL
   \   00BA   97             MOV       [HL],A
    856                          }  
    857                          else
    858                          { // Nothing to do
    859                          } 
    860                      } 
   \                     ??DATRfArmerNbAlarmITForDiag_17:
   \   00BB   891C           MOVW      AX,SP
   \   00BD   D6             MOVW      HL,AX
   \   00BE   AE01           MOV       A,[HL+0x01]
   \   00C0   41             INC       A
   \   00C1   BE01           MOV       [HL+0x01],A
   \   00C3   84             INCW      DE
   \   00C4   84             INCW      DE
   \   00C5   84             INCW      DE
   \   00C6   84             INCW      DE
   \   00C7   86             INCW      HL
   \   00C8   4D04           CMP       A,#4
   \   00CA   9D09           BNC       ??DATRfArmerNbAlarmITForDiag_18
   \   00CC   AE01           MOV       A,[HL+0x01]
   \   00CE   4D00           CMP       A,#0
   \   00D0   BD03           BNZ       $+5
   \   00D2   9B....         BR        N:??DATRfNewRcBlockReceived_Static_1
    861          
    862          
    863                      //Verify RC
    864                      //---------
    865                      if (NewKeyPressAndIdentifierOk == cTrue) //New button pressed and identifier Ok
   \                     ??DATRfArmerNbAlarmITForDiag_18:
   \   00D5   AE01           MOV       A,[HL+0x01]
   \   00D7   51             DEC       A
   \   00D8   BD64           BNZ       ??DATRfArmerNbAlarmITForDiag_15
    866                      { 
    867                          //Building of expected SI28Bits 
    868                          RollingCodeCalculated
    869                             = BuildingSI28BitsTheoric( (U32)(mDATReadTable (U32Bit, TableOfCurrentResynchroValue, IndiceKeyRf, Default)) );
   \   00DA   8E....         MOV       A,IndiceKeyRf
   \   00DD   A004           MOV       X,#4
   \   00DF   3188           MULU      X
   \   00E1   CA....         ADDW      AX,#DATDbkMirrors+146
   \   00E4   D6             MOVW      HL,AX
   \   00E5   87             MOV       A,[HL]
   \   00E6   70             MOV       X,A
   \   00E7   AE01           MOV       A,[HL+0x01]
   \   00E9   D2             MOVW      BC,AX
   \   00EA   100000         MOVW      AX,#0
   \   00ED   B3             PUSH      BC
   \   00EE   B1             PUSH      AX
   \   00EF   8E....         MOV       A,IndiceKeyRf
   \   00F2   A004           MOV       X,#4
   \   00F4   3188           MULU      X
   \   00F6   CA....         ADDW      AX,#DATDbkMirrors+144
   \   00F9   D6             MOVW      HL,AX
   \   00FA   87             MOV       A,[HL]
   \   00FB   70             MOV       X,A
   \   00FC   AE01           MOV       A,[HL+0x01]
   \   00FE   120000         MOVW      BC,#0
   \   0101   D6             MOVW      HL,AX
   \   0102   891C           MOVW      AX,SP
   \   0104   E6             XCHW      AX,HL
   \   0105   E2             XCHW      AX,BC
   \   0106   0902           ADD       A,[HL+0x02]
   \   0108   30             XCH       A,X
   \   0109   0903           ADD       A,[HL+0x03]
   \   010B   E2             XCHW      AX,BC
   \   010C   B6             POP       HL
   \   010D   B6             POP       HL
   \   010E   16....         MOVW      HL,#LWRD(BuildingSI28BitsTheoric)
   \   0111   A4..           MOV       E,#BYTE3(BuildingSI28BitsTheoric)
   \   0113   ..             CALLT     [__T_?FAR_FAST_CALL_L07]
    870                
    871                          // Test of rolling code
    872                         if (RollingCodeCalculated == DATRfRCFrameSRReceived.Format32Bit)
   \   0114   B5             PUSH      DE
   \   0115   D4             MOVW      DE,AX
   \   0116   64             MOV       A,E
   \   0117   18....         SUB       A,DATRfRCFrameSRReceived
   \   011A   70             MOV       X,A
   \   011B   65             MOV       A,D
   \   011C   38....         SUBC      A,DATRfRCFrameSRReceived+1
   \   011F   6160           OR        X,A
   \   0121   62             MOV       A,C
   \   0122   38....         SUBC      A,DATRfRCFrameSRReceived+2
   \   0125   6160           OR        X,A
   \   0127   63             MOV       A,B
   \   0128   38....         SUBC      A,DATRfRCFrameSRReceived+3
   \   012B   6160           OR        X,A
   \   012D   B4             POP       DE
   \   012E   BD16           BNZ       ??DATRfArmerNbAlarmITForDiag_19
    873                         { //The rolling code received is equal to previous received or in window(+0 +1024) 
    874                     
    875                             RCBlockReceivedIsOK = cTrue; //RC frame is accepted 
   \   0130   891C           MOVW      AX,SP
   \   0132   D6             MOVW      HL,AX
   \   0133   A101           MOV       A,#1
   \   0135   97             MOV       [HL],A
    876                         }
    877                         else //The rolling code is out of acceptation window, but is it in the other 
    878                              //known resynchronisation windows?
    879                         { 
    880                             //In all cases, a demand of resynchronisation is done.
    881                             UpdateKeyResynchronisation();
    882                             LDBRefreshWatchDog(); // invoke directly watchdog refreshment - needed for sleep mode
    883                             mDATWrite(U1Bit, PcfRefreshAllowed, cTrue, Default); // allow LIB_PCF to be preempted
    884              
    885                             //Building SI28Bits with initial value taught by BCM.Value used when key battery is changed
    886                             RollingCodeCalculated
    887                               = BuildingSI28BitsTheoric    ( (U32)((mDATReadTable (U32Bit, TableOfInitialResynchroValue, IndiceKeyRf, Default)) + (U32)0x08000200));
    888          
    889                             if (RollingCodeCalculated == DATRfRCFrameSRReceived.Format32Bit)    
    890                             { 
    891                                 RCBlockReceivedIsOK = cTrue; //RC frame is accepted
    892                             }
    893                             else
    894                             { //Try with the last written resync value            
    895                                 RollingCodeCalculated
    896                                    = BuildingSI28BitsTheoric( (U32)(mDATReadTable (U32Bit, TableOfDefResynchroValueWritten, IndiceKeyRf, Default)) );
    897          
    898                                 if (RollingCodeCalculated == DATRfRCFrameSRReceived.Format32Bit)    
    899                                 {
    900                                     RCBlockReceivedIsOK = cTrue; //RC frame is accepted
    901                                 }
    902                                 else
    903                                 { //Try with the last read resync value              
    904                                     RollingCodeCalculated
    905                                        = BuildingSI28BitsTheoric( (U32)(mDATReadTable (U32Bit, TableOfDefResynchroValueRead, IndiceKeyRf, Default)) );
    906          
    907                                     if (RollingCodeCalculated == DATRfRCFrameSRReceived.Format32Bit)    
    908                                     {
    909                                         RCBlockReceivedIsOK = cTrue; //RC frame is accepted
    910                                     }
    911                                     else
    912                                     { //Try with the last written resync value when the key battery has been changed                
    913                                         RollingCodeCalculated
    914                                            = BuildingSI28BitsTheoric( (U32)((mDATReadTable (U32Bit, TableOfDefResynchroValueWritten, IndiceKeyRf, Default)) + (U32)0x08000200));
    915          
    916                                         if (RollingCodeCalculated == DATRfRCFrameSRReceived.Format32Bit)    
    917                                         {
    918                                             RCBlockReceivedIsOK = cTrue; //RC frame is accepted
    919                                         }
    920                                         else
    921                                         { //Try with the last read resync value when the key battery has been changed                  
    922                                             RollingCodeCalculated
    923                                               = BuildingSI28BitsTheoric( (U32)((mDATReadTable (U32Bit, TableOfDefResynchroValueRead, IndiceKeyRf, Default)) + (U32)0x08000200));
    924          
    925                                            //To decide whether RC frame is accepted
    926                                            RCBlockReceivedIsOK = (RollingCodeCalculated == DATRfRCFrameSRReceived.Format32Bit);
    927                                         } 
    928                                     }
    929                                 }
    930                             }
    931                             mDATWrite(U1Bit, PcfRefreshAllowed, cFalse, Default); // forbid LIB_PCF to be preempted
    932                         }
    933                      }
    934                      else
    935                      { //Nothing to do: DATRfRCFrameIDEReceived or RCFrameSIReceived are not correct
    936                      }
    937          #endif //_PASSING_RF_
    938                  }
    939                  else //Bad parity, so RC frame is not accepted
    940                  { //In case it was reset before because a 1st good RCframe was received
    941                      //and so as to not wait the SIframe timeout
    942                      RCReceptionTimeOutIsActive = cTrue; 
    943                  }
    944              } 
    945              else
    946              { //Nothing to do, a RC frame has not been received
    947              }
    948          
    949          
    950          #ifdef _DIAGNOSTIC_MEMO_    //For Diagnostic   
    951              if(RCBlockReceivedIsOK == cTrue)
    952              {
    953                  ArmerNbAlarmITForDiag(cDiagRfFrameReceivedAndValid);
   \                     ??DATRfNewRcBlockReceived_Static_2:
   \   0136   A120           MOV       A,#32
   \   0138   16....         MOVW      HL,#LWRD(ArmerNbAlarmITForDiag)
   \   013B   A4..           MOV       E,#BYTE3(ArmerNbAlarmITForDiag)
   \   013D   ..             CALLT     [__T_?FAR_FAST_CALL_L07]
    954              }
    955               else
    956              {} //nothing to do
    957          #endif
    958          
    959              return (RCBlockReceivedIsOK);
   \                     ??DATRfArmerNbAlarmITForDiag_15:
   \   013E   891C           MOVW      AX,SP
   \   0140   D6             MOVW      HL,AX
   \   0141   87             MOV       A,[HL]
   \   0142   B2             POP       BC
   \   0143   B2             POP       BC
   \   0144   B2             POP       BC
   \   0145   AF             RET       
   \                     ??DATRfArmerNbAlarmITForDiag_19:
   \   0146   9A....         CALL      UpdateKeyResynchronisation
   \   0149   9A....         CALL      LDBRefreshWatchDog
   \   014C   A101           MOV       A,#1
   \   014E   9E....         MOV       DATCmnData,A
   \   0151   8E....         MOV       A,IndiceKeyRf
   \   0154   A004           MOV       X,#4
   \   0156   3188           MULU      X
   \   0158   CA....         ADDW      AX,#DATDbkMirrors+162
   \   015B   D6             MOVW      HL,AX
   \   015C   87             MOV       A,[HL]
   \   015D   70             MOV       X,A
   \   015E   AE01           MOV       A,[HL+0x01]
   \   0160   D2             MOVW      BC,AX
   \   0161   100000         MOVW      AX,#0
   \   0164   B3             PUSH      BC
   \   0165   B1             PUSH      AX
   \   0166   8E....         MOV       A,IndiceKeyRf
   \   0169   A004           MOV       X,#4
   \   016B   3188           MULU      X
   \   016D   CA....         ADDW      AX,#DATDbkMirrors+160
   \   0170   D6             MOVW      HL,AX
   \   0171   87             MOV       A,[HL]
   \   0172   70             MOV       X,A
   \   0173   AE01           MOV       A,[HL+0x01]
   \   0175   120000         MOVW      BC,#0
   \   0178   D6             MOVW      HL,AX
   \   0179   891C           MOVW      AX,SP
   \   017B   E6             XCHW      AX,HL
   \   017C   E2             XCHW      AX,BC
   \   017D   0902           ADD       A,[HL+0x02]
   \   017F   30             XCH       A,X
   \   0180   0903           ADD       A,[HL+0x03]
   \   0182   E2             XCHW      AX,BC
   \   0183   B6             POP       HL
   \   0184   B6             POP       HL
   \   0185   0D02           ADD       A,#2
   \   0187   E2             XCHW      AX,BC
   \   0188   30             XCH       A,X
   \   0189   2D00           ADDC      A,#0
   \   018B   30             XCH       A,X
   \   018C   2D08           ADDC      A,#8
   \   018E   E2             XCHW      AX,BC
   \   018F   16....         MOVW      HL,#LWRD(BuildingSI28BitsTheoric)
   \   0192   A4..           MOV       E,#BYTE3(BuildingSI28BitsTheoric)
   \   0194   ..             CALLT     [__T_?FAR_FAST_CALL_L07]
   \   0195   B5             PUSH      DE
   \   0196   D4             MOVW      DE,AX
   \   0197   64             MOV       A,E
   \   0198   18....         SUB       A,DATRfRCFrameSRReceived
   \   019B   70             MOV       X,A
   \   019C   65             MOV       A,D
   \   019D   38....         SUBC      A,DATRfRCFrameSRReceived+1
   \   01A0   6160           OR        X,A
   \   01A2   62             MOV       A,C
   \   01A3   38....         SUBC      A,DATRfRCFrameSRReceived+2
   \   01A6   6160           OR        X,A
   \   01A8   63             MOV       A,B
   \   01A9   38....         SUBC      A,DATRfRCFrameSRReceived+3
   \   01AC   6160           OR        X,A
   \   01AE   B4             POP       DE
   \   01AF   BD09           BNZ       ??DATRfArmerNbAlarmITForDiag_20
   \                     ??DATRfNewRcBlockReceived_Static_3:
   \   01B1   891C           MOVW      AX,SP
   \   01B3   D6             MOVW      HL,AX
   \   01B4   A101           MOV       A,#1
   \   01B6   97             MOV       [HL],A
   \   01B7   9B....         BR        N:??DATRfArmerNbAlarmITForDiag_21
   \                     ??DATRfArmerNbAlarmITForDiag_20:
   \   01BA   8E....         MOV       A,IndiceKeyRf
   \   01BD   A004           MOV       X,#4
   \   01BF   3188           MULU      X
   \   01C1   CA....         ADDW      AX,#DATDbkMirrors+194
   \   01C4   D6             MOVW      HL,AX
   \   01C5   87             MOV       A,[HL]
   \   01C6   70             MOV       X,A
   \   01C7   AE01           MOV       A,[HL+0x01]
   \   01C9   D2             MOVW      BC,AX
   \   01CA   100000         MOVW      AX,#0
   \   01CD   B3             PUSH      BC
   \   01CE   B1             PUSH      AX
   \   01CF   8E....         MOV       A,IndiceKeyRf
   \   01D2   A004           MOV       X,#4
   \   01D4   3188           MULU      X
   \   01D6   CA....         ADDW      AX,#DATDbkMirrors+192
   \   01D9   D6             MOVW      HL,AX
   \   01DA   87             MOV       A,[HL]
   \   01DB   70             MOV       X,A
   \   01DC   AE01           MOV       A,[HL+0x01]
   \   01DE   120000         MOVW      BC,#0
   \   01E1   D6             MOVW      HL,AX
   \   01E2   891C           MOVW      AX,SP
   \   01E4   E6             XCHW      AX,HL
   \   01E5   E2             XCHW      AX,BC
   \   01E6   0902           ADD       A,[HL+0x02]
   \   01E8   30             XCH       A,X
   \   01E9   0903           ADD       A,[HL+0x03]
   \   01EB   E2             XCHW      AX,BC
   \   01EC   B6             POP       HL
   \   01ED   B6             POP       HL
   \   01EE   16....         MOVW      HL,#LWRD(BuildingSI28BitsTheoric)
   \   01F1   A4..           MOV       E,#BYTE3(BuildingSI28BitsTheoric)
   \   01F3   ..             CALLT     [__T_?FAR_FAST_CALL_L07]
   \   01F4   B5             PUSH      DE
   \   01F5   D4             MOVW      DE,AX
   \   01F6   64             MOV       A,E
   \   01F7   18....         SUB       A,DATRfRCFrameSRReceived
   \   01FA   70             MOV       X,A
   \   01FB   65             MOV       A,D
   \   01FC   38....         SUBC      A,DATRfRCFrameSRReceived+1
   \   01FF   6160           OR        X,A
   \   0201   62             MOV       A,C
   \   0202   38....         SUBC      A,DATRfRCFrameSRReceived+2
   \   0205   6160           OR        X,A
   \   0207   63             MOV       A,B
   \   0208   38....         SUBC      A,DATRfRCFrameSRReceived+3
   \   020B   6160           OR        X,A
   \   020D   B4             POP       DE
   \   020E   ADA1           BZ        ??DATRfNewRcBlockReceived_Static_3
   \   0210   8E....         MOV       A,IndiceKeyRf
   \   0213   A004           MOV       X,#4
   \   0215   3188           MULU      X
   \   0217   CA....         ADDW      AX,#DATDbkMirrors+178
   \   021A   D6             MOVW      HL,AX
   \   021B   87             MOV       A,[HL]
   \   021C   70             MOV       X,A
   \   021D   AE01           MOV       A,[HL+0x01]
   \   021F   D2             MOVW      BC,AX
   \   0220   100000         MOVW      AX,#0
   \   0223   B3             PUSH      BC
   \   0224   B1             PUSH      AX
   \   0225   8E....         MOV       A,IndiceKeyRf
   \   0228   A004           MOV       X,#4
   \   022A   3188           MULU      X
   \   022C   CA....         ADDW      AX,#DATDbkMirrors+176
   \   022F   D6             MOVW      HL,AX
   \   0230   87             MOV       A,[HL]
   \   0231   70             MOV       X,A
   \   0232   AE01           MOV       A,[HL+0x01]
   \   0234   120000         MOVW      BC,#0
   \   0237   D6             MOVW      HL,AX
   \   0238   891C           MOVW      AX,SP
   \   023A   E6             XCHW      AX,HL
   \   023B   E2             XCHW      AX,BC
   \   023C   0902           ADD       A,[HL+0x02]
   \   023E   30             XCH       A,X
   \   023F   0903           ADD       A,[HL+0x03]
   \   0241   E2             XCHW      AX,BC
   \   0242   B6             POP       HL
   \   0243   B6             POP       HL
   \   0244   16....         MOVW      HL,#LWRD(BuildingSI28BitsTheoric)
   \   0247   A4..           MOV       E,#BYTE3(BuildingSI28BitsTheoric)
   \   0249   ..             CALLT     [__T_?FAR_FAST_CALL_L07]
   \   024A   B5             PUSH      DE
   \   024B   D4             MOVW      DE,AX
   \   024C   64             MOV       A,E
   \   024D   18....         SUB       A,DATRfRCFrameSRReceived
   \   0250   70             MOV       X,A
   \   0251   65             MOV       A,D
   \   0252   38....         SUBC      A,DATRfRCFrameSRReceived+1
   \   0255   6160           OR        X,A
   \   0257   62             MOV       A,C
   \   0258   38....         SUBC      A,DATRfRCFrameSRReceived+2
   \   025B   6160           OR        X,A
   \   025D   63             MOV       A,B
   \   025E   38....         SUBC      A,DATRfRCFrameSRReceived+3
   \   0261   6160           OR        X,A
   \   0263   B4             POP       DE
   \   0264   BD03           BNZ       $+5
   \   0266   9B....         BR        N:??DATRfNewRcBlockReceived_Static_3
   \   0269   8E....         MOV       A,IndiceKeyRf
   \   026C   A004           MOV       X,#4
   \   026E   3188           MULU      X
   \   0270   CA....         ADDW      AX,#DATDbkMirrors+194
   \   0273   D6             MOVW      HL,AX
   \   0274   87             MOV       A,[HL]
   \   0275   70             MOV       X,A
   \   0276   AE01           MOV       A,[HL+0x01]
   \   0278   D2             MOVW      BC,AX
   \   0279   100000         MOVW      AX,#0
   \   027C   B3             PUSH      BC
   \   027D   B1             PUSH      AX
   \   027E   8E....         MOV       A,IndiceKeyRf
   \   0281   A004           MOV       X,#4
   \   0283   3188           MULU      X
   \   0285   CA....         ADDW      AX,#DATDbkMirrors+192
   \   0288   D6             MOVW      HL,AX
   \   0289   87             MOV       A,[HL]
   \   028A   70             MOV       X,A
   \   028B   AE01           MOV       A,[HL+0x01]
   \   028D   120000         MOVW      BC,#0
   \   0290   D6             MOVW      HL,AX
   \   0291   891C           MOVW      AX,SP
   \   0293   E6             XCHW      AX,HL
   \   0294   E2             XCHW      AX,BC
   \   0295   0902           ADD       A,[HL+0x02]
   \   0297   30             XCH       A,X
   \   0298   0903           ADD       A,[HL+0x03]
   \   029A   E2             XCHW      AX,BC
   \   029B   B6             POP       HL
   \   029C   B6             POP       HL
   \   029D   0D02           ADD       A,#2
   \   029F   E2             XCHW      AX,BC
   \   02A0   30             XCH       A,X
   \   02A1   2D00           ADDC      A,#0
   \   02A3   30             XCH       A,X
   \   02A4   2D08           ADDC      A,#8
   \   02A6   E2             XCHW      AX,BC
   \   02A7   16....         MOVW      HL,#LWRD(BuildingSI28BitsTheoric)
   \   02AA   A4..           MOV       E,#BYTE3(BuildingSI28BitsTheoric)
   \   02AC   ..             CALLT     [__T_?FAR_FAST_CALL_L07]
   \   02AD   B5             PUSH      DE
   \   02AE   D4             MOVW      DE,AX
   \   02AF   64             MOV       A,E
   \   02B0   18....         SUB       A,DATRfRCFrameSRReceived
   \   02B3   70             MOV       X,A
   \   02B4   65             MOV       A,D
   \   02B5   38....         SUBC      A,DATRfRCFrameSRReceived+1
   \   02B8   6160           OR        X,A
   \   02BA   62             MOV       A,C
   \   02BB   38....         SUBC      A,DATRfRCFrameSRReceived+2
   \   02BE   6160           OR        X,A
   \   02C0   63             MOV       A,B
   \   02C1   38....         SUBC      A,DATRfRCFrameSRReceived+3
   \   02C4   6160           OR        X,A
   \   02C6   B4             POP       DE
   \   02C7   BD03           BNZ       $+5
   \   02C9   9B....         BR        N:??DATRfNewRcBlockReceived_Static_3
   \   02CC   8E....         MOV       A,IndiceKeyRf
   \   02CF   A004           MOV       X,#4
   \   02D1   3188           MULU      X
   \   02D3   CA....         ADDW      AX,#DATDbkMirrors+178
   \   02D6   D6             MOVW      HL,AX
   \   02D7   87             MOV       A,[HL]
   \   02D8   70             MOV       X,A
   \   02D9   AE01           MOV       A,[HL+0x01]
   \   02DB   D2             MOVW      BC,AX
   \   02DC   100000         MOVW      AX,#0
   \   02DF   B3             PUSH      BC
   \   02E0   B1             PUSH      AX
   \   02E1   8E....         MOV       A,IndiceKeyRf
   \   02E4   A004           MOV       X,#4
   \   02E6   3188           MULU      X
   \   02E8   CA....         ADDW      AX,#DATDbkMirrors+176
   \   02EB   D6             MOVW      HL,AX
   \   02EC   87             MOV       A,[HL]
   \   02ED   70             MOV       X,A
   \   02EE   AE01           MOV       A,[HL+0x01]
   \   02F0   120000         MOVW      BC,#0
   \   02F3   D6             MOVW      HL,AX
   \   02F4   891C           MOVW      AX,SP
   \   02F6   E6             XCHW      AX,HL
   \   02F7   E2             XCHW      AX,BC
   \   02F8   0902           ADD       A,[HL+0x02]
   \   02FA   30             XCH       A,X
   \   02FB   0903           ADD       A,[HL+0x03]
   \   02FD   E2             XCHW      AX,BC
   \   02FE   B6             POP       HL
   \   02FF   B6             POP       HL
   \   0300   0D02           ADD       A,#2
   \   0302   E2             XCHW      AX,BC
   \   0303   30             XCH       A,X
   \   0304   2D00           ADDC      A,#0
   \   0306   30             XCH       A,X
   \   0307   2D08           ADDC      A,#8
   \   0309   E2             XCHW      AX,BC
   \   030A   16....         MOVW      HL,#LWRD(BuildingSI28BitsTheoric)
   \   030D   A4..           MOV       E,#BYTE3(BuildingSI28BitsTheoric)
   \   030F   ..             CALLT     [__T_?FAR_FAST_CALL_L07]
   \   0310   B5             PUSH      DE
   \   0311   D4             MOVW      DE,AX
   \   0312   64             MOV       A,E
   \   0313   18....         SUB       A,DATRfRCFrameSRReceived
   \   0316   70             MOV       X,A
   \   0317   65             MOV       A,D
   \   0318   38....         SUBC      A,DATRfRCFrameSRReceived+1
   \   031B   6160           OR        X,A
   \   031D   62             MOV       A,C
   \   031E   38....         SUBC      A,DATRfRCFrameSRReceived+2
   \   0321   6160           OR        X,A
   \   0323   63             MOV       A,B
   \   0324   38....         SUBC      A,DATRfRCFrameSRReceived+3
   \   0327   6160           OR        X,A
   \   0329   B4             POP       DE
   \   032A   BD03           BNZ       $+5
   \   032C   9B....         BR        N:??DATRfNewRcBlockReceived_Static_3
   \                     ??DATRfArmerNbAlarmITForDiag_21:
   \   032F   A100           MOV       A,#0
   \   0331   9E....         MOV       DATCmnData,A
   \   0334   891C           MOVW      AX,SP
   \   0336   D6             MOVW      HL,AX
   \   0337   87             MOV       A,[HL]
   \   0338   51             DEC       A
   \   0339   AD03           BZ        $+5
   \   033B   9B....         BR        N:??DATRfArmerNbAlarmITForDiag_15
   \   033E   9B....         BR        N:??DATRfNewRcBlockReceived_Static_2
   \                     ??DATRfArmerNbAlarmITForDiag_16:
   \   0341   A101           MOV       A,#1
   \   0343   9E....         MOV       RCReceptionTimeOutIsActive,A
   \   0346   9B....         BR        N:??DATRfArmerNbAlarmITForDiag_15
   \   0349                  REQUIRE ?CL78K_V4_6_L00
    960          }
    961          
    962          //==============================================================================
    963          //  DESCRIPTION : DATRfRCReceptionTimeElapsedOrLongPushReceiveTimeElapsed
    964          //  
    965          //  PARAMETERS (Type,Name,Min,Max) :   none
    966          //
    967          //  RETURN VALUE :   
    968          // 
    969          //  DESIGN INFORMATION :   refer to Detailed Design Document
    970          //     
    971          //==============================================================================

   \                                 In  segment CODE, align 1, keep-with-next
    972          BOOL DATRfRCReceptionTimeElapsedOrLongPushReceiveTimeElapsed(void)
   \                     DATRfRCReceptionTimeElapsedOrLongPushReceiveTimeElapsed:
    973          {
   \   0000                  ; * Stack frame (at entry) *
   \   0000                  ; Param size: 0
   \   0000                  ; Total Auto size: 0
    974              BOOL TimeElapsed;
    975              TimeElapsed =
    976                 (  (  (TempoAlarmITForRCReceptionTimeOut == 0) && RCReceptionTimeOutIsActive   )
    977                    || (  (TempoAlarmITForLongPushReceiveTimeOut == 0) && LongPushTimeOutIsActive   )
    978                 );  
   \   0000   8E....         MOV       A,TempoAlarmITForRCReceptionTimeOut
   \   0003   4D00           CMP       A,#0
   \   0005   BD07           BNZ       ??DATRfArmerNbAlarmITForDiag_44
   \   0007   8E....         MOV       A,RCReceptionTimeOutIsActive
   \   000A   4D00           CMP       A,#0
   \   000C   BD0E           BNZ       ??DATRfArmerNbAlarmITForDiag_45
   \                     ??DATRfArmerNbAlarmITForDiag_44:
   \   000E   8E....         MOV       A,TempoAlarmITForLongPushReceiveTimeOut
   \   0011   4D00           CMP       A,#0
   \   0013   BD0A           BNZ       ??DATRfArmerNbAlarmITForDiag_46
   \   0015   8E....         MOV       A,LongPushTimeOutIsActive
   \   0018   4D00           CMP       A,#0
   \   001A   AD03           BZ        ??DATRfArmerNbAlarmITForDiag_46
   \                     ??DATRfArmerNbAlarmITForDiag_45:
   \   001C   A101           MOV       A,#1
   \   001E   AF             RET       
   \                     ??DATRfArmerNbAlarmITForDiag_46:
   \   001F   A100           MOV       A,#0
    979          
    980              return (TimeElapsed);
   \   0021   AF             RET       
   \   0022                  REQUIRE ?CL78K_V4_6_L00
    981          }
    982          
    983          //==============================================================================
    984          //  DESCRIPTION : DATRfSearchWakeUpBlock
    985          //  
    986          //  PARAMETERS (Type,Name,Min,Max) :   none
    987          //
    988          //  RETURN VALUE :   none
    989          // 
    990          //  DESIGN INFORMATION :   refer to Detailed Design Document
    991          //     
    992          //==============================================================================

   \                                 In  segment CODE, align 1, keep-with-next
    993          void DATRfSearchWakeUpBlock(void)
   \                     DATRfSearchWakeUpBlock:
    994          {
   \   0000                  ; * Stack frame (at entry) *
   \   0000                  ; Param size: 0
   \   0000   A101           MOV       A,#1
   \   0002   B5             PUSH      DE
   \   0003                  ; Total Auto size: 0
    995              LDBControl(cLDBChannelRf, cLDBRfStop);
   \   0003   16....         MOVW      HL,#LWRD(LDBRfControl)
   \   0006   A4..           MOV       E,#BYTE3(LDBRfControl)
   \   0008   ..             CALLT     [__T_?FAR_CALL_L07]
    996              SearchFrameInCourse = cFalse;
   \   0009   A100           MOV       A,#0
   \   000B   9E....         MOV       SearchFrameInCourse,A
    997              RCReceptionTimeOutIsActive = cFalse;
   \   000E   9E....         MOV       RCReceptionTimeOutIsActive,A
    998              // Stop Timeout for SI reception 
    999              LongPushTimeOutIsActive    = cFalse;
   \   0011                  REQUIRE ?CL78K_V4_6_L00
   \   0011                  REQUIRE ?Subroutine0
   \   0011                  ; // Fall through to label ?Subroutine0
   1000          }

   \                                 In  segment CODE, align 1, keep-with-next
   \                     ?Subroutine0:
   \   0000   9E....         MOV       LongPushTimeOutIsActive,A
   \   0003   B4             POP       DE
   \   0004   AF             RET       
   \   0005                  REQUIRE ?CL78K_V4_6_L00
   1001          
   1002          //==============================================================================
   1003          //  DESCRIPTION : DATRfShortPushDetectedAndArmLongPushTimer
   1004          //  
   1005          //  PARAMETERS (Type,Name,Min,Max) :   none
   1006          //
   1007          //  RETURN VALUE :   none
   1008          // 
   1009          //  DESIGN INFORMATION :   refer to Detailed Design Document
   1010          //     
   1011          //==============================================================================

   \                                 In  segment CODE, align 1, keep-with-next
   1012          void DATRfShortPushDetectedAndArmLongPushTimer(void)
   \                     DATRfShortPushDetectedAndArmLongPushTimer:
   1013          {
   \   0000                  ; * Stack frame (at entry) *
   \   0000                  ; Param size: 0
   \   0000   B5             PUSH      DE
   \   0001                  ; Total Auto size: 0
   1014          #ifdef X90_PROJECT
   1015              DATRfShortPushDetectedAndArmLongPushTimer_Static();
   \   0001   16....         MOVW      HL,#LWRD(DATRfShortPushDetectedAndArmLongPushTimer_Static)
   \   0004   A4..           MOV       E,#BYTE3(DATRfShortPushDetectedAndArmLongPushTimer_Static)
   \   0006   ..             CALLT     [__T_?FAR_CALL_L07]
   1016          }
   \   0007   B4             POP       DE
   \   0008   AF             RET       
   \   0009                  REQUIRE ?CL78K_V4_6_L00
   1017          #pragma optimize=no_inline

   \                                 In  segment BCODE, align 1, keep-with-next
   1018          static MEM_TYPE void DATRfShortPushDetectedAndArmLongPushTimer_Static(void)
   \                     DATRfShortPushDetectedAndArmLongPushTimer_Static:
   1019          {
   \   0000                  ; * Stack frame (at entry) *
   \   0000                  ; Param size: 0
   \   0000   A102           MOV       A,#2
   \   0002   B3             PUSH      BC
   \   0003                  ; Total Auto size: 0
   1020          #endif
   1021              TOSSendControl(cTOSControlWakeUpRequest); //Wake LAP up
   \   0003   ..             CALLT     [__T_TOSSendControl]
   1022          
   1023              //Button short push is saved for LAP to read
   1024              ButtonPushed = (RCFrameCIDReceived & cMaskNonExistingButtons);
   \   0004   8E....         MOV       A,RCFrameCIDReceived
   \   0007   9E....         MOV       ButtonPushed,A
   1025          
   1026              //Stop Timeout for RC reception and save last SI block received in EEPROM
   1027              RCReceptionTimeOutIsActive = cFalse;
   \   000A   A100           MOV       A,#0
   \   000C   9E....         MOV       RCReceptionTimeOutIsActive,A
   1028          #ifdef _PASSING_RF_
   1029              mDATWriteTable (U32Bit, TableOfCurrentResynchroValue, 0, RCFrameSIReceived, Default);
   1030          #else
   1031              mDATWriteTable (U32Bit, TableOfCurrentResynchroValue, IndiceKeyRf, SI28BitsLastRCFrameKnown, Default);
   \   000F   8E....         MOV       A,IndiceKeyRf
   \   0012   A004           MOV       X,#4
   \   0014   3188           MULU      X
   \   0016   CA....         ADDW      AX,#DATDbkMirrors
   \   0019   D4             MOVW      DE,AX
   \   001A   D6             MOVW      HL,AX
   \   001B   AE92           MOV       A,[HL+0x92]
   \   001D   70             MOV       X,A
   \   001E   AE93           MOV       A,[HL+0x93]
   \   0020   D2             MOVW      BC,AX
   \   0021   100000         MOVW      AX,#0
   \   0024   B3             PUSH      BC
   \   0025   B1             PUSH      AX
   \   0026   AE90           MOV       A,[HL+0x90]
   \   0028   70             MOV       X,A
   \   0029   AE91           MOV       A,[HL+0x91]
   \   002B   120000         MOVW      BC,#0
   \   002E   D6             MOVW      HL,AX
   \   002F   891C           MOVW      AX,SP
   \   0031   E6             XCHW      AX,HL
   \   0032   E2             XCHW      AX,BC
   \   0033   0902           ADD       A,[HL+0x02]
   \   0035   30             XCH       A,X
   \   0036   0903           ADD       A,[HL+0x03]
   \   0038   E2             XCHW      AX,BC
   \   0039   B6             POP       HL
   \   003A   B6             POP       HL
   \   003B   B5             PUSH      DE
   \   003C   D4             MOVW      DE,AX
   \   003D   64             MOV       A,E
   \   003E   18....         SUB       A,SI28BitsLastRCFrameKnown
   \   0041   70             MOV       X,A
   \   0042   65             MOV       A,D
   \   0043   38....         SUBC      A,SI28BitsLastRCFrameKnown+1
   \   0046   6160           OR        X,A
   \   0048   62             MOV       A,C
   \   0049   38....         SUBC      A,SI28BitsLastRCFrameKnown+2
   \   004C   6160           OR        X,A
   \   004E   63             MOV       A,B
   \   004F   38....         SUBC      A,SI28BitsLastRCFrameKnown+3
   \   0052   6160           OR        X,A
   \   0054   B4             POP       DE
   \   0055   AD19           BZ        ??DATRfArmerNbAlarmITForDiag_22
   \   0057   02....         MOVW      AX,SI28BitsLastRCFrameKnown
   \   005A   D2             MOVW      BC,AX
   \   005B   C4             MOVW      AX,DE
   \   005C   D6             MOVW      HL,AX
   \   005D   C2             MOVW      AX,BC
   \   005E   BE91           MOV       [HL+0x91],A
   \   0060   60             MOV       A,X
   \   0061   BE90           MOV       [HL+0x90],A
   \   0063   02....         MOVW      AX,SI28BitsLastRCFrameKnown+2
   \   0066   BE93           MOV       [HL+0x93],A
   \   0068   60             MOV       A,X
   \   0069   BE92           MOV       [HL+0x92],A
   \   006B   A104           MOV       A,#4
   \   006D   9A....         CALL      DATDbkStartUpdate
   1032          #endif
   1033          
   1034              //Start tempo for long push management
   1035              LongPushTimeOutIsActive               = cTrue;
   \                     ??DATRfArmerNbAlarmITForDiag_22:
   \   0070   A101           MOV       A,#1
   \   0072   9E....         MOV       LongPushTimeOutIsActive,A
   1036              TempoAlarmITForLongPushWaitTimeOut    = cLongPushWaitTimeOut;
   \   0075   A132           MOV       A,#50
   \   0077   9E....         MOV       TempoAlarmITForLongPushWaitTimeOut,A
   1037              TempoAlarmITForLongPushReceiveTimeOut = cLongPushReceiveTimeOut;
   \   007A   A164           MOV       A,#100
   \   007C   9E....         MOV       TempoAlarmITForLongPushReceiveTimeOut,A
   1038          
   1039          #ifdef _DIAGNOSTIC_MEMO_    //For Diagnostic   
   1040          // Cm006427: SDO managed in LAP_DLK.
   1041          #if (!defined(X90_PROJECT) && !defined(COMPILATION_NATIVE))
   1042              //Remember various buttons can be pressed simultaneously
   1043              if((ButtonPushed & cDATRfShortPressButton1) == cDATRfShortPressButton1)   
   1044              {
   1045                  ArmerNbAlarmITForDiag(cDiagShortPressButton1);
   1046              }
   1047              else
   1048              {} //nothing to do
   1049              if((ButtonPushed & cDATRfShortPressButton2) == cDATRfShortPressButton2)     
   1050              {
   1051                  ArmerNbAlarmITForDiag(cDiagShortPressButton2);
   1052              }
   1053              else
   1054              {} //nothing to do
   1055              if((ButtonPushed & cDATRfShortPressButton3) == cDATRfShortPressButton3)     
   1056              {
   1057                  ArmerNbAlarmITForDiag(cDiagShortPressButton3);
   1058              }
   1059              else
   1060            {} //nothing to do
   1061          #endif
   1062          #endif
   1063          }
   \   007F   B2             POP       BC
   \   0080   AF             RET       
   \   0081                  REQUIRE ?CL78K_V4_6_L00
   1064          
   1065          //==============================================================================
   1066          //  DESCRIPTION : DATRfSiBlockReceivedAndLongPushWaitTimeElapsed
   1067          //  
   1068          //  PARAMETERS (Type,Name,Min,Max) :   none
   1069          //
   1070          //  RETURN VALUE :   none
   1071          // 
   1072          //  DESIGN INFORMATION :   refer to Detailed Design Document
   1073          //     
   1074          //==============================================================================

   \                                 In  segment CODE, align 1, keep-with-next
   1075          BOOL DATRfSiBlockReceivedAndLongPushWaitTimeElapsed(void)
   \                     DATRfSiBlockReceivedAndLongPushWaitTimeElapsed:
   1076          {
   \   0000                  ; * Stack frame (at entry) *
   \   0000                  ; Param size: 0
   \   0000   B5             PUSH      DE
   \   0001                  ; Total Auto size: 0
   1077          #ifdef X90_PROJECT
   1078              return DATRfSiBlockReceivedAndLongPushWaitTimeElapsed_Static();
   \   0001   16....         MOVW      HL,#LWRD(DATRfSiBlockReceivedAndLongPushWaitTimeElapsed_Static)
   \   0004   A4..           MOV       E,#BYTE3(DATRfSiBlockReceivedAndLongPushWaitTimeElapsed_Static)
   \   0006   ..             CALLT     [__T_?FAR_CALL_L07]
   \   0007   B4             POP       DE
   \   0008   AF             RET       
   \   0009                  REQUIRE ?CL78K_V4_6_L00
   1079          }
   1080          #pragma optimize=no_inline

   \                                 In  segment BCODE, align 1, keep-with-next
   1081          static MEM_TYPE BOOL DATRfSiBlockReceivedAndLongPushWaitTimeElapsed_Static(void)
   \                     DATRfSiBlockReceivedAndLongPushWaitTimeElapsed_Static:
   1082          {
   \   0000                  ; * Stack frame (at entry) *
   \   0000                  ; Param size: 0
   \   0000   B3             PUSH      BC
   \   0001                  ; Total Auto size: 4
   \   0001   B7             PUSH      HL
   \   0002   B7             PUSH      HL
   1083          #endif
   1084              BOOL  SIBlockReceivedIsOK;
   1085          #ifdef _PASSING_RF_
   1086          #else
   1087              U16   SI10BitsRCFrame;
   1088              tMot16Bit SI10BitsSIFrame;
   1089          #endif
   1090          #ifdef _TEST_RF_ //initialize SI frame emitted when testing RF hardware
   1091              U8 DataSIFrameEmitted[cNbBytesSIFrame] = mInitValueOfSIFrameEmitted();
   \   0003   891C           MOVW      AX,SP
   \   0005   80             INCW      AX
   \   0006   80             INCW      AX
   \   0007   D4             MOVW      DE,AX
   \   0008   16....         MOVW      HL,#`?<Constant {0, 1}>`
   \   000B   120200         MOVW      BC,#2
   \   000E   9A....         CALL      ?MOVE_LONG_L06
   1092              U8 NbByte;
   1093          #endif
   1094          
   1095              //Default value
   1096              SIBlockReceivedIsOK = cFalse;
   \   0011   A200           MOV       C,#0
   1097          
   1098          
   1099              if(SIFrameReceived == cTrue)
   \   0013   8E....         MOV       A,SIFrameReceived
   \   0016   51             DEC       A
   \   0017   AD03           BZ        $+5
   \   0019   9B....         BR        N:??DATRfArmerNbAlarmITForDiag_23
   1100              {
   1101                  SIFrameReceived = cFalse; //Received frame is consumed
   \   001C   A100           MOV       A,#0
   \   001E   9E....         MOV       SIFrameReceived,A
   1102          
   1103          #ifdef _PASSING_RF_
   1104                  SIBlockReceivedIsOK = cTrue; 
   1105          #else
   1106                  SI10BitsRCFrame
   1107                      = (U16)( (mDATReadTable (U32Bit, TableOfCurrentResynchroValue, IndiceKeyRf, Default) & (U16)0x03FF) ); 
   1108          
   1109                  SI10BitsSIFrame.Format8Bit.F8Bit2 =  DataSIFrameReceived[0] >> 6;
   \   0021   8E....         MOV       A,DataSIFrameReceived
   \   0024   24             ROR       A,0x1
   \   0025   25             RORC      A,0x1
   \   0026   25             RORC      A,0x1
   \   0027   25             RORC      A,0x1
   \   0028   25             RORC      A,0x1
   \   0029   25             RORC      A,0x1
   \   002A   5D03           AND       A,#3
   \   002C   73             MOV       B,A
   \   002D   891C           MOVW      AX,SP
   \   002F   80             INCW      AX
   \   0030   D6             MOVW      HL,AX
   \   0031   63             MOV       A,B
   \   0032   97             MOV       [HL],A
   1110                  SI10BitsSIFrame.Format8Bit.F8Bit1 = (DataSIFrameReceived[0] << 2) | (DataSIFrameReceived[1] & 0x03);
   \   0033   891C           MOVW      AX,SP
   \   0035   D6             MOVW      HL,AX
   \   0036   8E....         MOV       A,DataSIFrameReceived+1
   \   0039   5D03           AND       A,#3
   \   003B   70             MOV       X,A
   \   003C   8E....         MOV       A,DataSIFrameReceived
   \   003F   26             ROL       A,0x1
   \   0040   27             ROLC      A,0x1
   \   0041   5DFC           AND       A,#252
   \   0043   6168           OR        A,X
   \   0045   97             MOV       [HL],A
   1111          
   1112                  //Decides whether SI frame is accepted
   1113                  SIBlockReceivedIsOK = ( SI10BitsRCFrame == (SI10BitsSIFrame.Format16Bit & 0x03FF) ); 
   \   0046   70             MOV       X,A
   \   0047   AE01           MOV       A,[HL+0x01]
   \   0049   D4             MOVW      DE,AX
   \   004A   8E....         MOV       A,IndiceKeyRf
   \   004D   A004           MOV       X,#4
   \   004F   3188           MULU      X
   \   0051   CA....         ADDW      AX,#DATDbkMirrors+144
   \   0054   D6             MOVW      HL,AX
   \   0055   87             MOV       A,[HL]
   \   0056   70             MOV       X,A
   \   0057   AE01           MOV       A,[HL+0x01]
   \   0059   5D03           AND       A,#3
   \   005B   30             XCH       A,X
   \   005C   611C           SUB       A,E
   \   005E   30             XCH       A,X
   \   005F   613D           SUBC      A,D
   \   0061   6168           OR        A,X
   \   0063   BD02           BNZ       ??DATRfArmerNbAlarmITForDiag_24
   \   0065   A201           MOV       C,#1
   1114          #endif
   1115          
   1116          #ifdef _TEST_RF_ //update counters used for RF hardware testing   
   1117              for(NbByte = 0;
   \                     ??DATRfArmerNbAlarmITForDiag_24:
   \   0067   A000           MOV       X,#0
   \   0069   14....         MOVW      DE,#DataSIFrameReceived
   \   006C   D6             MOVW      HL,AX
   \   006D   891C           MOVW      AX,SP
   \   006F   80             INCW      AX
   \   0070   80             INCW      AX
   \   0071   E6             XCHW      AX,HL
   \                     ??DATRfSiBlockReceivedAndLongPushWaitTimeElapse_0:
   \   0072   87             MOV       A,[HL]
   \   0073   73             MOV       B,A
   \   0074   85             MOV       A,[DE]
   \   0075   614B           CMP       A,B
   \   0077   BD08           BNZ       ??DATRfArmerNbAlarmITForDiag_25
   1118                  ( (NbByte<cNbBytesSIFrame) && (DataSIFrameReceived[NbByte] == DataSIFrameEmitted[NbByte]) ); 
   1119                  NbByte++)
   \   0079   40             INC       X
   \   007A   60             MOV       A,X
   \   007B   86             INCW      HL
   \   007C   84             INCW      DE
   \   007D   4D02           CMP       A,#2
   \   007F   8DF1           BC        ??DATRfSiBlockReceivedAndLongPushWaitTimeElapse_0
   1120              {} //compare contents
   1121              if((NbByte == cNbBytesSIFrame) && (DATRfNbSIBlocksReceivedAndOK < cNbMaxStockedInByte))
   \                     ??DATRfArmerNbAlarmITForDiag_25:
   \   0081   60             MOV       A,X
   \   0082   4D02           CMP       A,#2
   \   0084   BD0B           BNZ       ??DATRfArmerNbAlarmITForDiag_26
   \   0086   8E....         MOV       A,DATRfNbSIBlocksReceivedAndOK
   \   0089   4DFF           CMP       A,#255
   \   008B   AD04           BZ        ??DATRfArmerNbAlarmITForDiag_26
   1122              {
   1123                  DATRfNbSIBlocksReceivedAndOK++;
   \   008D   41             INC       A
   \   008E   9E....         MOV       DATRfNbSIBlocksReceivedAndOK,A
   1124              }
   1125              else
   1126              {} //nothing to do
   1127          #endif
   1128          
   1129            }
   1130            else
   1131            { //No SI frame was received
   1132            }
   1133          
   1134              return (  (SIBlockReceivedIsOK == cTrue)  
   1135              //SI blocks are ignored until after cDATRfLongPushWaitTimeOut
   1136                     && (TempoAlarmITForLongPushWaitTimeOut == 0) 
   1137                     && (TempoAlarmITForLongPushReceiveTimeOut > 0)
   1138              //This condition is necessary to avoid the case in wish a WakeUpBlock followed
   1139              //by an SIblock is received: SIblock acccepted only if an RCblock has been received
   1140                     && (LongPushTimeOutIsActive == cTrue) 
   1141                     );
   \                     ??DATRfArmerNbAlarmITForDiag_26:
   \   0091   62             MOV       A,C
   \   0092   51             DEC       A
   \   0093   BD18           BNZ       ??DATRfArmerNbAlarmITForDiag_23
   \   0095   8E....         MOV       A,TempoAlarmITForLongPushWaitTimeOut
   \   0098   4D00           CMP       A,#0
   \   009A   BD11           BNZ       ??DATRfArmerNbAlarmITForDiag_23
   \   009C   8E....         MOV       A,TempoAlarmITForLongPushReceiveTimeOut
   \   009F   4D00           CMP       A,#0
   \   00A1   AD0A           BZ        ??DATRfArmerNbAlarmITForDiag_23
   \   00A3   8E....         MOV       A,LongPushTimeOutIsActive
   \   00A6   51             DEC       A
   \   00A7   BD04           BNZ       ??DATRfArmerNbAlarmITForDiag_23
   \   00A9   A101           MOV       A,#1
   \   00AB   FA02           BR        ??DATRfArmerNbAlarmITForDiag_27
   \                     ??DATRfArmerNbAlarmITForDiag_23:
   \   00AD   A100           MOV       A,#0
   \                     ??DATRfArmerNbAlarmITForDiag_27:
   \   00AF   B2             POP       BC
   \   00B0   B2             POP       BC
   \   00B1   B2             POP       BC
   \   00B2   AF             RET       
   \   00B3                  REQUIRE ?CL78K_V4_6_L00
   1142          }
   1143          
   1144          //==============================================================================
   1145          //  DESCRIPTION : DATRfLongPushDetected
   1146          //  
   1147          //  PARAMETERS (Type,Name,Min,Max) :   none
   1148          //
   1149          //  RETURN VALUE :   none
   1150          // 
   1151          //  DESIGN INFORMATION :   refer to Detailed Design Document
   1152          //     
   1153          //==============================================================================

   \                                 In  segment CODE, align 1, keep-with-next
   1154          void DATRfLongPushDetected(void)
   \                     DATRfLongPushDetected:
   1155          {
   \   0000                  ; * Stack frame (at entry) *
   \   0000                  ; Param size: 0
   \   0000   B5             PUSH      DE
   \   0001                  ; Total Auto size: 0
   1156          #ifdef X90_PROJECT
   1157              DATRfLongPushDetected_Static();
   \   0001   16....         MOVW      HL,#LWRD(DATRfLongPushDetected_Static)
   \   0004   A4..           MOV       E,#BYTE3(DATRfLongPushDetected_Static)
   \   0006   ..             CALLT     [__T_?FAR_CALL_L07]
   1158          }
   \   0007   B4             POP       DE
   \   0008   AF             RET       
   \   0009                  REQUIRE ?CL78K_V4_6_L00
   1159          #pragma optimize=no_inline

   \                                 In  segment BCODE, align 1, keep-with-next
   1160          static MEM_TYPE void DATRfLongPushDetected_Static(void)
   \                     DATRfLongPushDetected_Static:
   1161          {
   \   0000                  ; * Stack frame (at entry) *
   \   0000                  ; Param size: 0
   \   0000                  ; Total Auto size: 0
   1162          #endif
   1163              //Button long push is saved for LAP to read
   1164          #ifdef X90_PROJECT
   1165              ButtonPushed = 0; // no long pushes for X90
   \   0000   A100           MOV       A,#0
   \   0002   9E....         MOV       ButtonPushed,A
   1166              
   1167              //adzhelp:  NOPs added so that object file produced from rev. 1.15 to be identical with 1.16
   1168              NOP();
   \   0005   00             nop
   1169              NOP();
   \   0006   00             nop
   1170              NOP();
   \   0007   00             nop
   1171              NOP();
   \   0008   00             nop
   1172              NOP();
   \   0009   00             nop
   1173              NOP();
   \   000A   00             nop
   1174              NOP();
   \   000B   00             nop
   1175              NOP();
   \   000C   00             nop
   1176          #else
   1177              ButtonPushed = ((RCFrameCIDReceived << 4) & cMaskNonExistingButtons);
   1178          #endif
   1179          
   1180              // it's always true at this level
   1181              mLIBassert(LongPushTimeOutIsActive == cTrue);
   1182              // Force TimeOut to pass on to SearchFrame mode
   1183              // TempoAlarmITForLongPushReceiveTimeOut = 0;
   1184              // Stop Timeout for SI reception 
   1185              LongPushTimeOutIsActive = cFalse;
   \   000D   9E....         MOV       LongPushTimeOutIsActive,A
   1186          
   1187          #ifdef _DIAGNOSTIC_MEMO_    //For Diagnostic   
   1188              //Remember various buttons can be pressed simultaneously
   1189              if ( (ButtonPushed & cDATRfLongPressButton1) == cDATRfLongPressButton1)   
   \   0010   16....         MOVW      HL,#ButtonPushed
   \   0013   31C708         BF        [HL].4, ??DATRfArmerNbAlarmITForDiag_28
   1190              {
   1191                  ArmerNbAlarmITForDiag(cDiagLongPressButton1);
   \   0016   A101           MOV       A,#1
   \   0018   16....         MOVW      HL,#LWRD(ArmerNbAlarmITForDiag)
   \   001B   A4..           MOV       E,#BYTE3(ArmerNbAlarmITForDiag)
   \   001D   ..             CALLT     [__T_?FAR_FAST_CALL_L07]
   1192              }
   1193              if ( (ButtonPushed & cDATRfLongPressButton2) == cDATRfLongPressButton2)     
   \                     ??DATRfArmerNbAlarmITForDiag_28:
   \   001E   16....         MOVW      HL,#ButtonPushed
   \   0021   31D708         BF        [HL].5, ??DATRfArmerNbAlarmITForDiag_29
   1194              {
   1195                  ArmerNbAlarmITForDiag(cDiagLongPressButton2);
   \   0024   A108           MOV       A,#8
   \   0026   16....         MOVW      HL,#LWRD(ArmerNbAlarmITForDiag)
   \   0029   A4..           MOV       E,#BYTE3(ArmerNbAlarmITForDiag)
   \   002B   ..             CALLT     [__T_?FAR_FAST_CALL_L07]
   1196              }
   1197              if ( (ButtonPushed & cDATRfLongPressButton3) == cDATRfLongPressButton3)     
   \                     ??DATRfArmerNbAlarmITForDiag_29:
   \   002C   16....         MOVW      HL,#ButtonPushed
   \   002F   31E708         BF        [HL].6, ??DATRfArmerNbAlarmITForDiag_30
   1198              {
   1199                  ArmerNbAlarmITForDiag(cDiagLongPressButton3);
   \   0032   A180           MOV       A,#128
   \   0034   16....         MOVW      HL,#LWRD(ArmerNbAlarmITForDiag)
   \   0037   A4..           MOV       E,#BYTE3(ArmerNbAlarmITForDiag)
   \   0039   ..             CALLT     [__T_?FAR_FAST_CALL_L07]
   1200              }
   1201          #endif
   1202          }
   \                     ??DATRfArmerNbAlarmITForDiag_30:
   \   003A   AF             RET       
   \   003B                  REQUIRE ?CL78K_V4_6_L00
   1203          /* [GRAPH_FUNCTIONS_END] */
   1204          
   1205          
   1206          //==============================================================================
   1207          //  DESCRIPTION : DATRfReadButtonState
   1208          //  
   1209          //  PARAMETERS (Type,Name,Min,Max) :   none
   1210          //
   1211          //  RETURN VALUE :   Button State (on/off)
   1212          // 
   1213          //  DESIGN INFORMATION :   refer to Detailed Design Document
   1214          //     
   1215          //==============================================================================

   \                                 In  segment CODE, align 1, keep-with-next
   1216          BOOL DATRfReadButtonState(U8 Button)
   \                     DATRfReadButtonState:
   1217          {
   \   0000                  ; * Stack frame (at entry) *
   \   0000                  ; Param size: 0
   \   0000   B3             PUSH      BC
   \   0001                  ; Total Auto size: 0
   \   0001   70             MOV       X,A
   1218              BOOL  ButtonState;
   1219          
   1220              //Remember various buttons can be pressed at the same time
   1221              if ((ButtonPushed & Button) == Button)
   \   0002   8E....         MOV       A,ButtonPushed
   \   0005   6158           AND       A,X
   \   0007   6148           CMP       A,X
   \   0009   BD0D           BNZ       ??DATRfArmerNbAlarmITForDiag_47
   1222              {
   1223                  ButtonState = cButtonIsPushed;
   \   000B   60             MOV       A,X
   \   000C   A201           MOV       C,#1
   1224          
   1225                  //Reset buttons read
   1226                  ButtonPushed &= (U8)~Button;
   \   000E   7DFF           XOR       A,#255
   \   0010   58....         AND       A,ButtonPushed
   \   0013   9E....         MOV       ButtonPushed,A
   \   0016   FA02           BR        ??DATRfArmerNbAlarmITForDiag_48
   1227              }
   1228              else
   1229              {
   1230                  ButtonState = cNoPushedButton;
   \                     ??DATRfArmerNbAlarmITForDiag_47:
   \   0018   A200           MOV       C,#0
   1231              }
   1232           
   1233              return (ButtonState);
   \                     ??DATRfArmerNbAlarmITForDiag_48:
   \   001A   62             MOV       A,C
   \   001B   B2             POP       BC
   \   001C   AF             RET       
   \   001D                  REQUIRE ?CL78K_V4_6_L00
   1234          }
   1235          
   1236          //==============================================================================
   1237          //  DESCRIPTION : DATRfCallBackCtrl
   1238          //  
   1239          //  PARAMETERS (Type,Name,Min,Max) :   none
   1240          //
   1241          //  RETURN VALUE :   none
   1242          // 
   1243          //  DESIGN INFORMATION :   refer to Detailed Design Document
   1244          //     
   1245          //==============================================================================

   \                                 In  segment CODE, align 1, keep-with-next
   1246          void DATRfCallBackCtrl(tCtrl Ctrl)
   \                     DATRfCallBackCtrl:
   1247          {
   \   0000                  ; * Stack frame (at entry) *
   \   0000                  ; Param size: 0
   \   0000                  ; Total Auto size: 0
   1248              if (Ctrl == cLDBRfWakeUpReceived)
   \   0000   4D02           CMP       A,#2
   \   0002   BD11           BNZ       ??DATRfArmerNbAlarmITForDiag_49
   1249              {
   1250                  mLIBassert((RCReceptionTimeOutIsActive == cFalse) && (LongPushTimeOutIsActive == cFalse));
   1251                  WakeUpBlockReceived = cTrue;
   \   0004   A101           MOV       A,#1
   \   0006   9E....         MOV       WakeUpBlockReceived,A
   1252          #ifdef _TEST_RF_ //update counter used for RF hardware testing
   1253                  if(DATRfNbWakeUpBlocksReceived < cNbMaxStockedInByte)
   \   0009   8E....         MOV       A,DATRfNbWakeUpBlocksReceived
   \   000C   4DFF           CMP       A,#255
   \   000E   AD20           BZ        ??DATRfArmerNbAlarmITForDiag_50
   1254                  {
   1255                      DATRfNbWakeUpBlocksReceived++;
   \   0010   41             INC       A
   \   0011   9E....         MOV       DATRfNbWakeUpBlocksReceived,A
   \   0014   AF             RET       
   1256                  }
   1257          #endif
   1258              }
   1259              else if (Ctrl == cLDBRfControlSleepTick)
   \                     ??DATRfArmerNbAlarmITForDiag_49:
   \   0015   4D06           CMP       A,#6
   \   0017   BD06           BNZ       ??DATRfArmerNbAlarmITForDiag_51
   1260              {
   1261                  // GraphEngineTaskSleep is on 20 ms and LDBSleepTick is on 20 ms
   1262                  // so task needs to be activated directly by sleep system timer interrupt context
   1263                  //CCOV: ailievb: Sharing of sleep timer between RF adn Immo, can't be tested at unit test(covered)
   1264                  TOSActivateTask(cTOSTaskIdGraphEngineTaskSleep);
   \   0019   100400         MOVW      AX,#4
   \   001C   9B....         BR        N:TOSActivateTask
   1265              }
   1266              else if (Ctrl == cLDBRfDecrementTempoSearchFrame)
   \                     ??DATRfArmerNbAlarmITForDiag_51:
   \   001F   4D09           CMP       A,#9
   \   0021   BD08           BNZ       ??DATRfArmerNbAlarmITForDiag_52
   1267              {
   1268                  //CCOV: ailievb: synchronization with LDB sleep ticks, can't be tested at unit test(covered)
   1269                  mLIBassert(TempoSearchFramePeriod > 0);
   1270                  TempoSearchFramePeriod--;
   \   0023   8E....         MOV       A,TempoSearchFramePeriod
   \   0026   51             DEC       A
   \   0027   9E....         MOV       TempoSearchFramePeriod,A
   \   002A   AF             RET       
   1271                  // decrement tempo in order to synchronize with LDB sleep ticks with active peripheral clock
   1272              }
   1273              else  // Enable sleep mode, WakeUp frame not received
   1274              {
   1275                  mLIBassert(Ctrl == cLDBRfWakeUpNotReceived);
   1276                  SearchFrameInCourse = cFalse;
   \                     ??DATRfArmerNbAlarmITForDiag_52:
   \   002B   A100           MOV       A,#0
   \   002D   9E....         MOV       SearchFrameInCourse,A
   1277              }
   1278          }
   \                     ??DATRfArmerNbAlarmITForDiag_50:
   \   0030   AF             RET       
   \   0031                  REQUIRE ?CL78K_V4_6_L00
   1279          
   1280          //==============================================================================
   1281          //  DESCRIPTION : DATRfCallBackEndCtrl
   1282          //  
   1283          //  PARAMETERS (Type,Name,Min,Max) :   none
   1284          //
   1285          //  RETURN VALUE :   none
   1286          // 
   1287          //  DESIGN INFORMATION :   refer to Detailed Design Document
   1288          //     
   1289          //==============================================================================

   \                                 In  segment CODE, align 1, keep-with-next
   1290          void DATRfCallBackEndCtrl(tCtrl Ctrl, tStatus Status) 
   \                     DATRfCallBackEndCtrl:
   1291          {
   \   0000                  ; * Stack frame (at entry) *
   \   0000                  ; Param size: 0
   \   0000                  ; Total Auto size: 0
   1292              mLIBassert (Status == cLDBCorrect); //cLDBCorrect defined in ldb.h.
   1293          }
   \   0000   AF             RET       
   \   0001                  REQUIRE ?CL78K_V4_6_L00
   1294          
   1295          //==============================================================================
   1296          //  DESCRIPTION : DATRfInit
   1297          //  
   1298          //  PARAMETERS (Type,Name,Min,Max) :   none
   1299          //
   1300          //  RETURN VALUE :   none
   1301          // 
   1302          //  DESIGN INFORMATION : Function called at reset or StartRf
   1303          //     
   1304          //==============================================================================

   \                                 In  segment CODE, align 1, keep-with-next
   1305          void DATRfInit(void)
   \                     DATRfInit:
   1306          {
   \   0000                  ; * Stack frame (at entry) *
   \   0000                  ; Param size: 0
   \   0000   B5             PUSH      DE
   \   0001                  ; Total Auto size: 0
   1307          #ifdef X90_PROJECT
   1308              DATRfInit_Static();
   \   0001   16....         MOVW      HL,#LWRD(DATRfInit_Static)
   \   0004   A4..           MOV       E,#BYTE3(DATRfInit_Static)
   \   0006   ..             CALLT     [__T_?FAR_CALL_L07]
   1309          }
   \   0007   B4             POP       DE
   \   0008   AF             RET       
   \   0009                  REQUIRE ?CL78K_V4_6_L00
   1310          #pragma optimize=no_inline

   \                                 In  segment BCODE, align 1, keep-with-next
   1311          static MEM_TYPE void DATRfInit_Static(void)
   \                     DATRfInit_Static:
   1312          {
   \   0000                  ; * Stack frame (at entry) *
   \   0000                  ; Param size: 0
   \   0000   A100           MOV       A,#0
   \   0002   B3             PUSH      BC
   \   0003                  ; Total Auto size: 0
   1313          #endif
   1314              mLIBassert(cDATRfLDBSearchFramePeriodMs < cDATRfWakeUpBlockDuration);
   1315              mLIBassert((cDATRfLDBSearchFramePeriodMs % cDATCpuSleepGraphEnginePeriodMs) == 0);
   1316          
   1317              //Init variables
   1318              SearchFrameInCourse  = cFalse; //Flag positioned by LDBCallBack
   \   0003   9E....         MOV       SearchFrameInCourse,A
   1319              WakeUpBlockReceived  = cFalse; //Flag positioned by LDBCallBack
   \   0006   9E....         MOV       WakeUpBlockReceived,A
   1320              RCFrameReceived      = cFalse; //Flag positioned by LDBCallBack
   \   0009   9E....         MOV       RCFrameReceived,A
   1321              SIFrameReceived      = cFalse; //Flag positioned by LDBCallBack
   \   000C   9E....         MOV       SIFrameReceived,A
   1322          
   1323              TempoSearchFramePeriod = 0;
   \   000F   9E....         MOV       TempoSearchFramePeriod,A
   1324          
   1325              //Init RCReception "timer",SIWait "timer" and SIReception "timer"
   1326              mLIBassert((cDATRfRCReceptionTimeOut % cDATCpuSleepGraphEnginePeriodMs) == 0);
   1327              TempoAlarmITForRCReceptionTimeOut = cRCReceptionTimeOut;
   \   0012   A109           MOV       A,#9
   \   0014   9E....         MOV       TempoAlarmITForRCReceptionTimeOut,A
   1328          
   1329              mLIBassert((cDATRfLongPushWaitTimeOut % cDATCpuSleepGraphEnginePeriodMs) == 0);
   1330              TempoAlarmITForLongPushWaitTimeOut = cLongPushWaitTimeOut;
   \   0017   A132           MOV       A,#50
   \   0019   9E....         MOV       TempoAlarmITForLongPushWaitTimeOut,A
   1331          
   1332              mLIBassert((cDATRfLongPushReceiveTimeOut % cDATCpuSleepGraphEnginePeriodMs) == 0);
   1333              TempoAlarmITForLongPushReceiveTimeOut = cLongPushReceiveTimeOut;
   \   001C   A164           MOV       A,#100
   \   001E   9E....         MOV       TempoAlarmITForLongPushReceiveTimeOut,A
   1334          
   1335          #ifdef _PASSING_RF_
   1336              TempoAlarmITForPassingRf = cRCReceptionTimeOut;
   1337          #endif
   1338          
   1339              RCReceptionTimeOutIsActive = cFalse; //Flag, indicates if timer is active
   \   0021   A100           MOV       A,#0
   \   0023   9E....         MOV       RCReceptionTimeOutIsActive,A
   1340              LongPushTimeOutIsActive    = cFalse; //Flag, indicates if timer is active
   \   0026   9E....         MOV       LongPushTimeOutIsActive,A
   1341          
   1342              //Frames initialized to 0
   1343              mLIBmemset ((U8*)DataRCFrameReceived,0,cNbBytesRCFrame); 
   \   0029   10....         MOVW      AX,#DataRCFrameReceived
   \   002C   140B00         MOVW      DE,#11
   \   002F   120000         MOVW      BC,#0
   \   0032   9A....         CALL      memset
   1344          #ifdef _QAC_
   1345              { U8 i;
   1346                  for(i=0; i<cNbBytesSIFrame ; i++)
   1347                  {
   1348                      DataSIFrameReceived[0] = 0;
   1349                  }
   1350              }
   1351          #else
   1352              mLIBmemset ((U8*)DataSIFrameReceived,0,cNbBytesSIFrame); 
   \   0035   10....         MOVW      AX,#DataSIFrameReceived
   \   0038   140200         MOVW      DE,#2
   \   003B   120000         MOVW      BC,#0
   \   003E   9A....         CALL      memset
   1353          #endif
   1354              DATRfRCFrameIDEReceived = 0;
   \   0041   100000         MOVW      AX,#0
   \   0044   03....         MOVW      DATRfRCFrameIDEReceived+2,AX
   \   0047   03....         MOVW      DATRfRCFrameIDEReceived,AX
   1355              RCFrameSIReceived       = 0; 
   \   004A   03....         MOVW      RCFrameSIReceived,AX
   1356              RCFrameCIDReceived      = 0;
   \   004D   9E....         MOV       RCFrameCIDReceived,A
   1357          
   1358              SI28BitsLastRCFrameKnown = 0;
   \   0050   03....         MOVW      SI28BitsLastRCFrameKnown+2,AX
   \   0053   03....         MOVW      SI28BitsLastRCFrameKnown,AX
   1359              ButtonPushed = cNoPushedButton; 
   \   0056   9E....         MOV       ButtonPushed,A
   1360          
   1361          #ifdef _DIAGNOSTIC_MEMO_ //for Diagnostic   
   1362              {
   1363                  DATRfPushMemorized = cNoPushedButton;
   \   0059   9E....         MOV       DATRfPushMemorized,A
   1364                  mLIBmemset(TempoAlarmITForDiag,cDiagMemorizationTime,cNbCodeDiagMemorized);
   \   005C   10....         MOVW      AX,#TempoAlarmITForDiag
   \   005F   140800         MOVW      DE,#8
   \   0062   126400         MOVW      BC,#100
   \   0065   9A....         CALL      memset
   1365              }
   1366          #endif
   1367          #ifdef _TEST_RF_ //init counters used for RF hardware testing   
   1368              DATRfNbWakeUpBlocksReceived  = 0;
   \   0068   A100           MOV       A,#0
   \   006A   9E....         MOV       DATRfNbWakeUpBlocksReceived,A
   1369              DATRfNbRCBlocksReceived      = 0;
   \   006D   9E....         MOV       DATRfNbRCBlocksReceived,A
   1370              DATRfNbRCBlocksReceivedAndOK = 0;
   \   0070   9E....         MOV       DATRfNbRCBlocksReceivedAndOK,A
   1371              DATRfNbRCBlocksReceivedCrcOK = 0;
   \   0073   9E....         MOV       DATRfNbRCBlocksReceivedCrcOK,A
   1372              DATRfNbSIBlocksReceived      = 0;
   \   0076   9E....         MOV       DATRfNbSIBlocksReceived,A
   1373              DATRfNbSIBlocksReceivedAndOK = 0;
   \   0079   9E....         MOV       DATRfNbSIBlocksReceivedAndOK,A
   1374          #endif
   1375          }
   \   007C   B2             POP       BC
   \   007D   AF             RET       
   \   007E                  REQUIRE ?CL78K_V4_6_L00
   1376          
   1377          //==============================================================================
   1378          //  DESCRIPTION : DATRfStart
   1379          //  
   1380          //  PARAMETERS (Type,Name,Min,Max) :   none
   1381          //
   1382          //  RETURN VALUE :   none
   1383          // 
   1384          //  DESIGN INFORMATION :   refer to Detailed Design Document
   1385          //     
   1386          //==============================================================================

   \                                 In  segment CODE, align 1, keep-with-next
   1387          void DATRfStart(void)
   \                     DATRfStart:
   1388          {
   \   0000                  ; * Stack frame (at entry) *
   \   0000                  ; Param size: 0
   \   0000   B5             PUSH      DE
   \   0001                  ; Total Auto size: 0
   1389              DATRfInit();
   \   0001   16....         MOVW      HL,#LWRD(DATRfInit_Static)
   \   0004   A4..           MOV       E,#BYTE3(DATRfInit_Static)
   \   0006   ..             CALLT     [__T_?FAR_CALL_L07]
   1390              // Launch Rf graph
   1391              TOSSeqActivateGraph(cTOSSeqGraphIdDATRfReceptionManagement);
   \   0007   A12C           MOV       A,#44
   \   0009   ..             CALLT     [__T_TOSSeqActivateGraph]
   1392          }
   \   000A   B4             POP       DE
   \   000B   AF             RET       
   \   000C                  REQUIRE ?CL78K_V4_6_L00
   1393          
   1394          //==============================================================================
   1395          //  DESCRIPTION : DATRfStop
   1396          //  
   1397          //  PARAMETERS (Type,Name,Min,Max) :   none
   1398          //
   1399          //  RETURN VALUE :   none
   1400          // 
   1401          //  DESIGN INFORMATION :   refer to Detailed Design Document
   1402          //     
   1403          //==============================================================================

   \                                 In  segment CODE, align 1, keep-with-next
   1404          void DATRfStop(void)
   \                     DATRfStop:
   1405          {
   \   0000                  ; * Stack frame (at entry) *
   \   0000                  ; Param size: 0
   \   0000   A101           MOV       A,#1
   \   0002   B5             PUSH      DE
   \   0003                  ; Total Auto size: 0
   1406              // Stop LDBRf
   1407              LDBControl (cLDBChannelRf, cLDBRfStop);
   \   0003   16....         MOVW      HL,#LWRD(LDBRfControl)
   \   0006   A4..           MOV       E,#BYTE3(LDBRfControl)
   \   0008   ..             CALLT     [__T_?FAR_CALL_L07]
   1408              // Stop Rf graph
   1409              TOSSeqDeactivateGraph(cTOSSeqGraphIdDATRfReceptionManagement);
   \   0009   A12C           MOV       A,#44
   \   000B   ..             CALLT     [__T_TOSSeqDeactivateGraph]
   1410              //Force TimeOut to authorise sleep mode
   1411              LongPushTimeOutIsActive = cFalse;
   \   000C   A100           MOV       A,#0
   \   000E   9B....         BR        N:?Subroutine0
   \   0011                  REQUIRE ?CL78K_V4_6_L00
   1412          }
   1413          
   1414          //==============================================================================
   1415          //  DESCRIPTION : DATRfInitializeRFTest
   1416          //  
   1417          //  PARAMETERS (Type,Name,Min,Max) :   none
   1418          //
   1419          //  RETURN VALUE :   none
   1420          // 
   1421          //  DESIGN INFORMATION :   refer to Detailed Design Document
   1422          //     
   1423          //==============================================================================
   1424          #ifdef _TEST_RF_ //init counters used for RF hardware testing   

   \                                 In  segment CODE, align 1, keep-with-next
   1425          void DATRfInitializeRFTest(void) 
   \                     DATRfInitializeRFTest:
   1426          {
   \   0000                  ; * Stack frame (at entry) *
   \   0000                  ; Param size: 0
   \   0000                  ; Total Auto size: 0
   1427              DATRfNbWakeUpBlocksReceived  = 0;
   \   0000   A100           MOV       A,#0
   \   0002   9E....         MOV       DATRfNbWakeUpBlocksReceived,A
   1428              DATRfNbRCBlocksReceived      = 0;
   \   0005   9E....         MOV       DATRfNbRCBlocksReceived,A
   1429              DATRfNbRCBlocksReceivedAndOK = 0;
   \   0008   9E....         MOV       DATRfNbRCBlocksReceivedAndOK,A
   1430              DATRfNbRCBlocksReceivedCrcOK = 0;
   \   000B   9E....         MOV       DATRfNbRCBlocksReceivedCrcOK,A
   1431              DATRfNbSIBlocksReceived      = 0;
   \   000E   9E....         MOV       DATRfNbSIBlocksReceived,A
   1432              DATRfNbSIBlocksReceivedAndOK = 0;
   \   0011   9E....         MOV       DATRfNbSIBlocksReceivedAndOK,A
   1433          }
   \   0014   AF             RET       
   \   0015                  REQUIRE ?CL78K_V4_6_L00
   1434          #endif
   1435          
   1436          //==============================================================================
   1437          //  DESCRIPTION : DATRfIsAnybodyMaintainActiveState 
   1438          //  
   1439          //  PARAMETERS (Type,Name,Min,Max) :   none
   1440          //
   1441          //  RETURN VALUE :   none
   1442          // 
   1443          //  DESIGN INFORMATION :   refer to Detailed Design Document
   1444          //     
   1445          //==============================================================================

   \                                 In  segment CODE, align 1, keep-with-next
   1446          void DATRfIsAnybodyMaintainActiveSleepState(void)
   \                     DATRfIsAnybodyMaintainActiveSleepState:
   1447          {
   \   0000                  ; * Stack frame (at entry) *
   \   0000                  ; Param size: 0
   \   0000                  ; Total Auto size: 0
   1448              // Sleep not allowed as long as RF wakeUp search is in course
   1449              if (SearchFrameInCourse != cFalse)
   \   0000   8E....         MOV       A,SearchFrameInCourse
   \   0003   4D00           CMP       A,#0
   \   0005   AD04           BZ        ??DATRfArmerNbAlarmITForDiag_53
   1450              {
   1451                  TOSWriteSignal(cTOSSignalSomebodyMaintainActiveSleepState);
   \   0007   102800         MOVW      AX,#40
   \   000A   ..             CALLT     [__T_TOSWriteSignal]
   1452               }
   1453          }
   \                     ??DATRfArmerNbAlarmITForDiag_53:
   \   000B   AF             RET       
   \   000C                  REQUIRE ?CL78K_V4_6_L00
   1454          
   1455          //==============================================================================
   1456          //  DESCRIPTION : DATRfIsAnybodyMaintainActiveState 
   1457          //  
   1458          //  PARAMETERS (Type,Name,Min,Max) :   none
   1459          //
   1460          //  RETURN VALUE :   none
   1461          // 
   1462          //  DESIGN INFORMATION :   refer to Detailed Design Document
   1463          //     
   1464          //==============================================================================

   \                                 In  segment CODE, align 1, keep-with-next
   1465          void DATRfIsAnybodyMaintainActiveState(void)
   \                     DATRfIsAnybodyMaintainActiveState:
   1466          {
   \   0000                  ; * Stack frame (at entry) *
   \   0000                  ; Param size: 0
   \   0000                  ; Total Auto size: 0
   1467              // Sleep not allowed as long as we're waiting for posible SI blocks 
   1468              // or there are pending requests (not read by LAP)
   1469              if ((SearchFrameInCourse != cFalse)
   1470                  ||(ButtonPushed != cNoPushedButton)) 
   \   0000   8E....         MOV       A,SearchFrameInCourse
   \   0003   4D00           CMP       A,#0
   \   0005   BD07           BNZ       ??DATRfArmerNbAlarmITForDiag_54
   \   0007   8E....         MOV       A,ButtonPushed
   \   000A   4D00           CMP       A,#0
   \   000C   AD04           BZ        ??DATRfArmerNbAlarmITForDiag_55
   1471              {
   1472                  TOSWriteSignal (cTOSSignalSomebodyMaintainActiveState);
   \                     ??DATRfArmerNbAlarmITForDiag_54:
   \   000E   102900         MOVW      AX,#41
   \   0011   ..             CALLT     [__T_TOSWriteSignal]
   1473              }
   1474          }
   \                     ??DATRfArmerNbAlarmITForDiag_55:
   \   0012   AF             RET       
   \   0013                  REQUIRE ?CL78K_V4_6_L00
   1475          
   1476          
   1477          //==============================================================================
   1478          //  DESCRIPTION : DATRfArmerNbAlarmITForDiag 
   1479          //  
   1480          //  PARAMETERS (Type,Name,Min,Max) :   none
   1481          //
   1482          //  RETURN VALUE :   none
   1483          // 
   1484          //  DESIGN INFORMATION :  Cm006427: SDO managed in LAP_DLK.
   1485          //     
   1486          //==============================================================================
   1487          #ifdef _DIAGNOSTIC_MEMO_    //For Diagnostic

   \                                 In  segment BCODE, align 1, keep-with-next
   1488          MEM_TYPE void DATRfArmerNbAlarmITForDiag(U8 u8RfButtonCodeP)
   \                     DATRfArmerNbAlarmITForDiag:
   1489          {
   \   0000                  ; * Stack frame (at entry) *
   \   0000                  ; Param size: 0
   \   0000   B3             PUSH      BC
   \   0001                  ; Total Auto size: 0
   \   0001   73             MOV       B,A
   1490              ArmerNbAlarmITForDiag(u8RfButtonCodeP);           
   \   0002   8E....         MOV       A,DATRfPushMemorized
   \   0005   616B           OR        A,B
   \   0007   9E....         MOV       DATRfPushMemorized,A
   \   000A   A200           MOV       C,#0
   \   000C   14....         MOVW      DE,#TempoAlarmITForDiag
   \                     ??DATRfArmerNbAlarmITForDiag_31:
   \   000F   100100         MOVW      AX,#1
   \   0012   ..             CALLT     [__T_?I_LSH_L02]
   \   0013   D6             MOVW      HL,AX
   \   0014   63             MOV       A,B
   \   0015   A000           MOV       X,#0
   \   0017   611E           SUB       A,L
   \   0019   30             XCH       A,X
   \   001A   613F           SUBC      A,H
   \   001C   6168           OR        A,X
   \   001E   BD05           BNZ       ??DATRfArmerNbAlarmITForDiag_32
   \   0020   A164           MOV       A,#100
   \   0022   B5             PUSH      DE
   \   0023   B6             POP       HL
   \   0024   97             MOV       [HL],A
   \                     ??DATRfArmerNbAlarmITForDiag_32:
   \   0025   42             INC       C
   \   0026   62             MOV       A,C
   \   0027   B5             PUSH      DE
   \   0028   B6             POP       HL
   \   0029   86             INCW      HL
   \   002A   B7             PUSH      HL
   \   002B   B4             POP       DE
   \   002C   4D08           CMP       A,#8
   \   002E   8DDF           BC        ??DATRfArmerNbAlarmITForDiag_31
   1491          }
   \   0030   B2             POP       BC
   \   0031   AF             RET       
   \   0032                  REQUIRE ?CL78K_V4_6_L00

   \                                 In  segment CLTVEC, align 2
   \                     __T_?I_LSH_L02:
   \   0000   ....           DW       ?I_LSH_L02

   \                                 In  segment CLTVEC, align 2
   \                     __T_?FAR_FAST_CALL_L07:
   \   0000   ....           DW       ?FAR_FAST_CALL_L07

   \                                 In  segment CLTVEC, align 2
   \                     __T_?FAR_CALL_L07:
   \   0000   ....           DW       ?FAR_CALL_L07

   \                                 In  segment CLTVEC, align 2
   \                     __T_TOSSendControl:
   \   0000   ....           DW       TOSSendControl

   \                                 In  segment CLTVEC, align 2
   \                     __T_TOSSeqActivateGraph:
   \   0000   ....           DW       TOSSeqActivateGraph

   \                                 In  segment CLTVEC, align 2
   \                     __T_TOSSeqDeactivateGraph:
   \   0000   ....           DW       TOSSeqDeactivateGraph

   \                                 In  segment CLTVEC, align 2
   \                     __T_TOSWriteSignal:
   \   0000   ....           DW       TOSWriteSignal

   \                                 In  segment CLTVEC, align 2
   \                     __T_?FUNC_ENTER_L06:
   \   0000   ....           DW       ?FUNC_ENTER_L06

   \                                 In  segment CLTVEC, align 2
   \                     __T_?FUNC_DEALL_L06:
   \   0000   ....           DW       ?FUNC_DEALL_L06

   \                                 In  segment CLTVEC, align 2
   \                     __T_?FUNC_LEAVE_L06:
   \   0000   ....           DW       ?FUNC_LEAVE_L06

   \                                 In  segment CONST, align 1
   \                     `?<Constant {194, 240, 165, 194, 129, 179, 64, `:
   \   0000   C2F0A5C2       DB 194, 240, 165, 194, 129, 179, 64, 34, 90, 0, 95
   \          81B34022
   \          5A005F  

   \                                 In  segment CONST, align 1
   \                     `?<Constant {0, 1}>`:
   \   0000   0001           DB 0, 1
   1492          #endif
   1493          /* [EXPORTED_FUNCTIONS_END] */

   Segment part sizes:

     Function/Label                                 Bytes
     --------------                                 -----
     DATRfReceptionManagement                         24
     SearchFrameInCourse                               1
     WakeUpBlockReceived                               1
     RCFrameReceived                                   1
     SIFrameReceived                                   1
     RCReceptionTimeOutIsActive                        1
     LongPushTimeOutIsActive                           1
     ButtonPushed                                      1
     IndiceKeyRf                                       1
     DATRfRCFrameIDEReceived                           4
     RCFrameSIReceived                                 2
     RCFrameCIDReceived                                1
     DataRCFrameReceived                              11
     DataSIFrameReceived                               2
     SI28BitsLastRCFrameKnown                          4
     TempoSearchFramePeriod                            1
     TempoAlarmITForRCReceptionTimeOut
                                                       1
     TempoAlarmITForLongPushWaitTimeOut
                                                       1
     TempoAlarmITForLongPushReceiveTimeOut
                                                       1
     TempoAlarmITForDiag                               8
     DATRfPushMemorized                                1
     DATRfNbWakeUpBlocksReceived                       1
     DATRfNbRCBlocksReceived                           1
     DATRfNbRCBlocksReceivedAndOK                      1
     DATRfNbRCBlocksReceivedCrcOK                      1
     DATRfNbSIBlocksReceived                           1
     DATRfNbSIBlocksReceivedAndOK                      1
     DATRfRCFrameSRReceived                            4
     DATRfRxSpontTable                                 8
     ArmerNbAlarmITForDiag                            50
     CallBckReceptionRCFrame                          35
     ExtractDataFromRCFrameReceived                  342
     UpdateKeyResynchronisation                       32
     ReBuildSI28Bits                                 175
     BuildingSI28BitsTheoric                          49
     CalculRollingCodeTheoreticRCFrame
                                                     449
     CallBckReceptionSIFrame                          35
     RfPeriodicTask                                   87
     DATRfWakeUpBlockReceived                         44
     DATRfArmRCReceptionTimer                         24
     DATRfNewRcBlockReceived                           9
     DATRfNewRcBlockReceived_Static                  841
     DATRfRCReceptionTimeElapsedOrLongPushReceiveTimeElapsed
                                                      34
     DATRfSearchWakeUpBlock                           17
     ?Subroutine0                                      5
     DATRfShortPushDetectedAndArmLongPushTimer
                                                       9
     DATRfShortPushDetectedAndArmLongPushTimer_Static
                                                     129
     DATRfSiBlockReceivedAndLongPushWaitTimeElapsed
                                                       9
     DATRfSiBlockReceivedAndLongPushWaitTimeElapsed_Static
                                                     179
     DATRfLongPushDetected                             9
     DATRfLongPushDetected_Static                     59
     DATRfReadButtonState                             29
     DATRfCallBackCtrl                                49
     DATRfCallBackEndCtrl                              1
     DATRfInit                                         9
     DATRfInit_Static                                126
     DATRfStart                                       12
     DATRfStop                                        17
     DATRfInitializeRFTest                            21
     DATRfIsAnybodyMaintainActiveSleepState
                                                      12
     DATRfIsAnybodyMaintainActiveState
                                                      19
     DATRfArmerNbAlarmITForDiag                       50
     __T_?I_LSH_L02                                    2
     __T_?FAR_FAST_CALL_L07                            2
     __T_?FAR_CALL_L07                                 2
     __T_TOSSendControl                                2
     __T_TOSSeqActivateGraph                           2
     __T_TOSSeqDeactivateGraph                         2
     __T_TOSWriteSignal                                2
     __T_?FUNC_ENTER_L06                               2
     __T_?FUNC_DEALL_L06                               2
     __T_?FUNC_LEAVE_L06                               2
     ?<Constant {194, 240, 165, 194, 129, 179, 64,    11
     ?<Constant {0, 1}>                                2

 
 2 449 bytes in segment BCODE
    20 bytes in segment CLTVEC
   518 bytes in segment CODE
    45 bytes in segment CONST
    55 bytes in segment NEAR_Z
 
 2 967 bytes of CODE  memory (+ 20 bytes shared)
    45 bytes of CONST memory
    55 bytes of DATA  memory

Errors: none
Warnings: none
