###############################################################################
#                                                                             #
# IAR C/C++ Compiler V4.61A/W32 for 78K0 and 78K0S      15/Feb/2011  13:26:19 #
# Copyright 1992-2008 IAR Systems AB.                                         #
#                                                                             #
#    Core         =  78k0                                                     #
#    Code model   =  Standard                                                 #
#                 =                                                           #
#    Source file  =  D:\X90_BCM\DEVELOPMENT\X90_BCM\K0\L7\BUILD\SOURCES\DAT\D #
#                    AT_EEP.C                                                 #
#    Command line =  --code_model standard --core 78k0 -e                     #
#                    -DMEM_TYPE=__banked -DMEM_FAST=__saddr                   #
#                    -DCALLT_TYPE=__callt -DX90_PROJECT                       #
#                    --generate_callt_runtime_library_calls -Ohs              #
#                    "-IC:\Program Files\IAR Systems\Embedded Workbench       #
#                    5.0\78k\inc" "-IC:\Program Files\IAR Systems\Embedded    #
#                    Workbench 5.0\78k\inc\clib" -I. -I..\EXE\GEN\            #
#                    -I..\SOURCES\DAT -I..\SOURCES\LAP -I..\SOURCES\LDB_API   #
#                    -I..\SOURCES\LIB -I..\SOURCES\TOS -I.\LDB -DROM          #
#                    -DUSE_LIBSTK -DDONT_KEEP_OLD_TYPE_COMPATIBILITY -l       #
#                    ..\EXE\TARGET_R\DAT_EEP.LST -o                           #
#                    ..\EXE\TARGET_R\DAT_EEP.R26                              #
#                    D:\X90_BCM\DEVELOPMENT\X90_BCM\K0\L7\BUILD\SOURCES\DAT\D #
#                    AT_EEP.C                                                 #
#    List file    =  ..\EXE\TARGET_R\DAT_EEP.LST                              #
#    Object file  =  ..\EXE\TARGET_R\DAT_EEP.R26                              #
#                                                                             #
#                                                                             #
###############################################################################

D:\X90_BCM\DEVELOPMENT\X90_BCM\K0\L7\BUILD\SOURCES\DAT\DAT_EEP.C
      1          //******************************************************************************
      2          // Company:      Johnson Controls Inc.
      3          // -----------------------------------------------------------------------------
      4          // Copyright:    This software is JCI property.
      5          //               Duplication or disclosure without JCI written authorization
      6          //               is prohibited.
      7          // -----------------------------------------------------------------------------
      8          // Project:      SW0032
      9          // Language:     ANSI-C
     10          // -----------------------------------------------------------------------------
     11          // Component:    This component manages the sharing of the access to the EEPROM
     12          //               from several processes.
     13          // -----------------------------------------------------------------------------
     14          // QACJ - (0288): Specific comment characters needed for PVCS compatibility
     15          // $Date:   04 Feb 2009 17:02:50  $
     16          // $Archive:   J:/_PVCSRoot/Renault/X90_BCM/SOFTWARE/PVCS/archives/DEVELOPMENT/EXT_CMP/CPP_CMP/STK/SOURCES/DAT_EEP.C-arc  $
     17          // $Revision:   1.0  $
     18          // -----------------------------------------------------------------------------
     19          // QACJ - (2017): Comment style needed for our toolkit
     20          /* $Log:   J:/_PVCSRoot/Renault/X90_BCM/SOFTWARE/PVCS/archives/DEVELOPMENT/EXT_CMP/CPP_CMP/STK/SOURCES/DAT_EEP.C-arc  $
     21          // 
     22          //    Rev 1.0   04 Feb 2009 17:02:50   adzhelp
     23          // Initial revision.
     24          */
     25          //******************************************************************************
     26          
     27          //------------------------------------------------------------------------------
     28          // Body Identification
     29          //------------------------------------------------------------------------------
     30          #define DAT_EEP  "DAT_EEP"
     31          
     32          //------------------------------------------------------------------------------
     33          // Included files to resolve specific definitions in this file
     34          //
     35          // #include <system_file_name.h>
     36          // #include "project_file_name.h"
     37          //------------------------------------------------------------------------------
     38          #include "LIB.h"
     39          #include "TOS.h"
     40          #include "LDB.h"
     41          #ifdef _QAC_
     42          #include "DAT.h"
     43          #endif
     44          #include "DAT_EEP.h"
     45          
     46          //------------------------------------------------------------------------------
     47          // Local constants
     48          //
     49          // #define cConstantName   ((tType) ConstantValue)
     50          //------------------------------------------------------------------------------
     51          
     52          #define cInvalidProcessHandle ((tDATEepProcessHandle) 0xFFU)
     53          
     54          //------------------------------------------------------------------------------
     55          // Local macros
     56          //
     57          // #define mMacroName   (MacroDefinition)
     58          //------------------------------------------------------------------------------
     59          #define mConvAdress16ToAdr8( Adr16 ) (tAddress)((Adr16) << 1U)
     60          
     61          
     62          #if ((cDATEepPageSize > 2) && ((cDATEepPageSize % 2) == 0))
     63          
     64          #define mIsDataIdentical(pSourceData, pReadData, lng) \
     65                          (mLIBmemcmp((pReadData), (pSourceData), lng) == 0)
     66          
     67          #define mGetTransferSize(address) GetMaxBurstTransferSize(address)
     68          #define DAT_EEP_BURST_MODE_ACTIVE
     69          
     70          #elif (cDATEepPageSize == 2)
     71          
     72          #define mIsDataIdentical(pSourceData, pReadData, lng) \
     73                          ((pReadData)[0] == (pSourceData)[0]) 
     74          
     75          #define mGetTransferSize(address)    ((LDBPARAM_TYPE_LNGMSG)2)
     76          
     77          #else
     78          
     79          #error "cDATEepPageSize: incorrect value. 2 is min value.\
     80              For the max value check the EEPROM specification!.\
     81              The value must be devisable by 2"
     82          
     83          #endif
     84          
     85          
     86          #ifdef TOSSuspendAllInterupts
     87            #define  mSuspendIT()\
     88            TOSSuspendAllInterupts() // Ancienne version de TOS_ORD (TOS.h Rev 1.12)
     89          #else
     90            #define  mSuspendIT()\
     91            TOSSuspendOSInterrupts() // Nouvelle version de TOS_ORD (TOS.h Rev 1.13)
     92          #endif
     93          
     94          #ifdef TOSResumeAllInterupts
     95            #define  mResumeIT()\
     96            TOSResumeAllInterupts() // Ancienne version de TOS_ORD (TOS.h Rev 1.12)
     97          #else
     98            #define  mResumeIT()\
     99            TOSResumeOSInterrupts() // Nouvelle version de TOS_ORD (TOS.h Rev 1.13)
    100          #endif
    101          
    102          #ifdef TOSDisableOSInterrupts
    103            #define mDisableIT()\
    104            TOSDisableOSInterrupts() // Nouvelle version de TOS_ORD (TOS.h Rev 1.13)
    105          #else
    106            #define mDisableIT()\
    107            TOSDisableAllInterupts() // Ancienne version de TOS_ORD (TOS.h Rev 1.12)
    108          #endif
    109          
    110          #ifdef TOSEnableOSInterrupts
    111            #define mEnableIT()\
    112            TOSEnableOSInterrupts() // Nouvelle version de TOS_ORD (TOS.h Rev 1.13)
    113          #else
    114            #define mEnableIT()\
    115            TOSEnableAllInterupts() // Ancienne version de TOS_ORD (TOS.h Rev 1.12)
    116          #endif
    117          //------------------------------------------------------------------------------
    118          // Local types
    119          //
    120          // typedef Expression   tTypeName;
    121          //------------------------------------------------------------------------------
    122          
    123          // States of main machine
    124          typedef enum
    125          {
    126              cStateReady,
    127              cStateReading,
    128              cStateComparing,
    129              cStateUnLocking,
    130              cStateChecking,
    131              cStateWriting,
    132              cStateLocking,
    133              cStateUnprotecting
    134          } tState;
    135          
    136          
    137          // Paramaters of Command machine
    138          typedef enum
    139          {
    140              cCmdRead,
    141              cCmdWrite,
    142              cCmdLock,
    143              cCmdUnlock,
    144              cCmdUnprotect
    145          } tCommandType;
    146          
    147          typedef struct
    148          {
    149              tMsg         Msg;
    150              U16          Adress;
    151              tCommandType Type;
    152          } tCommand;
    153          
    154          // States of command machine
    155          typedef enum
    156          {
    157              cCommandStateFree,
    158              cCommandStateFrozen,
    159              cCommandStateProcessing,
    160              cCommandStateFinished
    161          } tCommandState;
    162          
    163          #if cDATEepExtendedNumberOfProcess <= 8U
    164          typedef U8 tActiveProcessList;
    165          #else
    166              #if cDATEepExtendedNumberOfProcess <= 16U
    167          typedef U16 tActiveProcessList;
    168              #else
    169                  #if cDATEepExtendedNumberOfProcess <= 32U
    170          typedef U32 tActiveProcessList;
    171                  #else
    172                      #error "Too many processes"
    173                  #endif
    174              #endif
    175          #endif
    176          
    177          // -----------------------------------------------------------------------------
    178          // Local data
    179          //
    180          // static  tType   u8VariableName;  
    181          // static  tType*  pu8VariableName; 
    182          //------------------------------------------------------------------------------
    183          
    184          // Process schedule

   \                                 In  segment NEAR_Z, align 1, align-sorted
    185          static tDATEepProcessHandle ActiveProcessHandle;
   \                     ActiveProcessHandle:
   \   0000                  DS 1
   \   0001                  REQUIRE __INIT_NEAR_Z

   \                                 In  segment NEAR_Z, align 2, align-sorted
    186          static tActiveProcessList   ActiveProcessList;
   \                     ActiveProcessList:
   \   0000                  DS 2
   \   0002                  REQUIRE __INIT_NEAR_Z
    187          
    188          // Main state machine

   \                                 In  segment NEAR_Z, align 1, align-sorted
    189          static tState        State;
   \                     State:
   \   0000                  DS 1
   \   0001                  REQUIRE __INIT_NEAR_Z

   \                                 In  segment NEAR_Z, align 1, align-sorted
    190          static U8            WriteRetryCounter;
   \                     WriteRetryCounter:
   \   0000                  DS 1
   \   0001                  REQUIRE __INIT_NEAR_Z

   \                                 In  segment NEAR_Z, align 2, align-sorted
    191          static U16			 ReadBuffer[cDATEepPageSize / 2];
   \                     ReadBuffer:
   \   0000                  DS 2
   \   0002                  REQUIRE __INIT_NEAR_Z

   \                                 In  segment NEAR_Z, align 2, align-sorted
    192          static U16*          UserBuffer;
   \                     UserBuffer:
   \   0000                  DS 2
   \   0002                  REQUIRE __INIT_NEAR_Z

   \                                 In  segment NEAR_Z, align 1, align-sorted
    193          static tDATEepOffset OffsetFromUserBuffer;
   \                     OffsetFromUserBuffer:
   \   0000                  DS 1
   \   0001                  REQUIRE __INIT_NEAR_Z

   \                                 In  segment NEAR_Z, align 1, align-sorted
    194          static tDATEepOffset LastOffset;
   \                     LastOffset:
   \   0000                  DS 1
   \   0001                  REQUIRE __INIT_NEAR_Z
    195          
    196          // Command state machine

   \                                 In  segment NEAR_Z, align 1, align-sorted
    197          static volatile tCommandState  CommandState;
   \                     CommandState:
   \   0000                  DS 1
   \   0001                  REQUIRE __INIT_NEAR_Z

   \                                 In  segment NEAR_Z, align 2, align-sorted
    198          static tCommand             Command;
   \                     Command:
   \   0000                  DS 8
   \   0008                  REQUIRE __INIT_NEAR_Z

   \                                 In  segment NEAR_Z, align 2, align-sorted
    199          static tTOSTimer            CommandTempo;
   \                     CommandTempo:
   \   0000                  DS 2
   \   0002                  REQUIRE __INIT_NEAR_Z

   \                                 In  segment NEAR_Z, align 2, align-sorted
    200          static tTOSAlarm            Alarm;
   \                     Alarm:
   \   0000                  DS 4
   \   0004                  REQUIRE __INIT_NEAR_Z
    201          
    202          
    203          
    204          //------------------------------------------------------------------------------
    205          // Constant local data
    206          //
    207          // static const tType  VariableName;
    208          //------------------------------------------------------------------------------
    209          

   \                                 In  segment CONST, align 2
    210          static const tDATEepBloc BlocList[cDATEepExtendedNumberOfProcess ] =
   \                     BlocList:
   \   0000   0000           DW 0
   \   0002   0600           DB 6, 0
   \   0004   0600           DW 6
   \   0006   0E00           DB 14, 0
   \   0008   2E00           DW 46
   \   000A   0200           DB 2, 0
   \   000C   6000           DW 96
   \   000E   0B00           DB 11, 0
   \   0010   FD00           DW 253
   \   0012   0200           DB 2, 0
   \   0014   1400           DW 20
   \   0016   1A01           DB 26, 1
   \   0018   3000           DW 48
   \   001A   0801           DB 8, 1
   \   001C   3800           DW 56
   \   001E   2801           DB 40, 1
   \   0020   6B00           DW 107
   \   0022   4E01           DB 78, 1
   \   0024   B900           DW 185
   \   0026   4401           DB 68, 1
   \   0028   0000           DW 0
   \   002A   0002           DB 0, 2
    211              { mDATEepProcessInformationTable() };
    212          
    213          //QACJ 3218: Coding rule mismatch with static scopes.

   \                                 In  segment CONST, align 2
    214          static const tpfCallBack CallBackList[cDATEepExtendedNumberOfCallBack] = 
   \                     CallBackList:
   \   0000   ........       DW DATSbkCallBackEep, DATDbkCallBackEep, DATDeaCallBackEep
   \          ....    
    215          	{ mDATEepExtendedCallBackList() };
    216          //------------------------------------------------------------------------------
    217          // Exported data
    218          //
    219          // tType   u8LAYCmpVariableName; (LAY: 3 characters to identify the layer)
    220          // tType*  pu8LAYCmpVariableName;(Cmp: 3 characters to identify the component)
    221          //------------------------------------------------------------------------------
    222          

   \                                 In  segment NEAR_Z, align 2, align-sorted
    223          U16 DATEepBuffer[cDATEepBufferSize];
   \                     DATEepBuffer:
   \   0000                  DS 78
   \   004E                  REQUIRE __INIT_NEAR_Z
    224          
    225          //------------------------------------------------------------------------------
    226          // Constant exported data
    227          //
    228          //             (LAY: 3 characters to identify the layer)
    229          //             (Cmp: 3 characters to identify this component)
    230          // 
    231          // const tType   LAYCmpVariableName;
    232          //------------------------------------------------------------------------------
    233          
    234          //------------------------------------------------------------------------------
    235          // Local function prototypes
    236          // 
    237          // static tTypeRetour FunctionName(tTypeArgument1 ArgumentName1, ... );
    238          //------------------------------------------------------------------------------
    239          
    240          //==============================================================================
    241          //=========================== LOCAL FUNCTIONS ==================================
    242          //==============================================================================
    243          
    244          //==============================================================================
    245          // DESCRIPTION : Calls the callback function of the active process
    246          //
    247          // PARAMETERS (Type,Name,Min,Max) : 
    248          //    BOOL StatusOk: cTrue if the last operation is a success, cFalse otherwise.
    249          //
    250          // RETURN VALUE :   none
    251          //
    252          // DESIGN INFORMATION : 
    253          //==============================================================================
    254          static void CallUser(BOOL StatusOk)
    255          {
    256              U8 CallBackIndex;
    257          
    258              mLIBassert( ActiveProcessHandle < cDATEepExtendedNumberOfProcess );
    259              CallBackIndex = BlocList[ActiveProcessHandle].CallBackNumber;
    260          
    261              mLIBassert( CallBackIndex < cDATEepExtendedNumberOfCallBack );
    262              CallBackList[CallBackIndex]( ActiveProcessHandle, StatusOk );
    263          }
    264          
    265          
    266          //==============================================================================
    267          // DESCRIPTION : Translate the contents of the Command variable into LDB call
    268          //
    269          // PARAMETERS (Type,Name,Min,Max) :   none
    270          //
    271          // RETURN VALUE :   none
    272          //
    273          // DESIGN INFORMATION : 
    274          //==============================================================================
    275          static void SendCommand( void )
    276          {
    277              mLIBassert( CommandState == cCommandStateProcessing );
    278          
    279              TOSStartTimer( &CommandTempo );
    280          
    281              switch( Command.Type )
    282              {
    283              case( cCmdRead ) :
    284                  // This is a read command
    285                  LDBReceiveWithAddr( cLDBChannelEep, mConvAdress16ToAdr8(Command.Adress), &Command.Msg );
    286                  break;
    287          
    288              case( cCmdWrite ) :
    289                  // This is a write command
    290                  LDBSendWithAddr( cLDBChannelEep, mConvAdress16ToAdr8(Command.Adress), &Command.Msg );
    291                  break;
    292          
    293              case( cCmdLock ) :
    294                  // This is a lock command
    295                  LDBControl(cLDBChannelEep, cLDBEepLock );
    296                  break;
    297          
    298              case( cCmdUnlock ) :
    299                  // This is an unlock command
    300                  LDBControl(cLDBChannelEep, cLDBEepUnLock );
    301                  break;
    302          
    303          #ifdef cLIBStkUnprotect_Used
    304              case( cCmdUnprotect ) :
    305                  // This is an unprotect command
    306                  LDBControl(cLDBChannelEep, cLDBEepUnprotect );
    307                  break;
    308          #endif // cLIBStkUnprotect_Used
    309          
    310              default:
    311                  
    312                  mLIBassert(cFalse);
    313                  break;
    314              }
    315          }
    316          
    317          //==============================================================================
    318          // DESCRIPTION : Send the LDB command that is prepared in the Command variable
    319          //
    320          // PARAMETERS (Type,Name,Min,Max) :   none
    321          //
    322          // RETURN VALUE :   none
    323          //
    324          // DESIGN INFORMATION : 
    325          //==============================================================================

   \                                 In  segment CODE, align 1, keep-with-next
    326          static void StartCommand( void )
   \                     StartCommand:
    327          {
   \   0000                  ; * Stack frame (at entry) *
   \   0000                  ; Param size: 0
   \   0000   B3             PUSH      BC
   \   0001   B5             PUSH      DE
   \   0002                  ; Total Auto size: 0
    328              BOOL IsAccessible;
    329          
    330              mLIBassert( CommandState == cCommandStateFree );
    331          
    332              if( Command.Type == cCmdRead )
   \   0002   8E....         MOV       A,Command+6
   \   0005   4D00           CMP       A,#0
   \   0007   BD30           BNZ       ??DATEepIsProcessing_0
    333              {
    334                  // The Command state machine enter in the processing state
    335                  CommandState = cCommandStateProcessing;
   \                     ??StartCommand_0:
   \   0009   A102           MOV       A,#2
   \   000B   9E....         MOV       CommandState,A
    336                  SendCommand();
   \   000E   10....         MOVW      AX,#CommandTempo
   \   0011   ..             CALLT     [__T_TOSStartTimer]
   \   0012   8E....         MOV       A,Command+6
   \   0015   4D00           CMP       A,#0
   \   0017   AD0E           BZ        ??DATEepIsProcessing_1
   \   0019   4D01           CMP       A,#1
   \   001B   AD2A           BZ        ??DATEepIsProcessing_2
   \   001D   4D02           CMP       A,#2
   \   001F   AD38           BZ        ??DATEepIsProcessing_3
   \   0021   4D03           CMP       A,#3
   \   0023   AD3E           BZ        ??DATEepIsProcessing_4
   \   0025   FA1D           BR        ??DATEepIsProcessing_5
   \                     ??DATEepIsProcessing_1:
   \   0027   12....         MOVW      BC,#Command
   \   002A   02....         MOVW      AX,Command+4
   \   002D   30             XCH       A,X
   \   002E   27             ROLC      A,0x1
   \   002F   30             XCH       A,X
   \   0030   27             ROLC      A,0x1
   \   0031   16....         MOVW      HL,#LWRD(LDBEepReceiveWithAddr)
   \   0034   A4..           MOV       E,#BYTE3(LDBEepReceiveWithAddr)
   \                     ??StartCommand_1:
   \   0036   ..             CALLT     [__T_?FAR_CALL_L07]
   \   0037   FA0B           BR        ??DATEepIsProcessing_5
    337              }
    338              else
    339              {
    340                  // For all commands exclude Read we must
    341                  // check if the EEPROM is accesible
    342                  IsAccessible = DATPeeIsEepromAccessible();
    343          
    344                  if( IsAccessible == cTrue )
   \                     ??DATEepIsProcessing_0:
   \   0039   9A....         CALL      DATPeeIsEepromAccessible
   \   003C   51             DEC       A
   \   003D   ADCA           BZ        ??StartCommand_0
    345                  {
    346                      // The Command state machine enter in the processing state
    347                      CommandState = cCommandStateProcessing;
    348                      SendCommand();
    349                  }
    350                  else
    351                  {
    352                      // The Command state machine enter in the frozen state
    353                      CommandState = cCommandStateFrozen;
   \   003F   A101           MOV       A,#1
   \   0041   9E....         MOV       CommandState,A
    354                  }
    355              }
    356          }
   \                     ??DATEepIsProcessing_5:
   \   0044   B4             POP       DE
   \   0045   B2             POP       BC
   \   0046   AF             RET       
   \                     ??DATEepIsProcessing_2:
   \   0047   12....         MOVW      BC,#Command
   \   004A   02....         MOVW      AX,Command+4
   \   004D   21             CLR1      CY
   \   004E   30             XCH       A,X
   \   004F   27             ROLC      A,0x1
   \   0050   30             XCH       A,X
   \   0051   27             ROLC      A,0x1
   \   0052   16....         MOVW      HL,#LWRD(LDBEepSendWithAddr)
   \   0055   A4..           MOV       E,#BYTE3(LDBEepSendWithAddr)
   \   0057   FADD           BR        ??StartCommand_1
   \                     ??DATEepIsProcessing_3:
   \   0059   A100           MOV       A,#0
   \                     ??StartCommand_2:
   \   005B   16....         MOVW      HL,#LWRD(LDBEepControl)
   \   005E   A4..           MOV       E,#BYTE3(LDBEepControl)
   \   0060   ..             CALLT     [__T_?FAR_CALL_L07]
   \   0061   FAE1           BR        ??DATEepIsProcessing_5
   \                     ??DATEepIsProcessing_4:
   \   0063   A101           MOV       A,#1
   \   0065   FAF4           BR        ??StartCommand_2
   \   0067                  REQUIRE ?CL78K_V4_6_L00
    357          #ifdef DAT_EEP_BURST_MODE_ACTIVE
    358          //==============================================================================
    359          // DESCRIPTION : Calculate number of bytes that could be written (read) with 
    360          // single LDB call.
    361          //
    362          // PARAMETERS (Type,Name,Min,Max) :   Start address (in words)
    363          //
    364          // RETURN VALUE :   Number of bytes that could be fit in EEPROM page starting
    365          // from u16Addr.
    366          //
    367          // DESIGN INFORMATION : 
    368          //==============================================================================
    369          static LDBPARAM_TYPE_LNGMSG GetMaxBurstTransferSize(U16 u16Addr)
    370          {
    371              LDBPARAM_TYPE_LNGMSG result;
    372          
    373              U16 u16Address = (U16)(u16Addr * 2);
    374              U16 u16Size = (U16)((LastOffset - OffsetFromUserBuffer) * 2);
    375          
    376              // Physical EEPROM could read pages aligned on cDATEepPageSize boundaries
    377              // If the size exceed cDATEepPageSize data from the begining of the page
    378              // would be read instead data byte from address cDATEepPageSize+1.
    379              U16 u16DataOffset = (U16)(u16Address % cDATEepPageSize);
    380              
    381              if ((u16DataOffset + u16Size) > cDATEepPageSize)
    382              {
    383                  result = (LDBPARAM_TYPE_LNGMSG)(cDATEepPageSize - u16DataOffset);
    384              }
    385              else
    386              {
    387                  result = ((LDBPARAM_TYPE_LNGMSG)u16Size);
    388              }
    389          
    390              return result;
    391          }
    392          #endif
    393          //==============================================================================
    394          // DESCRIPTION : Update the component when a LDB command is complete.
    395          //
    396          // PARAMETERS (Type,Name,Min,Max) :   none
    397          //
    398          // RETURN VALUE :   none
    399          //
    400          // DESIGN INFORMATION : 
    401          //==============================================================================

   \                                 In  segment CODE, align 1, keep-with-next
    402          static void EndOfCommand( void )
   \                     EndOfCommand:
    403          {
   \   0000                  ; * Stack frame (at entry) *
   \   0000                  ; Param size: 0
   \   0000   B3             PUSH      BC
   \   0001                  ; Total Auto size: 0
    404              tDATEepOffset  ReadDataLng;
    405          
    406              switch( State )
   \   0001   8E....         MOV       A,State
   \   0004   4D01           CMP       A,#1
   \   0006   AD23           BZ        ??DATEepIsProcessing_6
   \   0008   4D02           CMP       A,#2
   \   000A   AD65           BZ        ??DATEepIsProcessing_7
   \   000C   4D03           CMP       A,#3
   \   000E   BD03           BNZ       $+5
   \   0010   9B....         BR        N:??DATEepIsProcessing_8
   \   0013   4D04           CMP       A,#4
   \   0015   BD03           BNZ       $+5
   \   0017   9B....         BR        N:??DATEepIsProcessing_9
   \   001A   4D05           CMP       A,#5
   \   001C   BD03           BNZ       $+5
   \   001E   9B....         BR        N:??DATEepIsProcessing_10
   \   0021   4D06           CMP       A,#6
   \   0023   BD03           BNZ       $+5
   \   0025   9B....         BR        N:??DATEepIsProcessing_11
   \   0028   9B....         BR        N:??DATEepIsProcessing_12
    407              {
    408                  // ------------------------------------------------------
    409                  //                 Reading State
    410                  // ------------------------------------------------------
    411              case( cStateReading   ) :
    412          
    413                  ReadDataLng = (tDATEepOffset)(Command.Msg.Lng / 2);
   \                     ??DATEepIsProcessing_6:
   \   002B   02....         MOVW      AX,Command+2
   \   002E   21             CLR1      CY
   \   002F   25             RORC      A,0x1
   \   0030   60             MOV       A,X
   \   0031   25             RORC      A,0x1
   \   0032   72             MOV       C,A
    414          
    415                  OffsetFromUserBuffer = OffsetFromUserBuffer + ReadDataLng;
   \   0033   8E....         MOV       A,OffsetFromUserBuffer
   \   0036   610A           ADD       A,C
   \   0038   9E....         MOV       OffsetFromUserBuffer,A
    416                  
    417                  if( OffsetFromUserBuffer < LastOffset )
   \   003B   48....         CMP       A,LastOffset
   \   003E   9D27           BNC       ??DATEepIsProcessing_13
    418                  {
    419                      // Read the next block
    420          
    421                      //QACJ 0506: The Buffer is always checked against NULL on assigment
    422                      Command.Msg.pBuffer = &(Command.Msg.pBuffer[Command.Msg.Lng]);
   \   0040   8E....         MOV       A,Command+3
   \   0043   30             XCH       A,X
   \   0044   08....         ADD       A,Command
   \   0047   30             XCH       A,X
   \   0048   28....         ADDC      A,Command+1
   \   004B   03....         MOVW      Command,AX
    423                      Command.Adress = Command.Adress + ReadDataLng;
   \   004E   62             MOV       A,C
   \   004F   A000           MOV       X,#0
   \   0051   08....         ADD       A,Command+4
   \   0054   30             XCH       A,X
   \   0055   28....         ADDC      A,Command+5
   \   0058   03....         MOVW      Command+4,AX
    424                      Command.Msg.Lng = mGetTransferSize(Command.Adress);
   \   005B   100200         MOVW      AX,#2
   \   005E   03....         MOVW      Command+2,AX
    425          
    426                      StartCommand();
   \   0061   9A....         CALL      StartCommand
   \   0064   9B....         BR        N:??DATEepIsProcessing_12
    427                  }
    428                  else
    429                  {
    430                      // There is no more data to process
    431                      State = cStateReady;
   \                     ??DATEepIsProcessing_13:
   \   0067   A100           MOV       A,#0
   \   0069   9E....         MOV       State,A
    432                      CallUser( cTrue );
   \                     ??EndOfCommand_0:
   \   006C   A301           MOV       B,#1
   \   006E   9B....         BR        N:??DATEepIsProcessing_14
    433                  }
    434                  break;
    435          
    436                  // ------------------------------------------------------
    437                  //                 Comparing State
    438                  // ------------------------------------------------------
    439              case( cStateComparing ) :
    440          
    441                  //QACJ 3416: No side effect because the function change nothing
    442                  //QACJ 0506: The UserBuffer is always checked against NULL on assigment
    443                  if( mIsDataIdentical((&UserBuffer[OffsetFromUserBuffer]), 
    444          						        ReadBuffer, Command.Msg.Lng) )
   \                     ??DATEepIsProcessing_7:
   \   0071   8E....         MOV       A,OffsetFromUserBuffer
   \   0074   A002           MOV       X,#2
   \   0076   3188           MULU      X
   \   0078   30             XCH       A,X
   \   0079   08....         ADD       A,UserBuffer
   \   007C   30             XCH       A,X
   \   007D   28....         ADDC      A,UserBuffer+1
   \   0080   D6             MOVW      HL,AX
   \   0081   87             MOV       A,[HL]
   \   0082   70             MOV       X,A
   \   0083   AE01           MOV       A,[HL+0x01]
   \   0085   D6             MOVW      HL,AX
   \   0086   02....         MOVW      AX,ReadBuffer
   \   0089   30             XCH       A,X
   \   008A   611E           SUB       A,L
   \   008C   30             XCH       A,X
   \   008D   613F           SUBC      A,H
   \   008F   6168           OR        A,X
   \   0091   BD34           BNZ       ??DATEepIsProcessing_15
    445                  {
    446                      ReadDataLng = (tDATEepOffset)(Command.Msg.Lng / 2);
   \   0093   02....         MOVW      AX,Command+2
   \   0096   21             CLR1      CY
   \   0097   25             RORC      A,0x1
   \   0098   60             MOV       A,X
   \   0099   25             RORC      A,0x1
   \   009A   72             MOV       C,A
    447          
    448                      OffsetFromUserBuffer = OffsetFromUserBuffer + ReadDataLng;
   \   009B   8E....         MOV       A,OffsetFromUserBuffer
   \   009E   610A           ADD       A,C
   \   00A0   9E....         MOV       OffsetFromUserBuffer,A
    449          
    450                      if( OffsetFromUserBuffer < LastOffset )
   \   00A3   48....         CMP       A,LastOffset
   \   00A6   9DBF           BNC       ??DATEepIsProcessing_13
    451                      {
    452                          // Read the next block
    453          
    454                          Command.Adress = Command.Adress + ReadDataLng;
   \   00A8   62             MOV       A,C
   \   00A9   A000           MOV       X,#0
   \   00AB   08....         ADD       A,Command+4
   \   00AE   30             XCH       A,X
   \   00AF   28....         ADDC      A,Command+5
   \   00B2   03....         MOVW      Command+4,AX
    455                          Command.Msg.Lng = mGetTransferSize(Command.Adress);
   \   00B5   100200         MOVW      AX,#2
   \   00B8   03....         MOVW      Command+2,AX
    456                          Command.Msg.pBuffer = (U8*)ReadBuffer;
   \   00BB   10....         MOVW      AX,#ReadBuffer
   \   00BE   03....         MOVW      Command,AX
    457          
    458                          StartCommand();
   \   00C1   9A....         CALL      StartCommand
   \   00C4   9B....         BR        N:??DATEepIsProcessing_12
    459                      }
    460                      else
    461                      {
    462                          // There is no more data to process
    463                          State = cStateReady;
    464                          CallUser( cTrue );
    465                      }
    466                  }
    467                  else
    468                  {
    469                      State = cStateReady;
   \                     ??DATEepIsProcessing_15:
   \   00C7   A100           MOV       A,#0
   \   00C9   9E....         MOV       State,A
    470                      CallUser( cFalse );
   \   00CC   73             MOV       B,A
   \   00CD   9B....         BR        N:??DATEepIsProcessing_14
    471                  }
    472                  break;
    473          
    474                  // ------------------------------------------------------
    475                  //                 Checking State
    476                  // ------------------------------------------------------
    477              case( cStateChecking  ) :
    478          
    479                  //QACJ 3416: No side effect because the function change nothing
    480                  if( mIsDataIdentical((&UserBuffer[OffsetFromUserBuffer]), 
    481          						        ReadBuffer, Command.Msg.Lng) )
   \                     ??DATEepIsProcessing_9:
   \   00D0   8E....         MOV       A,OffsetFromUserBuffer
   \   00D3   A002           MOV       X,#2
   \   00D5   3188           MULU      X
   \   00D7   30             XCH       A,X
   \   00D8   08....         ADD       A,UserBuffer
   \   00DB   30             XCH       A,X
   \   00DC   28....         ADDC      A,UserBuffer+1
   \   00DF   D6             MOVW      HL,AX
   \   00E0   87             MOV       A,[HL]
   \   00E1   70             MOV       X,A
   \   00E2   AE01           MOV       A,[HL+0x01]
   \   00E4   D6             MOVW      HL,AX
   \   00E5   02....         MOVW      AX,ReadBuffer
   \   00E8   30             XCH       A,X
   \   00E9   611E           SUB       A,L
   \   00EB   30             XCH       A,X
   \   00EC   613F           SUBC      A,H
   \   00EE   6168           OR        A,X
   \   00F0   BD50           BNZ       ??DATEepIsProcessing_16
    482                  {
    483                      WriteRetryCounter = 0;
   \   00F2   A100           MOV       A,#0
   \   00F4   9E....         MOV       WriteRetryCounter,A
    484          
    485                      ReadDataLng = (tDATEepOffset)(Command.Msg.Lng / 2);
   \   00F7   02....         MOVW      AX,Command+2
   \   00FA   21             CLR1      CY
   \   00FB   25             RORC      A,0x1
   \   00FC   60             MOV       A,X
   \   00FD   25             RORC      A,0x1
   \   00FE   72             MOV       C,A
    486          
    487                      OffsetFromUserBuffer = OffsetFromUserBuffer + ReadDataLng;
   \   00FF   8E....         MOV       A,OffsetFromUserBuffer
   \   0102   610A           ADD       A,C
   \   0104   9E....         MOV       OffsetFromUserBuffer,A
    488          
    489                      if( OffsetFromUserBuffer < LastOffset )
   \   0107   48....         CMP       A,LastOffset
   \   010A   9D25           BNC       ??DATEepIsProcessing_17
    490                      {
    491                          // Read the next block
    492          
    493                          Command.Adress = Command.Adress + ReadDataLng;
   \   010C   62             MOV       A,C
   \   010D   A000           MOV       X,#0
   \   010F   08....         ADD       A,Command+4
   \   0112   30             XCH       A,X
   \   0113   28....         ADDC      A,Command+5
   \   0116   03....         MOVW      Command+4,AX
    494                          Command.Msg.Lng = mGetTransferSize(Command.Adress);
   \   0119   100200         MOVW      AX,#2
   \   011C   03....         MOVW      Command+2,AX
    495                          Command.Msg.pBuffer = (U8*)ReadBuffer;
   \   011F   10....         MOVW      AX,#ReadBuffer
   \   0122   03....         MOVW      Command,AX
    496          
    497                          Command.Type = cCmdRead;
   \   0125   A100           MOV       A,#0
   \   0127   16....         MOVW      HL,#Command+6
   \   012A   97             MOV       [HL],A
    498          
    499                          StartCommand();
   \   012B   9A....         CALL      StartCommand
   \   012E   9B....         BR        N:??DATEepIsProcessing_12
    500                      }
    501                      else
    502                      {
    503                          // There is no more data to process
    504                          // Write cycle is terminate
    505                          State = cStateLocking;
   \                     ??DATEepIsProcessing_17:
   \   0131   A106           MOV       A,#6
   \   0133   9E....         MOV       State,A
    506                          Command.Type = cCmdLock;
   \   0136   A102           MOV       A,#2
   \   0138   16....         MOVW      HL,#Command+6
   \   013B   97             MOV       [HL],A
    507                          StartCommand();
   \   013C   9A....         CALL      StartCommand
   \   013F   9B....         BR        N:??DATEepIsProcessing_12
    508                      }
    509                  }
    510                  else
    511                  {
    512                      if( WriteRetryCounter < cDATEepMaxWriteRetryNumber )
   \                     ??DATEepIsProcessing_16:
   \   0142   8E....         MOV       A,WriteRetryCounter
   \   0145   4D05           CMP       A,#5
   \   0147   9DE8           BNC       ??DATEepIsProcessing_17
    513                      {
    514                          // The maximum number of retry is not reached
    515                          // A write cycle is done for this data
    516          
    517                          State = cStateWriting;
   \   0149   A105           MOV       A,#5
   \   014B   9E....         MOV       State,A
    518                          WriteRetryCounter++;
   \   014E   8E....         MOV       A,WriteRetryCounter
   \   0151   41             INC       A
   \   0152   9E....         MOV       WriteRetryCounter,A
    519          
    520                          Command.Msg.pBuffer  = (U8*)&UserBuffer[OffsetFromUserBuffer];
   \   0155   8E....         MOV       A,OffsetFromUserBuffer
   \   0158   A002           MOV       X,#2
   \   015A   3188           MULU      X
   \   015C   30             XCH       A,X
   \   015D   08....         ADD       A,UserBuffer
   \   0160   30             XCH       A,X
   \   0161   28....         ADDC      A,UserBuffer+1
   \   0164   03....         MOVW      Command,AX
    521                          Command.Type = cCmdWrite;
   \   0167   A101           MOV       A,#1
   \   0169   16....         MOVW      HL,#Command+6
   \   016C   97             MOV       [HL],A
    522          
    523                          StartCommand();
   \   016D   9A....         CALL      StartCommand
   \   0170   FA55           BR        ??DATEepIsProcessing_12
    524                      }
    525                      else
    526                      {
    527                          // The max number of retry is reached
    528                          // Write cycle is terminate
    529                          State = cStateLocking;
    530          
    531                          Command.Type = cCmdLock;
    532                          StartCommand();
    533                      }
    534                  }
    535                  break;
    536          
    537                  // ------------------------------------------------------
    538                  //                 Writing State
    539                  // ------------------------------------------------------
    540              case( cStateWriting   ) :
    541                  // The data write is terminated
    542                  // A read cycle is done to verify
    543                  Command.Msg.pBuffer = (U8*)ReadBuffer;
   \                     ??DATEepIsProcessing_10:
   \   0172   10....         MOVW      AX,#ReadBuffer
   \   0175   03....         MOVW      Command,AX
    544                  
    545                  Command.Type = cCmdRead;
   \   0178   A100           MOV       A,#0
   \   017A   16....         MOVW      HL,#Command+6
   \   017D   97             MOV       [HL],A
    546          
    547                  State = cStateChecking;
   \   017E   A104           MOV       A,#4
   \   0180   9E....         MOV       State,A
    548                  StartCommand();
   \   0183   9A....         CALL      StartCommand
   \   0186   FA3F           BR        ??DATEepIsProcessing_12
    549                  break;
    550          
    551                  // ------------------------------------------------------
    552                  //                 Unlocking
    553                  // ------------------------------------------------------
    554              case( cStateUnLocking ) :
    555                  State = cStateChecking;
   \                     ??DATEepIsProcessing_8:
   \   0188   A104           MOV       A,#4
   \   018A   9E....         MOV       State,A
    556                  Command.Type = cCmdRead;
   \   018D   A100           MOV       A,#0
   \   018F   16....         MOVW      HL,#Command+6
   \   0192   97             MOV       [HL],A
    557                  StartCommand();
   \   0193   9A....         CALL      StartCommand
   \   0196   FA2F           BR        ??DATEepIsProcessing_12
    558                  break;
    559          
    560                  // ------------------------------------------------------
    561                  //                 Locking
    562                  // ------------------------------------------------------
    563              case( cStateLocking ) :
    564                  State = cStateReady;
   \                     ??DATEepIsProcessing_11:
   \   0198   A100           MOV       A,#0
   \   019A   9E....         MOV       State,A
    565                  if( WriteRetryCounter < cDATEepMaxWriteRetryNumber )
   \   019D   8E....         MOV       A,WriteRetryCounter
   \   01A0   4D05           CMP       A,#5
   \   01A2   9D03           BNC       $+5
   \   01A4   9B....         BR        N:??EndOfCommand_0
    566                  {
    567                      CallUser( cTrue );
    568                  }
    569                  else
    570                  {
    571                      CallUser( cFalse );
   \   01A7   A300           MOV       B,#0
   \                     ??DATEepIsProcessing_14:
   \   01A9   8E....         MOV       A,ActiveProcessHandle
   \   01AC   72             MOV       C,A
   \   01AD   A004           MOV       X,#4
   \   01AF   3188           MULU      X
   \   01B1   CA....         ADDW      AX,#BlocList+3
   \   01B4   D6             MOVW      HL,AX
   \   01B5   87             MOV       A,[HL]
   \   01B6   A002           MOV       X,#2
   \   01B8   3188           MULU      X
   \   01BA   CA....         ADDW      AX,#CallBackList
   \   01BD   D6             MOVW      HL,AX
   \   01BE   87             MOV       A,[HL]
   \   01BF   70             MOV       X,A
   \   01C0   AE01           MOV       A,[HL+0x01]
   \   01C2   D6             MOVW      HL,AX
   \   01C3   62             MOV       A,C
   \   01C4   9A....         CALL      ?IND_CALL_L06
    572                  }
    573                  break;
    574          
    575                  // ------------------------------------------------------
    576                  //                 Removing the EEPROM protection if needed
    577                  // ------------------------------------------------------
    578          #ifdef cLIBStkUnprotect_Used
    579                  case( cStateUnprotecting ) :
    580                  {
    581                    State = cStateReady;
    582                    CallUser( cTrue );
    583                  }
    584                  break;
    585          #endif // cLIBStkUnprotect_Used
    586          
    587                  // ------------------------------------------------------
    588                  //                 Error State
    589                  // ------------------------------------------------------
    590              default :
    591                  mLIBassert(cFalse);
    592                  break;
    593              }
    594          }
   \                     ??DATEepIsProcessing_12:
   \   01C7   B2             POP       BC
   \   01C8   AF             RET       
   \   01C9                  REQUIRE ?CL78K_V4_6_L00
    595          
    596          
    597          //==============================================================================
    598          // DESCRIPTION : Periodical trigger of the state machine
    599          //
    600          // PARAMETERS (Type,Name,Min,Max) :   none
    601          //
    602          // RETURN VALUE :   none
    603          //
    604          // DESIGN INFORMATION : 
    605          //==============================================================================

   \                                 In  segment CODE, align 1, keep-with-next
    606          static void CommandStateMachine(void)
   \                     CommandStateMachine:
    607          {
   \   0000                  ; * Stack frame (at entry) *
   \   0000                  ; Param size: 0
   \   0000   B3             PUSH      BC
   \   0001   B5             PUSH      DE
   \   0002                  ; Total Auto size: 0
    608              BOOL bResult;
    609              BOOL IsAccessible;
    610          
    611              switch( CommandState )
   \   0002   8E....         MOV       A,CommandState
   \   0005   4D01           CMP       A,#1
   \   0007   AD0A           BZ        ??DATEepIsProcessing_18
   \   0009   4D02           CMP       A,#2
   \   000B   AD5C           BZ        ??DATEepIsProcessing_19
   \   000D   4D03           CMP       A,#3
   \   000F   AD71           BZ        ??DATEepIsProcessing_20
   \   0011   FA77           BR        ??DATEepIsProcessing_21
    612              {
    613              case(cCommandStateFrozen):
    614          
    615                  IsAccessible = DATPeeIsEepromAccessible();
    616          
    617                  if( IsAccessible == (BOOL) cTrue )
   \                     ??DATEepIsProcessing_18:
   \   0013   9A....         CALL      DATPeeIsEepromAccessible
   \   0016   51             DEC       A
   \   0017   BD71           BNZ       ??DATEepIsProcessing_21
    618                  {
    619                      // The state machine can leave the frozen state
    620                      CommandState = cCommandStateProcessing;
   \   0019   A102           MOV       A,#2
   \   001B   9E....         MOV       CommandState,A
    621                      SendCommand();
   \   001E   10....         MOVW      AX,#CommandTempo
   \   0021   ..             CALLT     [__T_TOSStartTimer]
   \   0022   8E....         MOV       A,Command+6
   \   0025   4D00           CMP       A,#0
   \   0027   AD0E           BZ        ??DATEepIsProcessing_22
   \   0029   4D01           CMP       A,#1
   \   002B   AD1C           BZ        ??DATEepIsProcessing_23
   \   002D   4D02           CMP       A,#2
   \   002F   AD2A           BZ        ??DATEepIsProcessing_24
   \   0031   4D03           CMP       A,#3
   \   0033   AD30           BZ        ??DATEepIsProcessing_25
   \   0035   FA53           BR        ??DATEepIsProcessing_21
   \                     ??DATEepIsProcessing_22:
   \   0037   12....         MOVW      BC,#Command
   \   003A   02....         MOVW      AX,Command+4
   \   003D   30             XCH       A,X
   \   003E   27             ROLC      A,0x1
   \   003F   30             XCH       A,X
   \   0040   27             ROLC      A,0x1
   \   0041   16....         MOVW      HL,#LWRD(LDBEepReceiveWithAddr)
   \   0044   A4..           MOV       E,#BYTE3(LDBEepReceiveWithAddr)
   \                     ??CommandStateMachine_0:
   \   0046   ..             CALLT     [__T_?FAR_CALL_L07]
   \   0047   FA41           BR        ??DATEepIsProcessing_21
   \                     ??DATEepIsProcessing_23:
   \   0049   12....         MOVW      BC,#Command
   \   004C   02....         MOVW      AX,Command+4
   \   004F   21             CLR1      CY
   \   0050   30             XCH       A,X
   \   0051   27             ROLC      A,0x1
   \   0052   30             XCH       A,X
   \   0053   27             ROLC      A,0x1
   \   0054   16....         MOVW      HL,#LWRD(LDBEepSendWithAddr)
   \   0057   A4..           MOV       E,#BYTE3(LDBEepSendWithAddr)
   \   0059   FAEB           BR        ??CommandStateMachine_0
   \                     ??DATEepIsProcessing_24:
   \   005B   A100           MOV       A,#0
   \                     ??CommandStateMachine_1:
   \   005D   16....         MOVW      HL,#LWRD(LDBEepControl)
   \   0060   A4..           MOV       E,#BYTE3(LDBEepControl)
   \   0062   ..             CALLT     [__T_?FAR_CALL_L07]
   \   0063   FA25           BR        ??DATEepIsProcessing_21
   \                     ??DATEepIsProcessing_25:
   \   0065   A101           MOV       A,#1
   \   0067   FAF4           BR        ??CommandStateMachine_1
    622                  }
    623                  break;
    624          
    625              case(cCommandStateProcessing):
    626          
    627          #ifdef cLDBEepCheckWriteCompletion
    628                  if( Command.Type == cCmdWrite )
   \                     ??DATEepIsProcessing_19:
   \   0069   8E....         MOV       A,Command+6
   \   006C   51             DEC       A
   \   006D   BD08           BNZ       ??DATEepIsProcessing_26
    629                  {
    630                      LDBControl(cLDBChannelEep, cLDBEepCheckWriteCompletion);
   \   006F   A102           MOV       A,#2
   \   0071   16....         MOVW      HL,#LWRD(LDBEepControl)
   \   0074   A4..           MOV       E,#BYTE3(LDBEepControl)
   \   0076   ..             CALLT     [__T_?FAR_CALL_L07]
    631                  }
    632          #endif
    633          
    634          #ifdef cLIBStkUnprotect_Used
    635                  if( Command.Type == cCmdUnprotect )
    636                  {
    637                      LDBControl(cLDBChannelEep, cLDBEepUnprotect);
    638                  }
    639          #endif // cLIBStkUnprotect_Used
    640          
    641                  bResult = TOSIsTimerElapsed( &CommandTempo, 
    642          	        mTOSConvMsInTimerTick(cDATEepTimeoutLdbMs));
    643          
    644                  if( bResult != cFalse )
   \                     ??DATEepIsProcessing_26:
   \   0077   10....         MOVW      AX,#CommandTempo
   \   007A   120A00         MOVW      BC,#10
   \   007D   ..             CALLT     [__T_TOSIsTimerElapsed]
   \   007E   4D00           CMP       A,#0
   \   0080   AD08           BZ        ??DATEepIsProcessing_21
    645                  {
    646                      // The time-out is reach
    647                      // the command is finised
    648                      CommandState = cCommandStateFree;
   \                     ??DATEepIsProcessing_20:
   \   0082   A100           MOV       A,#0
   \   0084   9E....         MOV       CommandState,A
    649                      EndOfCommand();
   \   0087   9A....         CALL      EndOfCommand
    650                  }
    651                  break;
    652          
    653              case(cCommandStateFinished):
    654                  // the command is finised
    655                  CommandState = cCommandStateFree;
    656                  EndOfCommand();
    657                  break;
    658          
    659              case(cCommandStateFree):
    660                  break;
    661          
    662              default:
    663                  mLIBassert(cFalse);
    664                  break;
    665              }
    666          }
   \                     ??DATEepIsProcessing_21:
   \   008A   B4             POP       DE
   \   008B   B2             POP       BC
   \   008C   AF             RET       
   \   008D                  REQUIRE ?CL78K_V4_6_L00
    667          
    668          //==============================================================================
    669          // DESCRIPTION : Process scheduling engine. Passes from one active process to another.
    670          //
    671          // PARAMETERS (Type,Name,Min,Max) :   none
    672          //
    673          // RETURN VALUE :   none
    674          //
    675          // DESIGN INFORMATION : 
    676          //==============================================================================

   \                                 In  segment CODE, align 1, keep-with-next
    677          static void ScheduleProcess(void)
   \                     ScheduleProcess:
    678          {
   \   0000                  ; * Stack frame (at entry) *
   \   0000                  ; Param size: 0
   \   0000   B3             PUSH      BC
   \   0001   B5             PUSH      DE
   \   0002                  ; Total Auto size: 0
    679              // No process are working
    680              if( ActiveProcessList != (tActiveProcessList) 0 )
   \   0002   02....         MOVW      AX,ActiveProcessList
   \   0005   6168           OR        A,X
   \   0007   AD6A           BZ        ??DATEepIsProcessing_27
    681              {
    682                  // One process or more are waiting
    683                  // we must select the next active process
    684                  tActiveProcessList ActiveProcessMask;
    685          
    686                  // Request ActiveSleep Mode
    687                  TOSSendControl( cTOSControlActiveSleepRequest );
   \   0009   A101           MOV       A,#1
   \   000B   ..             CALLT     [__T_TOSSendControl]
    688                  
    689                  ActiveProcessHandle = 0;
   \   000C   A100           MOV       A,#0
   \   000E   9E....         MOV       ActiveProcessHandle,A
    690                  ActiveProcessMask   = 1;
   \   0011   140100         MOVW      DE,#1
    691                  while((ActiveProcessMask & ActiveProcessList) == (tActiveProcessList) 0)
   \   0014   16....         MOVW      HL,#ActiveProcessList
   \   0017   31861B         BT        [HL].0, ??DATEepIsProcessing_28
    692                  {
    693                      ActiveProcessHandle ++;
   \                     ??ScheduleProcess_0:
   \   001A   8E....         MOV       A,ActiveProcessHandle
   \   001D   41             INC       A
   \   001E   9E....         MOV       ActiveProcessHandle,A
    694                      ActiveProcessMask <<= 1;
   \   0021   C4             MOVW      AX,DE
   \   0022   21             CLR1      CY
   \   0023   30             XCH       A,X
   \   0024   27             ROLC      A,0x1
   \   0025   30             XCH       A,X
   \   0026   27             ROLC      A,0x1
   \   0027   D4             MOVW      DE,AX
   \   0028   02....         MOVW      AX,ActiveProcessList
   \   002B   30             XCH       A,X
   \   002C   615C           AND       A,E
   \   002E   30             XCH       A,X
   \   002F   615D           AND       A,D
   \   0031   6168           OR        A,X
   \   0033   ADE5           BZ        ??ScheduleProcess_0
    695                  }
    696          
    697                  mLIBassert( ActiveProcessHandle<cDATEepExtendedNumberOfProcess );
    698          
    699                  // The process request is clear
    700                  // Modif YM le 09/01/2003: EPT URD 42 DEV 315
    701                  // TOSSuspendAllInterupts();
    702          
    703                  mDisableIT();
   \                     ??DATEepIsProcessing_28:
   \   0035   C4             MOVW      AX,DE
   \   0036   7B1E           DI
    704          
    705                  ActiveProcessList &= ~( ActiveProcessMask );
   \   0038   30             XCH       A,X
   \   0039   7DFF           XOR       A,#255
   \   003B   30             XCH       A,X
   \   003C   7DFF           XOR       A,#255
   \   003E   30             XCH       A,X
   \   003F   58....         AND       A,ActiveProcessList
   \   0042   30             XCH       A,X
   \   0043   58....         AND       A,ActiveProcessList+1
   \   0046   03....         MOVW      ActiveProcessList,AX
    706          
    707                  mEnableIT();
   \   0049   7A1E           EI
    708          
    709                  CallUser( cTrue );
   \   004B   A301           MOV       B,#1
   \   004D   8E....         MOV       A,ActiveProcessHandle
   \   0050   72             MOV       C,A
   \   0051   A004           MOV       X,#4
   \   0053   3188           MULU      X
   \   0055   CA....         ADDW      AX,#BlocList+3
   \   0058   D6             MOVW      HL,AX
   \   0059   87             MOV       A,[HL]
   \   005A   A002           MOV       X,#2
   \   005C   3188           MULU      X
   \   005E   CA....         ADDW      AX,#CallBackList
   \   0061   D6             MOVW      HL,AX
   \   0062   87             MOV       A,[HL]
   \   0063   70             MOV       X,A
   \   0064   AE01           MOV       A,[HL+0x01]
   \   0066   D6             MOVW      HL,AX
   \   0067   62             MOV       A,C
   \   0068   9A....         CALL      ?IND_CALL_L06
    710          
    711                  // In this state the alaram is start
    712                  TOSSetRelAlarm(
    713                                 &Alarm,
    714                                 0,
    715                                 (tTOSTickAlarm) mTOSConvUsInAlarmTick(cDATEepPeriodAlarmUs)
    716                                );
   \   006B   10....         MOVW      AX,#Alarm
   \   006E   A301           MOV       B,#1
   \   0070   9A....         CALL      TOSSetRelAlarm_Interne
    717              }
    718          }
   \                     ??DATEepIsProcessing_27:
   \   0073   B4             POP       DE
   \   0074   B2             POP       BC
   \   0075   AF             RET       
   \   0076                  REQUIRE ?CL78K_V4_6_L00
    719          
    720          
    721          
    722          //==============================================================================
    723          //=========================== EXPORTED FUNCTIONS ===============================
    724          //==============================================================================
    725          
    726          //==============================================================================
    727          // DESCRIPTION : Request of activation of a process
    728          //
    729          // PARAMETERS (Type,Name,Min,Max) : 
    730          //    tDATEepProcessHandle ProcessHandle: Indentifier of the process to activate
    731          //
    732          // RETURN VALUE :   none
    733          //
    734          // DESIGN INFORMATION : Result in a call of the process callback when teh EEPROM is
    735          //    available
    736          //==============================================================================

   \                                 In  segment CODE, align 1, keep-with-next
    737          void DATEepProcessRequest(tDATEepProcessHandle ProcessHandle)
   \                     DATEepProcessRequest:
    738          {
   \   0000                  ; * Stack frame (at entry) *
   \   0000                  ; Param size: 0
   \   0000   B3             PUSH      BC
   \   0001                  ; Total Auto size: 0
   \   0001   72             MOV       C,A
    739              mLIBassert( ProcessHandle<cDATEepExtendedNumberOfProcess );
    740          
    741              // Modif YM le 09/01/2003: EPT URD 42 DEV 315
    742              // TOSSuspendAllInterupts();
    743          
    744              mSuspendIT();
   \   0002   9A....         CALL      TOSSuspendOSInterrupts
    745          
    746              ActiveProcessList |= ( ((tActiveProcessList)1UL) << ProcessHandle );
   \   0005   100100         MOVW      AX,#1
   \   0008   ..             CALLT     [__T_?I_LSH_L02]
   \   0009   30             XCH       A,X
   \   000A   68....         OR        A,ActiveProcessList
   \   000D   30             XCH       A,X
   \   000E   68....         OR        A,ActiveProcessList+1
   \   0011   03....         MOVW      ActiveProcessList,AX
    747          
    748              mResumeIT();
   \   0014   9A....         CALL      TOSResumeOSInterrupts
    749          
    750              if( ActiveProcessHandle == cInvalidProcessHandle )
   \   0017   8E....         MOV       A,ActiveProcessHandle
   \   001A   4DFF           CMP       A,#255
   \   001C   BD06           BNZ       ??DATEepIsProcessing_29
    751              {
    752                  TOSActivateTask( cTOSTaskIdDATEepTask );
   \   001E   100100         MOVW      AX,#1
   \   0021   9A....         CALL      TOSActivateTask
    753              }
    754          }
   \                     ??DATEepIsProcessing_29:
   \   0024   B2             POP       BC
   \   0025   AF             RET       
   \   0026                  REQUIRE ?CL78K_V4_6_L00
    755          
    756          //==============================================================================
    757          // DESCRIPTION : Check if a process activation is pending or active.
    758          //
    759          // PARAMETERS (Type,Name,Min,Max) : 
    760          //    tDATEepProcessHandle ProcessHandle: Identifier og the process to check
    761          //
    762          // RETURN VALUE :   none
    763          //
    764          // DESIGN INFORMATION : 
    765          //==============================================================================

   \                                 In  segment CODE, align 1, keep-with-next
    766          BOOL DATEepIsActivate(tDATEepProcessHandle ProcessHandle)
   \                     DATEepIsActivate:
    767          {
   \   0000                  ; * Stack frame (at entry) *
   \   0000                  ; Param size: 0
   \   0000   B3             PUSH      BC
   \   0001                  ; Total Auto size: 0
   \   0001   70             MOV       X,A
    768              BOOL IsActivate;
    769          
    770              if( ActiveProcessHandle == ProcessHandle )
   \   0002   8E....         MOV       A,ActiveProcessHandle
   \   0005   6148           CMP       A,X
   \   0007   BD04           BNZ       ??DATEepIsProcessing_30
    771              {
    772                  // This process is currently working
    773                  IsActivate = cTrue;
   \                     ??DATEepIsActivate_0:
   \   0009   A101           MOV       A,#1
   \   000B   FA14           BR        ??DATEepIsProcessing_31
    774              }
    775              
    776              else if ( (ActiveProcessList & ( ((tActiveProcessList)1U) << ProcessHandle ))
    777                        != (tActiveProcessList)0U)
   \                     ??DATEepIsProcessing_30:
   \   000D   60             MOV       A,X
   \   000E   72             MOV       C,A
   \   000F   100100         MOVW      AX,#1
   \   0012   ..             CALLT     [__T_?I_LSH_L02]
   \   0013   30             XCH       A,X
   \   0014   58....         AND       A,ActiveProcessList
   \   0017   30             XCH       A,X
   \   0018   58....         AND       A,ActiveProcessList+1
   \   001B   6168           OR        A,X
   \   001D   BDEA           BNZ       ??DATEepIsActivate_0
    778              {
    779                  // This process is not actually working,
    780                  // This process is present in the waiting list.
    781                  IsActivate = cTrue;
    782              }
    783              else
    784              {
    785                  // This process is not actually working,
    786                  // This process is not present in the waiting list.
    787                  IsActivate = cFalse;
   \   001F   A100           MOV       A,#0
    788              }
    789          
    790              return IsActivate;
   \                     ??DATEepIsProcessing_31:
   \   0021   B2             POP       BC
   \   0022   AF             RET       
   \   0023                  REQUIRE ?CL78K_V4_6_L00
    791          }
    792          
    793          
    794          //==============================================================================
    795          // DESCRIPTION : Free the currently active process so as to let the others run.
    796          //
    797          // PARAMETERS (Type,Name,Min,Max) :   none
    798          //
    799          // RETURN VALUE :   none
    800          //
    801          // DESIGN INFORMATION :
    802          //==============================================================================

   \                                 In  segment CODE, align 1, keep-with-next
    803          void DATEepTerminateProcess(void)
   \                     DATEepTerminateProcess:
    804          {
   \   0000                  ; * Stack frame (at entry) *
   \   0000                  ; Param size: 0
   \   0000                  ; Total Auto size: 0
    805              mLIBassert( State == cStateReady );
    806          
    807              ActiveProcessHandle = cInvalidProcessHandle;
   \   0000   A1FF           MOV       A,#255
   \   0002   9E....         MOV       ActiveProcessHandle,A
    808              TOSCancelAlarm( &Alarm );
   \   0005   10....         MOVW      AX,#Alarm
   \   0008   9A....         CALL      TOSCancelAlarm
    809          
    810              if( ActiveProcessList != (tActiveProcessList)0U )
   \   000B   02....         MOVW      AX,ActiveProcessList
   \   000E   6168           OR        A,X
   \   0010   AD06           BZ        ??DATEepIsProcessing_32
    811              {
    812                  TOSActivateTask( cTOSTaskIdDATEepTask );
   \   0012   100100         MOVW      AX,#1
   \   0015   9A....         CALL      TOSActivateTask
    813              }
    814          }
   \                     ??DATEepIsProcessing_32:
   \   0018   AF             RET       
   \   0019                  REQUIRE ?CL78K_V4_6_L00
    815          //==============================================================================
    816          // DESCRIPTION : Read a buffer from the EEPROM in a zone belonging to the active process
    817          //
    818          // PARAMETERS (Type,Name,Min,Max) : 
    819          //    U16* pBuff:        Buffer for output.
    820          //
    821          //    tDATEepOffset Ad:  Address to read, relative to the EEPROM zone of the process.
    822          //						 (in 16 bit word)
    823          //    tDATEepOffset Sz:  Size to read in bytes (in 16 bit word)
    824          //
    825          // RETURN VALUE :   none
    826          //
    827          // DESIGN INFORMATION : Use this only from an active process.
    828          //    Make sure the buffer is big enough for the size
    829          //==============================================================================

   \                                 In  segment CODE, align 1, keep-with-next
    830          void DATEepRead( U16* pBuff, tDATEepOffset Ad, tDATEepOffset Sz )
   \                     DATEepRead:
    831          {
   \   0000                  ; * Stack frame (at entry) *
   \   0000                  ; Param size: 0
   \   0000   B5             PUSH      DE
   \   0001                  ; Total Auto size: 0
   \   0001   D4             MOVW      DE,AX
    832              mLIBassert( State == cStateReady );
    833          
    834              if( (ActiveProcessHandle != cInvalidProcessHandle) && (pBuff != NULL) )
   \   0002   8E....         MOV       A,ActiveProcessHandle
   \   0005   4DFF           CMP       A,#255
   \   0007   AD42           BZ        ??DATEepIsProcessing_33
   \   0009   65             MOV       A,D
   \   000A   6168           OR        A,X
   \   000C   AD3D           BZ        ??DATEepIsProcessing_33
    835              {
    836                  mLIBassert( ActiveProcessHandle < cDATEepExtendedNumberOfProcess );
    837          
    838                  State = cStateReading;
   \   000E   A101           MOV       A,#1
   \   0010   9E....         MOV       State,A
    839          
    840                  LastOffset = Sz;
   \   0013   62             MOV       A,C
   \   0014   9E....         MOV       LastOffset,A
    841                  OffsetFromUserBuffer = 0;
   \   0017   A100           MOV       A,#0
   \   0019   9E....         MOV       OffsetFromUserBuffer,A
    842          
    843                  Command.Adress  = Ad + BlocList[ActiveProcessHandle].Offset;
   \   001C   8E....         MOV       A,ActiveProcessHandle
   \   001F   A004           MOV       X,#4
   \   0021   3188           MULU      X
   \   0023   CA....         ADDW      AX,#BlocList
   \   0026   D6             MOVW      HL,AX
   \   0027   87             MOV       A,[HL]
   \   0028   70             MOV       X,A
   \   0029   AE01           MOV       A,[HL+0x01]
   \   002B   D6             MOVW      HL,AX
   \   002C   63             MOV       A,B
   \   002D   72             MOV       C,A
   \   002E   67             MOV       A,H
   \   002F   30             XCH       A,X
   \   0030   610A           ADD       A,C
   \   0032   30             XCH       A,X
   \   0033   2D00           ADDC      A,#0
   \   0035   03....         MOVW      Command+4,AX
    844                  Command.Msg.Lng = mGetTransferSize(Command.Adress);
   \   0038   100200         MOVW      AX,#2
   \   003B   03....         MOVW      Command+2,AX
    845                  Command.Msg.pBuffer = (U8*)pBuff;
   \   003E   C4             MOVW      AX,DE
   \   003F   03....         MOVW      Command,AX
    846                  Command.Type = cCmdRead;
   \   0042   A100           MOV       A,#0
   \   0044   16....         MOVW      HL,#Command+6
   \   0047   97             MOV       [HL],A
    847          
    848                  StartCommand();
   \   0048   9A....         CALL      StartCommand
    849              }
    850              else
    851              {
    852                  mLIBassert(cFalse);
    853              }
    854          }
   \                     ??DATEepIsProcessing_33:
   \   004B   B4             POP       DE
   \   004C   AF             RET       
   \   004D                  REQUIRE ?CL78K_V4_6_L00
    855          //==============================================================================
    856          // DESCRIPTION : Write a buffer into the EEPROM in a zone belonging to the 
    857          // active process
    858          //
    859          // PARAMETERS (Type,Name,Min,Max) : 
    860          //    U16* pBuff:       Buffer containing the source data.
    861          //    tDATEepOffset Ad: Adress where the data must be written (in 16 bit word).
    862          //    tDATEepOffset Sz: Size of the data (in 16 bit word).
    863          //
    864          // RETURN VALUE :   none
    865          //
    866          // DESIGN INFORMATION : Use this only from an active process
    867          //==============================================================================

   \                                 In  segment CODE, align 1, keep-with-next
    868          void DATEepWrite  (U16* pBuff, tDATEepOffset Ad, tDATEepOffset Sz)
   \                     DATEepWrite:
    869          {
   \   0000                  ; * Stack frame (at entry) *
   \   0000                  ; Param size: 0
   \   0000   B5             PUSH      DE
   \   0001                  ; Total Auto size: 0
   \   0001   D4             MOVW      DE,AX
    870              mLIBassert( State == cStateReady );
    871          
    872              if( (ActiveProcessHandle != cInvalidProcessHandle) && (pBuff != NULL) )
   \   0002   8E....         MOV       A,ActiveProcessHandle
   \   0005   4DFF           CMP       A,#255
   \   0007   AD74           BZ        ??DATEepIsProcessing_34
   \   0009   65             MOV       A,D
   \   000A   6168           OR        A,X
   \   000C   AD6F           BZ        ??DATEepIsProcessing_34
    873              {
    874                  mLIBassert( ActiveProcessHandle < cDATEepExtendedNumberOfProcess );
    875          
    876                  if( (Sz+Ad) <= BlocList[ActiveProcessHandle].Size )
   \   000E   63             MOV       A,B
   \   000F   76             MOV       L,A
   \   0010   62             MOV       A,C
   \   0011   A000           MOV       X,#0
   \   0013   610E           ADD       A,L
   \   0015   30             XCH       A,X
   \   0016   2D00           ADDC      A,#0
   \   0018   B1             PUSH      AX
   \   0019   8E....         MOV       A,ActiveProcessHandle
   \   001C   A004           MOV       X,#4
   \   001E   3188           MULU      X
   \   0020   CA....         ADDW      AX,#BlocList+2
   \   0023   D6             MOVW      HL,AX
   \   0024   87             MOV       A,[HL]
   \   0025   70             MOV       X,A
   \   0026   B6             POP       HL
   \   0027   67             MOV       A,H
   \   0028   7D80           XOR       A,#128
   \   002A   77             MOV       H,A
   \   002B   60             MOV       A,X
   \   002C   A080           MOV       X,#128
   \   002E   611E           SUB       A,L
   \   0030   60             MOV       A,X
   \   0031   613F           SUBC      A,H
   \   0033   8D48           BC        ??DATEepIsProcessing_34
    877                  {
    878                      State = cStateUnLocking;
   \   0035   A103           MOV       A,#3
   \   0037   9E....         MOV       State,A
    879          
    880                      LastOffset = Sz;
   \   003A   62             MOV       A,C
   \   003B   9E....         MOV       LastOffset,A
    881                      OffsetFromUserBuffer = 0;
   \   003E   A100           MOV       A,#0
   \   0040   9E....         MOV       OffsetFromUserBuffer,A
    882          
    883                      Command.Adress  = Ad + BlocList[ActiveProcessHandle].Offset;
   \   0043   8E....         MOV       A,ActiveProcessHandle
   \   0046   A004           MOV       X,#4
   \   0048   3188           MULU      X
   \   004A   CA....         ADDW      AX,#BlocList
   \   004D   D6             MOVW      HL,AX
   \   004E   87             MOV       A,[HL]
   \   004F   70             MOV       X,A
   \   0050   AE01           MOV       A,[HL+0x01]
   \   0052   D6             MOVW      HL,AX
   \   0053   63             MOV       A,B
   \   0054   72             MOV       C,A
   \   0055   67             MOV       A,H
   \   0056   30             XCH       A,X
   \   0057   610A           ADD       A,C
   \   0059   30             XCH       A,X
   \   005A   2D00           ADDC      A,#0
   \   005C   03....         MOVW      Command+4,AX
    884                      Command.Msg.Lng = mGetTransferSize(Command.Adress);
   \   005F   100200         MOVW      AX,#2
   \   0062   03....         MOVW      Command+2,AX
    885                      Command.Msg.pBuffer = (U8*)ReadBuffer;
   \   0065   10....         MOVW      AX,#ReadBuffer
   \   0068   03....         MOVW      Command,AX
    886                      Command.Type = cCmdUnlock;
   \   006B   A103           MOV       A,#3
   \   006D   16....         MOVW      HL,#Command+6
   \   0070   97             MOV       [HL],A
    887          
    888                      UserBuffer = pBuff;
   \   0071   C4             MOVW      AX,DE
   \   0072   03....         MOVW      UserBuffer,AX
    889          
    890                      WriteRetryCounter = 0;
   \   0075   A100           MOV       A,#0
   \   0077   9E....         MOV       WriteRetryCounter,A
    891          
    892                      StartCommand();
   \   007A   9A....         CALL      StartCommand
    893                  }
    894                  else
    895                  {
    896                      mLIBassert(cFalse);
    897                  }
    898              }
    899              else
    900              {
    901                  mLIBassert(cFalse);
    902              }
    903          }
   \                     ??DATEepIsProcessing_34:
   \   007D   B4             POP       DE
   \   007E   AF             RET       
   \   007F                  REQUIRE ?CL78K_V4_6_L00
    904          
    905          //==============================================================================
    906          // DESCRIPTION : Compare the contents of the EEPROM in a zone belonging to a process
    907          //    with a RAM area
    908          //
    909          // PARAMETERS (Type,Name,Min,Max) : 
    910          //    U16* pBuff:               Buffer containing the reference data.
    911          //    tDATEepOffset Ad:  Adress where to begin the comparison, relative to the beginning
    912          //       of the zone belonging to the process.
    913          //    tDATEepOffset Sz: Size to compare in bytes.
    914          //
    915          // RETURN VALUE :   none
    916          //
    917          // DESIGN INFORMATION : Use this only from an active process
    918          //==============================================================================

   \                                 In  segment CODE, align 1, keep-with-next
    919          void DATEepCompare(U16* pBuff, tDATEepOffset Ad, tDATEepOffset Sz)
   \                     DATEepCompare:
    920          {
   \   0000                  ; * Stack frame (at entry) *
   \   0000                  ; Param size: 0
   \   0000   B5             PUSH      DE
   \   0001                  ; Total Auto size: 0
   \   0001   D4             MOVW      DE,AX
    921              mLIBassert( State == cStateReady );
    922          
    923              if( (ActiveProcessHandle != cInvalidProcessHandle) && (pBuff != NULL) )
   \   0002   8E....         MOV       A,ActiveProcessHandle
   \   0005   4DFF           CMP       A,#255
   \   0007   AD48           BZ        ??DATEepIsProcessing_35
   \   0009   65             MOV       A,D
   \   000A   6168           OR        A,X
   \   000C   AD43           BZ        ??DATEepIsProcessing_35
    924              {
    925                  mLIBassert( ActiveProcessHandle < cDATEepExtendedNumberOfProcess );
    926          
    927                  State = cStateComparing;
   \   000E   A102           MOV       A,#2
   \   0010   9E....         MOV       State,A
    928          
    929                  LastOffset = Sz;
   \   0013   62             MOV       A,C
   \   0014   9E....         MOV       LastOffset,A
    930                  OffsetFromUserBuffer = 0;
   \   0017   A100           MOV       A,#0
   \   0019   9E....         MOV       OffsetFromUserBuffer,A
    931          
    932                  Command.Adress  = Ad + BlocList[ActiveProcessHandle].Offset;
   \   001C   8E....         MOV       A,ActiveProcessHandle
   \   001F   A004           MOV       X,#4
   \   0021   3188           MULU      X
   \   0023   CA....         ADDW      AX,#BlocList
   \   0026   D6             MOVW      HL,AX
   \   0027   87             MOV       A,[HL]
   \   0028   70             MOV       X,A
   \   0029   AE01           MOV       A,[HL+0x01]
   \   002B   D6             MOVW      HL,AX
   \   002C   63             MOV       A,B
   \   002D   72             MOV       C,A
   \   002E   67             MOV       A,H
   \   002F   30             XCH       A,X
   \   0030   610A           ADD       A,C
   \   0032   30             XCH       A,X
   \   0033   2D00           ADDC      A,#0
   \   0035   03....         MOVW      Command+4,AX
    933                  Command.Msg.Lng = mGetTransferSize(Command.Adress);
   \   0038   100200         MOVW      AX,#2
   \   003B   03....         MOVW      Command+2,AX
    934                  Command.Msg.pBuffer = (U8*)ReadBuffer;
   \   003E   10....         MOVW      AX,#ReadBuffer
   \   0041   03....         MOVW      Command,AX
    935                  Command.Type = cCmdRead;
   \   0044   A100           MOV       A,#0
   \   0046   16....         MOVW      HL,#Command+6
   \   0049   97             MOV       [HL],A
    936          
    937                  UserBuffer = pBuff;
   \   004A   C4             MOVW      AX,DE
   \   004B   03....         MOVW      UserBuffer,AX
    938          
    939                  StartCommand();
   \   004E   9A....         CALL      StartCommand
    940              }
    941              else
    942              {
    943                  mLIBassert(cFalse);
    944              }
    945          }
   \                     ??DATEepIsProcessing_35:
   \   0051   B4             POP       DE
   \   0052   AF             RET       
   \   0053                  REQUIRE ?CL78K_V4_6_L00
    946          
    947          //==============================================================================
    948          // DESCRIPTION : Read the EEPROM without process mapping
    949          //
    950          // PARAMETERS (Type,Name,Min,Max) :
    951          //    U16* pBuff:               Buffer where to write the data to.
    952          //    tDATEepOffset Ad:  Adress where to read from the EEPROM, relative to the beginning
    953          //       of the zone belonging to the process.
    954          //    tDATEepOffset Sz: Size to write in bytes.
    955          //
    956          // RETURN VALUE :   none
    957          //
    958          // DESIGN INFORMATION : Use this only from the supervisor process when active
    959          //==============================================================================

   \                                 In  segment CODE, align 1, keep-with-next
    960          void DATEepAbsoluteRead (U16* pBuff, U16 Ad, tDATEepOffset Sz)
   \                     DATEepAbsoluteRead:
    961          {
   \   0000                  ; * Stack frame (at entry) *
   \   0000                  ; Param size: 0
   \   0000                  ; Total Auto size: 0
   \   0000   D6             MOVW      HL,AX
    962              mLIBassert( State == cStateReady );
    963          
    964              if( (ActiveProcessHandle == cDATEepProcessSupervisor) && (pBuff != NULL) )
   \   0001   8E....         MOV       A,ActiveProcessHandle
   \   0004   4D0A           CMP       A,#10
   \   0006   BD2A           BNZ       ??DATEepIsProcessing_36
   \   0008   67             MOV       A,H
   \   0009   6168           OR        A,X
   \   000B   AD25           BZ        ??DATEepIsProcessing_36
    965              {
    966                  State = cStateReading;
   \   000D   A101           MOV       A,#1
   \   000F   9E....         MOV       State,A
    967          
    968                  LastOffset = Sz;
   \   0012   65             MOV       A,D
   \   0013   9E....         MOV       LastOffset,A
    969                  OffsetFromUserBuffer = 0;
   \   0016   A100           MOV       A,#0
   \   0018   9E....         MOV       OffsetFromUserBuffer,A
    970          
    971                  Command.Adress  = Ad;
   \   001B   C2             MOVW      AX,BC
   \   001C   03....         MOVW      Command+4,AX
    972                  Command.Msg.Lng = mGetTransferSize(Command.Adress);
   \   001F   100200         MOVW      AX,#2
   \   0022   03....         MOVW      Command+2,AX
    973                  Command.Msg.pBuffer = (U8*)pBuff;
   \   0025   C6             MOVW      AX,HL
   \   0026   03....         MOVW      Command,AX
    974                  Command.Type = cCmdRead;
   \   0029   A100           MOV       A,#0
   \   002B   16....         MOVW      HL,#Command+6
   \   002E   97             MOV       [HL],A
    975          
    976                  StartCommand();
   \   002F   9A....         CALL      StartCommand
    977              }
    978              else
    979              {
    980                  mLIBassert(cFalse);
    981              }
    982          }
   \                     ??DATEepIsProcessing_36:
   \   0032   AF             RET       
   \   0033                  REQUIRE ?CL78K_V4_6_L00
    983          
    984          //==============================================================================
    985          // DESCRIPTION : Write into the EEPROM without process mapping
    986          //
    987          // PARAMETERS (Type,Name,Min,Max) : 
    988          //    U16* pBuff:               Buffer containing the source data.
    989          //    U16 Ad:                       Adress where to write to. 0 is the beginning of the EEPROM
    990          //    tDATEepOffset Sz   Size to write
    991          //
    992          // RETURN VALUE :   none
    993          //
    994          // DESIGN INFORMATION : Use this only from the supervisor process when active
    995          //==============================================================================

   \                                 In  segment CODE, align 1, keep-with-next
    996          void DATEepAbsoluteWrite(U16* pBuff, U16 Ad, tDATEepOffset Sz)
   \                     DATEepAbsoluteWrite:
    997          {
   \   0000                  ; * Stack frame (at entry) *
   \   0000                  ; Param size: 0
   \   0000   B1             PUSH      AX
   \   0001                  ; Total Auto size: 2
    998              mLIBassert( State == cStateReady );
    999          
   1000              if( (ActiveProcessHandle == cDATEepProcessSupervisor) && (pBuff != NULL) )
   \   0001   8E....         MOV       A,ActiveProcessHandle
   \   0004   4D0A           CMP       A,#10
   \   0006   BD41           BNZ       ??DATEepIsProcessing_37
   \   0008   891C           MOVW      AX,SP
   \   000A   D6             MOVW      HL,AX
   \   000B   87             MOV       A,[HL]
   \   000C   70             MOV       X,A
   \   000D   AE01           MOV       A,[HL+0x01]
   \   000F   6168           OR        A,X
   \   0011   AD36           BZ        ??DATEepIsProcessing_37
   1001              {
   1002                  State = cStateUnLocking;
   \   0013   A103           MOV       A,#3
   \   0015   9E....         MOV       State,A
   1003          
   1004                  LastOffset = Sz;
   \   0018   65             MOV       A,D
   \   0019   9E....         MOV       LastOffset,A
   1005                  OffsetFromUserBuffer  = 0;
   \   001C   A100           MOV       A,#0
   \   001E   9E....         MOV       OffsetFromUserBuffer,A
   1006          
   1007                  Command.Adress  = Ad;
   \   0021   C2             MOVW      AX,BC
   \   0022   03....         MOVW      Command+4,AX
   1008                  Command.Msg.Lng = mGetTransferSize(Command.Adress);
   \   0025   100200         MOVW      AX,#2
   \   0028   03....         MOVW      Command+2,AX
   1009                  Command.Msg.pBuffer = (U8*)ReadBuffer;
   \   002B   10....         MOVW      AX,#ReadBuffer
   \   002E   03....         MOVW      Command,AX
   1010                  Command.Type = cCmdUnlock;
   \   0031   A103           MOV       A,#3
   \   0033   16....         MOVW      HL,#Command+6
   \   0036   97             MOV       [HL],A
   1011          
   1012                  UserBuffer = pBuff;
   \   0037   891C           MOVW      AX,SP
   \   0039   D6             MOVW      HL,AX
   \   003A   87             MOV       A,[HL]
   \   003B   70             MOV       X,A
   \   003C   AE01           MOV       A,[HL+0x01]
   \   003E   03....         MOVW      UserBuffer,AX
   1013          
   1014                  WriteRetryCounter = 0;
   \   0041   A100           MOV       A,#0
   \   0043   9E....         MOV       WriteRetryCounter,A
   1015          
   1016                  StartCommand();
   \   0046   9A....         CALL      StartCommand
   1017              }
   1018              else
   1019              {
   1020                  mLIBassert(cFalse);
   1021              }
   1022          }
   \                     ??DATEepIsProcessing_37:
   \   0049   B0             POP       AX
   \   004A   AF             RET       
   \   004B                  REQUIRE ?CL78K_V4_6_L00
   1023          
   1024          //==============================================================================
   1025          // DESCRIPTION : Command for unprotecting the EEPROM.
   1026          //
   1027          // PARAMETERS (Type,Name,Min,Max) :   none
   1028          //
   1029          // RETURN VALUE :   none
   1030          //
   1031          // DESIGN INFORMATION : This updates the Command contect and provokes the LDB
   1032          //    command
   1033          //==============================================================================
   1034          #ifdef cLIBStkUnprotect_Used
   1035          void DATEepUnprotect (void)
   1036          {
   1037              mLIBassert( State == cStateReady );
   1038          
   1039              State = cStateUnprotecting;
   1040          
   1041              Command.Type          = cCmdUnprotect;
   1042              // The other fields of Command are not reset because unuseful
   1043          
   1044              StartCommand();
   1045          }
   1046          #endif // cLIBStkUnprotect_Used
   1047          
   1048          
   1049          //==============================================================================
   1050          // DESCRIPTION : Callback used by LDB_EEP for indicating the completion of a LDBControl
   1051          //    operation
   1052          //
   1053          // PARAMETERS (Type,Name,Min,Max) : 
   1054          //    tCtrl Ctrl:          The type of control that is complete.
   1055          //    tStatus Status  Status of the operation (value of cLDBCorrect for success).
   1056          //
   1057          // RETURN VALUE :   none
   1058          //
   1059          // DESIGN INFORMATION : 
   1060          //==============================================================================

   \                                 In  segment CODE, align 1, keep-with-next
   1061          void DATEepCallBackEndCtrl (tCtrl Ctrl, tStatus Status)
   \                     DATEepCallBackEndCtrl:
   1062          {
   \   0000                  ; * Stack frame (at entry) *
   \   0000                  ; Param size: 0
   \   0000                  ; Total Auto size: 0
   1063              BOOL IsCommandToFinish;
   1064          
   1065              //QACJ 3199: API change refused yet - we keep non static parameters
   1066              Status = Status;
   1067              Ctrl = Ctrl;
   1068          
   1069              IsCommandToFinish = cTrue;
   1070          
   1071          #ifdef cLDBEepCheckWriteCompletion
   1072              if( Ctrl == cLDBEepCheckWriteCompletion )
   \   0000   4D02           CMP       A,#2
   \   0002   AD0B           BZ        ??DATEepIsProcessing_38
   1073              {
   1074                  // The write operation is not complete before LDB calls the Tx Callback
   1075                  mLIBassert(Status==cLDBCorrect);
   1076                  IsCommandToFinish = cFalse;
   1077              }
   1078          #endif // cLDBEepCheckWriteCompletion
   1079          
   1080          #ifdef cLIBStkUnprotect_Used
   1081              if( Status == cLDBEepControlInProgress )
   1082              {
   1083                  // The command is not over while the callback says
   1084                  //    cLDBEepControlInProgress. linited to the unprotect service
   1085                  mLIBassert(Ctrl == cLDBEepUnprotect);
   1086                  IsCommandToFinish = cFalse;
   1087              }
   1088          #endif // cLIBStkUnprotect_Used
   1089              
   1090              if (IsCommandToFinish != cFalse)
   1091              {
   1092                  mLIBassert(Status==cLDBCorrect);
   1093                  CommandState = cCommandStateFinished;
   \   0004   A103           MOV       A,#3
   \   0006   9E....         MOV       CommandState,A
   1094                  TOSActivateTask( cTOSTaskIdDATEepTask );
   \   0009   100100         MOVW      AX,#1
   \   000C   9A....         CALL      TOSActivateTask
   1095              }
   1096          }
   \                     ??DATEepIsProcessing_38:
   \   000F   AF             RET       
   \   0010                  REQUIRE ?CL78K_V4_6_L00
   1097          
   1098          //==============================================================================
   1099          // DESCRIPTION : DATEepCallBackTxWithAddr
   1100          //
   1101          // PARAMETERS (Type,Name,Min,Max) : 
   1102          //    tAddress Unused:  Address targetted by the write request that is complete
   1103          //    tStatus Status:      Status of the write operation. cLDBCorrect for success.
   1104          //
   1105          // RETURN VALUE :   none
   1106          //
   1107          // DESIGN INFORMATION : 
   1108          //==============================================================================

   \                                 In  segment CODE, align 1, keep-with-next
   1109          void DATEepCallBackTxWithAddr (tAddress Unused, tStatus Status)
   \                     DATEepCallBackTxWithAddr:
   1110          {
   \   0000                  ; * Stack frame (at entry) *
   \   0000                  ; Param size: 0
   \   0000                  ; Total Auto size: 0
   1111              mLIBassert(Status==cLDBCorrect);
   1112              //QACJ 3199: API change refused yet - we keep non static parameters
   1113              Status = Status;
   1114              //QACJ 3199: API change refused yet - we keep non static parameters
   1115              Unused = Unused;
   1116          
   1117              CommandState = cCommandStateFinished;
   \   0000   A103           MOV       A,#3
   \   0002   9E....         MOV       CommandState,A
   1118              TOSActivateTask( cTOSTaskIdDATEepTask );
   \   0005   100100         MOVW      AX,#1
   \   0008   9B....         BR        N:TOSActivateTask
   \   000B                  REQUIRE ?CL78K_V4_6_L00
   1119          }
   1120          
   1121          //==============================================================================
   1122          // DESCRIPTION : Callback used by LDB_EEP for indicating the completion of a read
   1123          //    operation.
   1124          //
   1125          // PARAMETERS (Type,Name,Min,Max) : 
   1126          //    tAddress Unused:  Address targetted by the read request that is complete
   1127          //    tStatus Status:      Status of the read operation. cLDBCorrect for success.
   1128          //
   1129          // RETURN VALUE :   none
   1130          //
   1131          // DESIGN INFORMATION : 
   1132          //==============================================================================

   \                                 In  segment CODE, align 1, keep-with-next
   1133          void DATEepCallBackRxWithAddr (tAddress Unused, tStatus Status)
   \                     DATEepCallBackRxWithAddr:
   1134          {
   \   0000                  ; * Stack frame (at entry) *
   \   0000                  ; Param size: 0
   \   0000                  ; Total Auto size: 0
   1135              mLIBassert(Status==cLDBCorrect);
   1136              //QACJ 3199: API change refused yet - we keep non static parameters
   1137              Status = Status;
   1138              //QACJ 3199: API change refused yet - we keep non static parameters
   1139              Unused = Unused;
   1140          
   1141              CommandState = cCommandStateFinished;
   \   0000   A103           MOV       A,#3
   \   0002   9E....         MOV       CommandState,A
   1142              TOSActivateTask( cTOSTaskIdDATEepTask );
   \   0005   100100         MOVW      AX,#1
   \   0008   9B....         BR        N:TOSActivateTask
   \   000B                  REQUIRE ?CL78K_V4_6_L00
   1143          }
   1144          
   1145          //==============================================================================
   1146          // DESCRIPTION : DAT_EEP task
   1147          //
   1148          // PARAMETERS (Type,Name,Min,Max) :   none
   1149          //
   1150          // RETURN VALUE :   none
   1151          //
   1152          // DESIGN INFORMATION : 
   1153          //==============================================================================

   \                                 In  segment CODE, align 1, keep-with-next
   1154          void DATEepTask(void)
   \                     DATEepTask:
   1155          {
   \   0000                  ; * Stack frame (at entry) *
   \   0000                  ; Param size: 0
   \   0000                  ; Total Auto size: 0
   1156              if( ActiveProcessHandle != cInvalidProcessHandle )
   \   0000   8E....         MOV       A,ActiveProcessHandle
   \   0003   4DFF           CMP       A,#255
   \   0005   AD03           BZ        ??DATEepIsProcessing_39
   1157              {
   1158                  CommandStateMachine();
   \   0007   9B....         BR        N:CommandStateMachine
   1159              }
   1160              else
   1161              {
   1162                  ScheduleProcess();
   \                     ??DATEepIsProcessing_39:
   \   000A   9B....         BR        N:ScheduleProcess
   \   000D                  REQUIRE ?CL78K_V4_6_L00
   1163              }
   1164          }
   1165          
   1166          //==============================================================================
   1167          // DESCRIPTION : Initialize DAT_EEP
   1168          //
   1169          // PARAMETERS (Type,Name,Min,Max) :   none
   1170          //
   1171          // RETURN VALUE :   none
   1172          //
   1173          // DESIGN INFORMATION : 
   1174          //==============================================================================

   \                                 In  segment CODE, align 1, keep-with-next
   1175          void DATEepInit(void)
   \                     DATEepInit:
   1176          {
   \   0000                  ; * Stack frame (at entry) *
   \   0000                  ; Param size: 0
   \   0000                  ; Total Auto size: 0
   1177              ActiveProcessList = 0;
   \   0000   100000         MOVW      AX,#0
   \   0003   03....         MOVW      ActiveProcessList,AX
   1178              State = cStateReady;
   \   0006   9E....         MOV       State,A
   1179              ActiveProcessHandle = cInvalidProcessHandle;
   \   0009   A1FF           MOV       A,#255
   \   000B   9E....         MOV       ActiveProcessHandle,A
   1180              CommandState = cCommandStateFree;
   \   000E   A100           MOV       A,#0
   \   0010   9E....         MOV       CommandState,A
   1181              Alarm.TaskID = cTOSTaskIdDATEepTask;
   \   0013   80             INCW      AX
   \   0014   03....         MOVW      Alarm,AX
   1182          }
   \   0017   AF             RET       
   \   0018                  REQUIRE ?CL78K_V4_6_L00
   1183          
   1184          //==============================================================================
   1185          // DESCRIPTION : Sends the MaintainActiveSleep signal unless DAT_EEP is inactive
   1186          //
   1187          // PARAMETERS (Type,Name,Min,Max) :   none
   1188          //
   1189          // RETURN VALUE :   none
   1190          //
   1191          // DESIGN INFORMATION : 
   1192          //==============================================================================

   \                                 In  segment CODE, align 1, keep-with-next
   1193          void DATEepIsMaintainActiveSleepState( void )
   \                     DATEepIsMaintainActiveSleepState:
   1194          {
   \   0000                  ; * Stack frame (at entry) *
   \   0000                  ; Param size: 0
   \   0000                  ; Total Auto size: 0
   1195              BOOL IsProcessing = (BOOL) DATEepIsProcessing();
   \   0000   8E....         MOV       A,ActiveProcessHandle
   \   0003   4DFF           CMP       A,#255
   \   0005   AD05           BZ        ??DATEepIsProcessing_40
   1196          
   1197              if( IsProcessing != cFalse )
   1198              {
   1199                  TOSWriteSignal(cTOSSignalSomebodyMaintainActiveSleepState);
   \                     ??DATEepIsMaintainActiveSleepState_0:
   \   0007   102800         MOVW      AX,#40
   \   000A   ..             CALLT     [__T_TOSWriteSignal]
   \   000B   AF             RET       
   1200              }
   \                     ??DATEepIsProcessing_40:
   \   000C   02....         MOVW      AX,ActiveProcessList
   \   000F   6168           OR        A,X
   \   0011   BDF4           BNZ       ??DATEepIsMaintainActiveSleepState_0
   1201          }
   \   0013   AF             RET       
   \   0014                  REQUIRE ?CL78K_V4_6_L00
   1202          
   1203          
   1204          //==============================================================================
   1205          // DESCRIPTION : Checks if any process is pending or active
   1206          //
   1207          // PARAMETERS (Type,Name,Min,Max) :   none
   1208          //
   1209          // RETURN VALUE :   none
   1210          //
   1211          // DESIGN INFORMATION : 
   1212          //==============================================================================
   1213          

   \                                 In  segment CODE, align 1, keep-with-next
   1214          BOOL DATEepIsProcessing(void)
   \                     DATEepIsProcessing:
   1215          {
   \   0000                  ; * Stack frame (at entry) *
   \   0000                  ; Param size: 0
   \   0000                  ; Total Auto size: 0
   1216              BOOL IsProcessingReturn;
   1217          
   1218              if (ActiveProcessHandle != cInvalidProcessHandle)
   \   0000   8E....         MOV       A,ActiveProcessHandle
   \   0003   4DFF           CMP       A,#255
   \   0005   AD03           BZ        ??DATEepIsProcessing_41
   1219              {
   1220                  // A process is active
   1221                  IsProcessingReturn = cTrue;
   \                     ??DATEepIsProcessing_42:
   \   0007   A101           MOV       A,#1
   \   0009   AF             RET       
   1222              }
   1223              else if (!(ActiveProcessList == (tActiveProcessList)0))
   \                     ??DATEepIsProcessing_41:
   \   000A   02....         MOVW      AX,ActiveProcessList
   \   000D   6168           OR        A,X
   \   000F   BDF6           BNZ       ??DATEepIsProcessing_42
   1224              {
   1225                  // A process has requested activity but is not schedulled yed
   1226                  IsProcessingReturn = cTrue;
   1227              }
   1228              else
   1229              {
   1230                  // This block erradicates a QAC warning
   1231                  IsProcessingReturn = cFalse;
   \   0011   A100           MOV       A,#0
   1232              }
   1233          
   1234              return IsProcessingReturn;
   \   0013   AF             RET       
   \   0014                  REQUIRE ?CL78K_V4_6_L00
   1235          }

   \                                 In  segment CLTVEC, align 2
   \                     __T_TOSStartTimer:
   \   0000   ....           DW       TOSStartTimer

   \                                 In  segment CLTVEC, align 2
   \                     __T_?FAR_CALL_L07:
   \   0000   ....           DW       ?FAR_CALL_L07

   \                                 In  segment CLTVEC, align 2
   \                     __T_TOSIsTimerElapsed:
   \   0000   ....           DW       TOSIsTimerElapsed

   \                                 In  segment CLTVEC, align 2
   \                     __T_TOSSendControl:
   \   0000   ....           DW       TOSSendControl

   \                                 In  segment CLTVEC, align 2
   \                     __T_?I_LSH_L02:
   \   0000   ....           DW       ?I_LSH_L02

   \                                 In  segment CLTVEC, align 2
   \                     __T_TOSWriteSignal:
   \   0000   ....           DW       TOSWriteSignal
   1236          
   1237          

   Segment part sizes:

     Function/Label                 Bytes
     --------------                 -----
     ActiveProcessHandle               1
     ActiveProcessList                 2
     State                             1
     WriteRetryCounter                 1
     ReadBuffer                        2
     UserBuffer                        2
     OffsetFromUserBuffer              1
     LastOffset                        1
     CommandState                      1
     Command                           8
     CommandTempo                      2
     Alarm                             4
     BlocList                         44
     CallBackList                      6
     DATEepBuffer                     78
     StartCommand                    103
     EndOfCommand                    457
     CommandStateMachine             141
     ScheduleProcess                 118
     DATEepProcessRequest             38
     DATEepIsActivate                 35
     DATEepTerminateProcess           25
     DATEepRead                       77
     DATEepWrite                     127
     DATEepCompare                    83
     DATEepAbsoluteRead               51
     DATEepAbsoluteWrite              75
     DATEepCallBackEndCtrl            16
     DATEepCallBackTxWithAddr         11
     DATEepCallBackRxWithAddr         11
     DATEepTask                       13
     DATEepInit                       24
     DATEepIsMaintainActiveSleepState
                                      20
     DATEepIsProcessing               20
     __T_TOSStartTimer                 2
     __T_?FAR_CALL_L07                 2
     __T_TOSIsTimerElapsed             2
     __T_TOSSendControl                2
     __T_?I_LSH_L02                    2
     __T_TOSWriteSignal                2

 
    12 bytes in segment CLTVEC
 1 445 bytes in segment CODE
    50 bytes in segment CONST
   104 bytes in segment NEAR_Z
 
 1 445 bytes of CODE  memory (+ 12 bytes shared)
    50 bytes of CONST memory
   104 bytes of DATA  memory

Errors: none
Warnings: none
