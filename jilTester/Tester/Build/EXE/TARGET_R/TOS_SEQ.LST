###############################################################################
#                                                                             #
# IAR C/C++ Compiler V4.61A/W32 for 78K0 and 78K0S      15/Feb/2011  13:26:05 #
# Copyright 1992-2008 IAR Systems AB.                                         #
#                                                                             #
#    Core         =  78k0                                                     #
#    Code model   =  Standard                                                 #
#                 =                                                           #
#    Source file  =  D:\X90_BCM\DEVELOPMENT\X90_BCM\K0\L7\BUILD\SOURCES\TOS\T #
#                    OS_SEQ.C                                                 #
#    Command line =  --code_model standard --core 78k0 -e                     #
#                    -DMEM_TYPE=__banked -DMEM_FAST=__saddr                   #
#                    -DCALLT_TYPE=__callt -DX90_PROJECT                       #
#                    --generate_callt_runtime_library_calls -Ohs              #
#                    "-IC:\Program Files\IAR Systems\Embedded Workbench       #
#                    5.0\78k\inc" "-IC:\Program Files\IAR Systems\Embedded    #
#                    Workbench 5.0\78k\inc\clib" -I. -I..\EXE\GEN\            #
#                    -I..\SOURCES\DAT -I..\SOURCES\LAP -I..\SOURCES\LDB_API   #
#                    -I..\SOURCES\LIB -I..\SOURCES\TOS -I.\LDB -DROM          #
#                    -DUSE_LIBSTK -DDONT_KEEP_OLD_TYPE_COMPATIBILITY -l       #
#                    ..\EXE\TARGET_R\TOS_SEQ.LST -o                           #
#                    ..\EXE\TARGET_R\TOS_SEQ.R26                              #
#                    D:\X90_BCM\DEVELOPMENT\X90_BCM\K0\L7\BUILD\SOURCES\TOS\T #
#                    OS_SEQ.C                                                 #
#    List file    =  ..\EXE\TARGET_R\TOS_SEQ.LST                              #
#    Object file  =  ..\EXE\TARGET_R\TOS_SEQ.R26                              #
#                                                                             #
#                                                                             #
###############################################################################

D:\X90_BCM\DEVELOPMENT\X90_BCM\K0\L7\BUILD\SOURCES\TOS\TOS_SEQ.C
      1          //******************************************************************************
      2          // Company:      Johnson Controls Inc.
      3          // -----------------------------------------------------------------------------
      4          // Copyright:    This software is JCI property.
      5          //               Duplication or disclosure without JCI written authorization
      6          //               is prohibited.
      7          // -----------------------------------------------------------------------------
      8          // Project:      STK
      9          // Language:     ANSI-C
     10          // -----------------------------------------------------------------------------
     11          // Component:    TOS_SEQ
     12          //               The graph engine management
     13          // -----------------------------------------------------------------------------
     14          // $Date:   Sep 17 2009 10:27:10  $
     15          // $Archive:   J:/_PVCSRoot/Renault/X90_BCM/SOFTWARE/PVCS/archives/DEVELOPMENT/EXT_CMP/CPP_CMP/STK/SOURCES/TOS_SEQ.C-arc  $
     16          // $Revision:   1.1  $
     17          // -----------------------------------------------------------------------------
     18          /* $Log::   J:/_PVCSRoot/Renault/X90_BCM/SOFTWARE/PVCS/archives/DEVELOPMENT/EXT_CMP/CPP_CMP/STK/SOURCES/TOS_SEQ.C-arc  $
     19          // 
     20          //    Rev 1.1   Sep 17 2009 10:27:10   adzhelp
     21          // Cm003277: Functions defined as CALLT_TYPE
     22          // 
     23          //    Rev 1.0   04 Feb 2009 17:03:06   adzhelp
     24          // Initial revision.
     25          */
     26          //******************************************************************************
     27          
     28          //------------------------------------------------------------------------------
     29          // Body Identification
     30          //------------------------------------------------------------------------------
     31          #define TOS_SEQ "TOS_SEQ"
     32          
     33          //------------------------------------------------------------------------------
     34          // Included files to resolve specific definitions in this file
     35          //------------------------------------------------------------------------------
     36          #include "tos_seq.h"
     37          #include "tos_ord.h"
     38          #include "lib.h"
     39          #ifdef COMPILATION_NATIVE
     40            #include <windows.h>
     41            #include <winbase.h>
     42          #endif
     43          
     44          //------------------------------------------------------------------------------
     45          // Local constants
     46          //------------------------------------------------------------------------------
     47          
     48          //------------------------------------------------------------------------------
     49          // Local macros
     50          //------------------------------------------------------------------------------
     51          #ifdef COMPILATION_NATIVE
     52              #define mDbgInit() DbgInit()
     53          
     54              #define mDbgSeqMotor()\
     55                  if( pfDbgSeqMotor!=NULL) pfDbgSeqMotor()
     56          
     57              #define mDbgActivateGraph(ID)                   \
     58                  if(pfDbgActivateGraph!=NULL)                \
     59                  {                                           \
     60                      if( pfDbgActivateGraph(ID) )            \
     61                      {                                       \
     62                          DbgDebugBreak();                    \
     63                      }                                       \
     64                  }
     65          
     66              #define mDbgDeactivateGraph(ID)                 \
     67                  if(pfDbgDeactivateGraph!=NULL)              \
     68                  {                                           \
     69                      if( pfDbgDeactivateGraph(ID) )          \
     70                      {                                       \
     71                          DbgDebugBreak();                    \
     72                      }                                       \
     73                  }
     74          
     75              #define mDbgFreezeGraph(ID)                     \
     76                  if(pfDbgFreezeGraph!=NULL)                  \
     77                  {                                           \
     78                      if( pfDbgFreezeGraph(ID) )              \
     79                      {                                       \
     80                          DbgDebugBreak();                    \
     81                      }                                       \
     82                  }
     83          
     84              #define mDbgUnfreezeGraph(ID)                   \
     85                  if(pfDbgUnfreezeGraph!=NULL)                \
     86                  {                                           \
     87                      if( pfDbgUnfreezeGraph(ID) )            \
     88                      {                                       \
     89                          DbgDebugBreak();                    \
     90                      }                                       \
     91                  }
     92          
     93              #define mDbgChangeGrapheRule(ID,Rule)           \
     94                  if(pfDbgChangeGrapheRule!=NULL)             \
     95                  {                                           \
     96                      if( pfDbgChangeGrapheRule(ID,Rule) )    \
     97                      {                                       \
     98                          DbgDebugBreak();                    \
     99                      }                                       \
    100                  }
    101          #elif defined (_QAC_)
    102          extern void NOP(void);
    103              #define mDbgInit()                          NOP()
    104              #define mDbgSeqMotor()                      NOP()
    105              #define mDbgActivateGraph(ID)               NOP()
    106              #define mDbgDeactivateGraph(ID)             NOP()
    107              #define mDbgFreezeGraph(ID)                 NOP()
    108              #define mDbgUnfreezeGraph(ID)               NOP()
    109              #define mDbgChangeGrapheRule(ID,Rule)       NOP()
    110          #else
    111              #define mDbgInit()
    112              #define mDbgSeqMotor()
    113              #define mDbgActivateGraph(ID)
    114              #define mDbgDeactivateGraph(ID)
    115              #define mDbgFreezeGraph(ID)
    116              #define mDbgUnfreezeGraph(ID)
    117              #define mDbgChangeGrapheRule(ID,Rule)
    118          #endif
    119          
    120          //------------------------------------------------------------------------------
    121          // Local types
    122          //------------------------------------------------------------------------------
    123          
    124          // -----------------------------------------------------------------------------
    125          // Local data
    126          //------------------------------------------------------------------------------
    127          #ifdef COMPILATION_NATIVE
    128          BOOL  (*pfDbgInit)(U32 u32NbGr,const tTOSSeqGraphListType*);
    129          void  (*pfDbgSeqMotor)(void);
    130          BOOL  (*pfDbgActivateGraph)(U32 u32ID);
    131          BOOL  (*pfDbgDeactivateGraph)(U32 u32ID);
    132          BOOL  (*pfDbgFreezeGraph)(U32 u32ID);
    133          BOOL  (*pfDbgUnfreezeGraph)(U32 u32ID);
    134          BOOL  (*pfDbgChangeGrapheRule)(U32 u32ID,U32 u32Rule);
    135          HINSTANCE hDbgGraphDll = NULL;
    136          #endif
    137          

   \                                 In  segment NEAR_Z, align 1, align-sorted
    138          static tTOSSeqGraphContextType TOSSeqGraphContext[cTOSSeqGraphNumber];
   \                     TOSSeqGraphContext:
   \   0000                  DS 94
   \   005E                  REQUIRE __INIT_NEAR_Z
    139          
    140          //------------------------------------------------------------------------------
    141          // Constant local data
    142          //------------------------------------------------------------------------------
    143          
    144          //------------------------------------------------------------------------------
    145          // Exported data
    146          //------------------------------------------------------------------------------

   \                                 In  segment NEAR_Z, align 1, align-sorted
    147          tTOSSeqGraphId TOSSeqGraphNumber;
   \                     TOSSeqGraphNumber:
   \   0000                  DS 1
   \   0001                  REQUIRE __INIT_NEAR_Z
    148          
    149          //------------------------------------------------------------------------------
    150          // Constant exported data
    151          //------------------------------------------------------------------------------
    152          
    153          //------------------------------------------------------------------------------
    154          // Local function prototypes
    155          //------------------------------------------------------------------------------
    156          #ifdef COMPILATION_NATIVE
    157          //==============================================================================
    158          // DESCRIPTION:         Initializes the debug mode in COMPILATION_NATIVE
    159          //
    160          // PARAMETERS:          None
    161          //
    162          // RETURN VALUE:        None
    163          //
    164          // DESIGN INFORMATION:  Initializes the debug variables.
    165          //                      Refer to Detailed Design Document
    166          //==============================================================================
    167          static void DbgInit(void);
    168          
    169          //==============================================================================
    170          // DESCRIPTION:         Avoids masking of the last function by the debugbreak 
    171          //                      execution.
    172          //
    173          // PARAMETERS:          None
    174          //
    175          // RETURN VALUE:        None
    176          //
    177          // DESIGN INFORMATION:  Calls debugbreak function.
    178          //                      Refer to Detailed Design Document
    179          //==============================================================================
    180          static void DbgDebugBreak(void);
    181          #endif
    182          
    183          //==============================================================================
    184          // DESCRIPTION:         Tests all sister's transitions of the graph and executes
    185          //                      corresponding actions.
    186          //
    187          // PARAMETERS:          None
    188          //
    189          // RETURN VALUE:        None
    190          //
    191          // DESIGN INFORMATION:  Tests all sister's transitions of the current graph one
    192          //                      after the other. When one returns TRUE executes the
    193          //                      corresponding action and stops testing the other sister's
    194          //                      rules. If there is no daughter's rule, deactivates the graph.
    195          //                      Refer to Detailed Design Document
    196          //==============================================================================
    197          static void ScanGraph(void);
    198          
    199          //==============================================================================
    200          //=========================== LOCAL FUNCTIONS ==================================
    201          //==============================================================================
    202          
    203          #ifdef COMPILATION_NATIVE
    204          static void DbgInit(void)
    205          {
    206              if( hDbgGraphDll == NULL )
    207              {
    208                  hDbgGraphDll = LoadLibrary("DBGSEQ.DLL");
    209              }
    210          
    211              if ( hDbgGraphDll != NULL )
    212              {
    213                  pfDbgInit = (void*)GetProcAddress(hDbgGraphDll, "DbgInit");
    214          
    215                  if( pfDbgInit != NULL )
    216                  {
    217                      if( pfDbgInit(cTOSSeqGraphNumber, &TOSSeqGraphList) )
    218                      {
    219                          pfDbgSeqMotor         = (void*)GetProcAddress(hDbgGraphDll, "DbgSeqMoteur");
    220                          pfDbgActivateGraph    = (void*)GetProcAddress(hDbgGraphDll, "DbgActiverGraphe");
    221                          pfDbgDeactivateGraph  = (void*)GetProcAddress(hDbgGraphDll, "DbgDesactiverGraphe");
    222                          pfDbgFreezeGraph       = (void*)GetProcAddress(hDbgGraphDll, "DbgGelerGraphe");
    223                          pfDbgUnfreezeGraph     = (void*)GetProcAddress(hDbgGraphDll, "DbgDegelerGraphe");
    224                          pfDbgChangeGrapheRule = (void*)GetProcAddress(hDbgGraphDll, "DbgChangerRegleGraphe");
    225                      }
    226                      else
    227                      {
    228                          pfDbgInit = NULL;
    229                      }
    230                  }
    231              }
    232              else
    233              {
    234                  pfDbgInit               = NULL;
    235                  pfDbgSeqMotor           = NULL;
    236                  pfDbgActivateGraph      = NULL;
    237                  pfDbgDeactivateGraph    = NULL;
    238                  pfDbgFreezeGraph        = NULL;
    239                  pfDbgUnfreezeGraph      = NULL;
    240                  pfDbgChangeGrapheRule   = NULL;
    241              }
    242          }
    243          
    244          static void DbgDebugBreak(void)
    245          {
    246              DebugBreak();
    247          }
    248          #endif
    249          

   \                                 In  segment CODE, align 1, keep-with-next
    250          static void ScanGraph(void)
   \                     ScanGraph:
    251          {
   \   0000                  ; * Stack frame (at entry) *
   \   0000                  ; Param size: 0
   \   0000   B3             PUSH      BC
   \   0001   B5             PUSH      DE
   \   0002                  ; Total Auto size: 0
    252              const tTOSSeqRuleType* pRule;
    253          #ifdef COMPILATION_NATIVE         // For debug mode, save the rule number
    254              tTOSSeqRuleId RuleNumber;
    255          #endif
    256          
    257              mLIBassert(TOSSeqGraphNumber < cTOSSeqGraphNumber);
    258          
    259          #ifdef COMPILATION_NATIVE
    260              RuleNumber = TOSSeqGraphContext[TOSSeqGraphNumber].RuleNumber;
    261              pRule = TOSSeqGraphList[TOSSeqGraphNumber]->Rules
    262                      + TOSSeqGraphContext[TOSSeqGraphNumber].RuleNumber;
    263          #else
    264              pRule = *TOSSeqGraphList[TOSSeqGraphNumber]
    265                      + TOSSeqGraphContext[TOSSeqGraphNumber].RuleNumber;
   \   0002   8E....         MOV       A,TOSSeqGraphNumber
   \   0005   A002           MOV       X,#2
   \   0007   3188           MULU      X
   \   0009   CA....         ADDW      AX,#TOSSeqGraphContext+1
   \   000C   D6             MOVW      HL,AX
   \   000D   87             MOV       A,[HL]
   \   000E   A006           MOV       X,#6
   \   0010   3188           MULU      X
   \   0012   D4             MOVW      DE,AX
   \   0013   8E....         MOV       A,TOSSeqGraphNumber
   \   0016   A002           MOV       X,#2
   \   0018   3188           MULU      X
   \   001A   CA....         ADDW      AX,#TOSSeqGraphList
   \   001D   D6             MOVW      HL,AX
   \   001E   87             MOV       A,[HL]
   \   001F   70             MOV       X,A
   \   0020   AE01           MOV       A,[HL+0x01]
   \   0022   E4             XCHW      AX,DE
   \   0023   30             XCH       A,X
   \   0024   610C           ADD       A,E
   \   0026   30             XCH       A,X
   \   0027   612D           ADDC      A,D
   \   0029   D4             MOVW      DE,AX
    266          #endif
    267              do
    268              {
    269                  if ((*pRule->pTransition)() != cFalse)
   \                     ??ScanGraph_0:
   \   002A   C4             MOVW      AX,DE
   \   002B   D6             MOVW      HL,AX
   \   002C   87             MOV       A,[HL]
   \   002D   70             MOV       X,A
   \   002E   AE01           MOV       A,[HL+0x01]
   \   0030   D6             MOVW      HL,AX
   \   0031   9A....         CALL      ?IND_CALL_L06
   \   0034   4D00           CMP       A,#0
   \   0036   AD45           BZ        ??TOSSeqMotor_0
    270                  {
    271          #ifdef COMPILATION_NATIVE
    272                      mDbgChangeGrapheRule(TOSSeqGraphNumber,RuleNumber);
    273                      // When GraphDesigner break the application, you are in the DLL
    274                      // For exit to the DLL, place a breakpoint in front of (*ptRegle->ptAction)();
    275                      // and continue the application by 'F5' key press.
    276                      // Now you can debug your application just before execute the action.
    277          #endif
    278                      (*pRule->pAction)();
   \   0038   C4             MOVW      AX,DE
   \   0039   D6             MOVW      HL,AX
   \   003A   AE02           MOV       A,[HL+0x02]
   \   003C   70             MOV       X,A
   \   003D   AE03           MOV       A,[HL+0x03]
   \   003F   D6             MOVW      HL,AX
   \   0040   9A....         CALL      ?IND_CALL_L06
    279          
    280                      if (pRule->DaughterRuleNumber != cTOSSeqInvalidRule)
   \   0043   B5             PUSH      DE
   \   0044   B6             POP       HL
   \   0045   AE05           MOV       A,[HL+0x05]
   \   0047   41             INC       A
   \   0048   AD15           BZ        ??TOSSeqMotor_1
    281                      {
    282                          TOSSeqGraphContext[TOSSeqGraphNumber].RuleNumber = pRule->DaughterRuleNumber;
   \   004A   84             INCW      DE
   \   004B   84             INCW      DE
   \   004C   84             INCW      DE
   \   004D   84             INCW      DE
   \   004E   84             INCW      DE
   \   004F   85             MOV       A,[DE]
   \   0050   72             MOV       C,A
   \   0051   8E....         MOV       A,TOSSeqGraphNumber
   \   0054   A002           MOV       X,#2
   \   0056   3188           MULU      X
   \   0058   CA....         ADDW      AX,#TOSSeqGraphContext+1
   \   005B   D6             MOVW      HL,AX
   \   005C   62             MOV       A,C
   \   005D   FA1B           BR        ??TOSSeqMotor_2
    283                      }
    284                      else    // End of graph
    285                      {
    286                          mDbgDeactivateGraph(TOSSeqGraphNumber);
    287                          TOSSeqGraphContext[TOSSeqGraphNumber].GraphState  = cTOSSeqInactiveGraph;
   \                     ??TOSSeqMotor_1:
   \   005F   8E....         MOV       A,TOSSeqGraphNumber
   \   0062   A002           MOV       X,#2
   \   0064   3188           MULU      X
   \   0066   CA....         ADDW      AX,#TOSSeqGraphContext
   \   0069   D6             MOVW      HL,AX
   \   006A   A100           MOV       A,#0
   \   006C   97             MOV       [HL],A
    288                          TOSSeqGraphContext[TOSSeqGraphNumber].RuleNumber  = 0 ;
   \   006D   8E....         MOV       A,TOSSeqGraphNumber
   \   0070   A002           MOV       X,#2
   \   0072   3188           MULU      X
   \   0074   CA....         ADDW      AX,#TOSSeqGraphContext+1
   \   0077   D6             MOVW      HL,AX
   \   0078   A100           MOV       A,#0
   \                     ??TOSSeqMotor_2:
   \   007A   97             MOV       [HL],A
    289                      }
    290                      pRule = NULL;     // Condition for exit loop
   \   007B   FA2C           BR        ??TOSSeqMotor_3
    291                  }
    292                  else if ( pRule->SisterRuleNumber != cTOSSeqInvalidRule )
   \                     ??TOSSeqMotor_0:
   \   007D   B5             PUSH      DE
   \   007E   B6             POP       HL
   \   007F   AE04           MOV       A,[HL+0x04]
   \   0081   41             INC       A
   \   0082   AD25           BZ        ??TOSSeqMotor_3
    293                  {
    294          #ifdef COMPILATION_NATIVE                   // For debug mode, save the rule number
    295                      RuleNumber = pRule->SisterRuleNumber;
    296                      pRule = TOSSeqGraphList[TOSSeqGraphNumber]->Rules
    297                              + pRule->SisterRuleNumber;
    298          #else
    299                      pRule = *TOSSeqGraphList[TOSSeqGraphNumber]
    300                              + pRule->SisterRuleNumber;
   \   0084   84             INCW      DE
   \   0085   84             INCW      DE
   \   0086   84             INCW      DE
   \   0087   84             INCW      DE
   \   0088   85             MOV       A,[DE]
   \   0089   A006           MOV       X,#6
   \   008B   3188           MULU      X
   \   008D   D4             MOVW      DE,AX
   \   008E   8E....         MOV       A,TOSSeqGraphNumber
   \   0091   A002           MOV       X,#2
   \   0093   3188           MULU      X
   \   0095   CA....         ADDW      AX,#TOSSeqGraphList
   \   0098   D6             MOVW      HL,AX
   \   0099   87             MOV       A,[HL]
   \   009A   70             MOV       X,A
   \   009B   AE01           MOV       A,[HL+0x01]
   \   009D   E4             XCHW      AX,DE
   \   009E   30             XCH       A,X
   \   009F   610C           ADD       A,E
   \   00A1   30             XCH       A,X
   \   00A2   612D           ADDC      A,D
   \   00A4   D4             MOVW      DE,AX
    301          #endif
    302                  }
    303                  else
    304                  {
    305                      pRule = NULL;
    306                  }
    307              }
    308              while(pRule != NULL);
   \   00A5   6168           OR        A,X
   \   00A7   BD81           BNZ       ??ScanGraph_0
    309          }
   \                     ??TOSSeqMotor_3:
   \   00A9   B4             POP       DE
   \   00AA   B2             POP       BC
   \   00AB   AF             RET       
   \   00AC                  REQUIRE ?CL78K_V4_6_L00
    310          
    311          //==============================================================================
    312          //=========================== EXPORTED FUNCTIONS ===============================
    313          //==============================================================================
    314          
    315          //==============================================================================
    316          // DESCRIPTION:         See component header file
    317          //==============================================================================

   \                                 In  segment CODE, align 1, keep-with-next
    318          void TOSSeqInitialize(void)
   \                     TOSSeqInitialize:
    319          {
   \   0000                  ; * Stack frame (at entry) *
   \   0000                  ; Param size: 0
   \   0000   B5             PUSH      DE
   \   0001                  ; Total Auto size: 0
    320              tTOSSeqGraphId GraphNumber;
    321          
    322              mLIBassert(cTOSSeqGraphNumber > 0);
    323          
    324              mDbgInit();
    325          
    326              for (GraphNumber = 0;GraphNumber < cTOSSeqGraphNumber; GraphNumber++)
   \   0001   16....         MOVW      HL,#TOSSeqGraphContext
   \   0004   A02F           MOV       X,#47
    327              {
    328                  TOSSeqGraphContext[GraphNumber].GraphState = cTOSSeqInactiveGraph;
   \                     ??TOSSeqInitialize_0:
   \   0006   A100           MOV       A,#0
   \   0008   97             MOV       [HL],A
    329                  TOSSeqGraphContext[GraphNumber].RuleNumber = 0 ;
   \   0009   B7             PUSH      HL
   \   000A   B4             POP       DE
   \   000B   84             INCW      DE
   \   000C   95             MOV       [DE],A
    330              }
   \   000D   86             INCW      HL
   \   000E   86             INCW      HL
   \   000F   50             DEC       X
   \   0010   BDF4           BNZ       ??TOSSeqInitialize_0
    331          }
   \   0012   B4             POP       DE
   \   0013   AF             RET       
   \   0014                  REQUIRE ?CL78K_V4_6_L00
    332          
    333          //==============================================================================
    334          // DESCRIPTION:         See component header file
    335          //==============================================================================

   \                                 In  segment CODE, align 1, keep-with-next
    336          CALLT_TYPE void TOSSeqActivateGraph(const tTOSSeqGraphId GraphNumber)
   \                     TOSSeqActivateGraph:
    337          {
   \   0000                  ; * Stack frame (at entry) *
   \   0000                  ; Param size: 0
   \   0000   B3             PUSH      BC
   \   0001                  ; Total Auto size: 0
    338              mLIBassert(GraphNumber < cTOSSeqGraphNumber);
    339              mLIBassert(TOSSeqGraphContext[GraphNumber].GraphState == cTOSSeqInactiveGraph);
    340          
    341              mDbgActivateGraph(GraphNumber);
    342              TOSSeqGraphContext[GraphNumber].GraphState = cTOSSeqActiveGraph;
   \   0001   A002           MOV       X,#2
   \   0003   3188           MULU      X
   \   0005   CA....         ADDW      AX,#TOSSeqGraphContext
   \   0008   D6             MOVW      HL,AX
   \   0009   A101           MOV       A,#1
   \   000B   97             MOV       [HL],A
    343              TOSSeqGraphContext[GraphNumber].RuleNumber = 0;
   \   000C   A100           MOV       A,#0
   \   000E   86             INCW      HL
   \   000F   97             MOV       [HL],A
    344          }
   \   0010   B2             POP       BC
   \   0011   AF             RET       
   \   0012                  REQUIRE ?CL78K_V4_6_L00
    345          
    346          //==============================================================================
    347          // DESCRIPTION:         See component header file
    348          //==============================================================================

   \                                 In  segment CODE, align 1, keep-with-next
    349          CALLT_TYPE void TOSSeqDeactivateGraph(const tTOSSeqGraphId GraphNumber)
   \                     TOSSeqDeactivateGraph:
    350          {
   \   0000                  ; * Stack frame (at entry) *
   \   0000                  ; Param size: 0
   \   0000                  ; Total Auto size: 0
    351              mLIBassert(GraphNumber < cTOSSeqGraphNumber);
    352              // If graph is already deactivated, it is not a fault
    353              //  mLIBassert(TOSSeqGraphContext[GraphNumber].GraphState != cTOSSeqInactiveGraph);
    354          
    355              mDbgDeactivateGraph(GraphNumber);
    356              TOSSeqGraphContext[GraphNumber].GraphState = cTOSSeqInactiveGraph;
   \   0000   A002           MOV       X,#2
   \   0002   3188           MULU      X
   \   0004   CA....         ADDW      AX,#TOSSeqGraphContext
   \   0007   D6             MOVW      HL,AX
   \   0008   A100           MOV       A,#0
   \   000A   97             MOV       [HL],A
    357          }
   \   000B   AF             RET       
   \   000C                  REQUIRE ?CL78K_V4_6_L00
    358          
    359          //==============================================================================
    360          // DESCRIPTION:         See component header file
    361          //==============================================================================

   \                                 In  segment CODE, align 1, keep-with-next
    362          void TOSSeqFreezeGraph(const tTOSSeqGraphId GraphNumber)
   \                     TOSSeqFreezeGraph:
    363          {
   \   0000                  ; * Stack frame (at entry) *
   \   0000                  ; Param size: 0
   \   0000                  ; Total Auto size: 0
    364              mLIBassert(GraphNumber < cTOSSeqGraphNumber);
    365              mLIBassert(TOSSeqGraphContext[GraphNumber].GraphState == cTOSSeqActiveGraph);
    366          
    367              mDbgFreezeGraph(GraphNumber);
    368              TOSSeqGraphContext[GraphNumber].GraphState = cTOSSeqFrozenGraph;
   \   0000   A002           MOV       X,#2
   \   0002   3188           MULU      X
   \   0004   CA....         ADDW      AX,#TOSSeqGraphContext
   \   0007   D6             MOVW      HL,AX
   \   0008   A102           MOV       A,#2
   \   000A   97             MOV       [HL],A
    369          }
   \   000B   AF             RET       
   \   000C                  REQUIRE ?CL78K_V4_6_L00
    370          
    371          //==============================================================================
    372          // DESCRIPTION:         See component header file
    373          //==============================================================================

   \                                 In  segment CODE, align 1, keep-with-next
    374          void TOSSeqUnfreezeGraph(const tTOSSeqGraphId GraphNumber)
   \                     TOSSeqUnfreezeGraph:
    375          {
   \   0000                  ; * Stack frame (at entry) *
   \   0000                  ; Param size: 0
   \   0000                  ; Total Auto size: 0
    376              mLIBassert(GraphNumber < cTOSSeqGraphNumber);
    377              mLIBassert(TOSSeqGraphContext[GraphNumber].GraphState == cTOSSeqFrozenGraph);
    378          
    379              mDbgUnfreezeGraph(GraphNumber);
    380              TOSSeqGraphContext[GraphNumber].GraphState = cTOSSeqActiveGraph;
   \   0000   A002           MOV       X,#2
   \   0002   3188           MULU      X
   \   0004   CA....         ADDW      AX,#TOSSeqGraphContext
   \   0007   D6             MOVW      HL,AX
   \   0008   A101           MOV       A,#1
   \   000A   97             MOV       [HL],A
    381          }
   \   000B   AF             RET       
   \   000C                  REQUIRE ?CL78K_V4_6_L00
    382          
    383          //==============================================================================
    384          // DESCRIPTION:         See component header file
    385          //==============================================================================

   \                                 In  segment CODE, align 1, keep-with-next
    386          CALLT_TYPE tTOSSeqGraphStateType TOSSeqGraphState(const tTOSSeqGraphId GraphNumber)
   \                     TOSSeqGraphState:
    387          {
   \   0000                  ; * Stack frame (at entry) *
   \   0000                  ; Param size: 0
   \   0000                  ; Total Auto size: 0
    388              mLIBassert(GraphNumber < cTOSSeqGraphNumber);
    389          
    390              return (TOSSeqGraphContext[GraphNumber].GraphState);
   \   0000   A002           MOV       X,#2
   \   0002   3188           MULU      X
   \   0004   CA....         ADDW      AX,#TOSSeqGraphContext
   \   0007   D6             MOVW      HL,AX
   \   0008   87             MOV       A,[HL]
   \   0009   AF             RET       
   \   000A                  REQUIRE ?CL78K_V4_6_L00
    391          }
    392          
    393          //==============================================================================
    394          // DESCRIPTION:         See component header file
    395          //==============================================================================

   \                                 In  segment CODE, align 1, keep-with-next
    396          BOOL TOSSeqTrueEval(void)
   \                     TOSSeqTrueEval:
    397          {
   \   0000                  ; * Stack frame (at entry) *
   \   0000                  ; Param size: 0
   \   0000                  ; Total Auto size: 0
    398              // This function must always return true
    399              return (cTrue);
   \   0000   A101           MOV       A,#1
   \   0002   AF             RET       
   \   0003                  REQUIRE ?CL78K_V4_6_L00
    400          }
    401          
    402          //==============================================================================
    403          // DESCRIPTION:         See component header file
    404          //==============================================================================

   \                                 In  segment CODE, align 1, keep-with-next
    405          void TOSSeqNoAction(void)
   \                     TOSSeqNoAction:
    406          {
   \   0000                  ; * Stack frame (at entry) *
   \   0000                  ; Param size: 0
   \   0000                  ; Total Auto size: 0
    407              // This function must be always empty
    408          }
   \   0000   AF             RET       
   \   0001                  REQUIRE ?CL78K_V4_6_L00
    409          
    410          //==============================================================================
    411          // DESCRIPTION:         See component header file
    412          //==============================================================================

   \                                 In  segment CODE, align 1, keep-with-next
    413          void TOSSeqMotor(const tTOSSeqGraphId StartGraph,const tTOSSeqGraphId EndGraph)
   \                     TOSSeqMotor:
    414          {
   \   0000                  ; * Stack frame (at entry) *
   \   0000                  ; Param size: 0
   \   0000   B3             PUSH      BC
   \   0001                  ; Total Auto size: 0
   \   0001   70             MOV       X,A
    415              tTOSSeqGraphId OldGraphNumber;
    416          
    417              mLIBassert(EndGraph < cTOSSeqGraphNumber);
    418          
    419              mDbgSeqMotor();
    420          
    421              OldGraphNumber = TOSSeqGraphNumber;     // Save OldGraphNumber
   \   0002   8E....         MOV       A,TOSSeqGraphNumber
   \   0005   72             MOV       C,A
    422          
    423              // if no graph is activated -> simulation of a minimum time
    424              mLDBSimulateProcessingTime(cTOSSeqDureeTourGrapheSimulationNs/
    425                                         (cLDBTick*(cTOSSeqGraphNumber+1)));
    426          
    427              // It is possible because it is not possible to have 2 graph tasks with same priority
    428              for (TOSSeqGraphNumber = StartGraph; TOSSeqGraphNumber<= EndGraph; TOSSeqGraphNumber++)
   \   0006   60             MOV       A,X
   \   0007   9E....         MOV       TOSSeqGraphNumber,A
   \   000A   63             MOV       A,B
   \   000B   48....         CMP       A,TOSSeqGraphNumber
   \   000E   8D22           BC        ??TOSSeqMotor_4
    429              {
    430                  mLIBassert(TOSSeqGraphList[TOSSeqGraphNumber] != NULL);
    431          
    432                  if (TOSSeqGraphContext[TOSSeqGraphNumber].GraphState == cTOSSeqActiveGraph)
   \                     ??TOSSeqMotor_5:
   \   0010   8E....         MOV       A,TOSSeqGraphNumber
   \   0013   A002           MOV       X,#2
   \   0015   3188           MULU      X
   \   0017   CA....         ADDW      AX,#TOSSeqGraphContext
   \   001A   D6             MOVW      HL,AX
   \   001B   87             MOV       A,[HL]
   \   001C   51             DEC       A
   \   001D   BD06           BNZ       ??TOSSeqMotor_6
    433                  {
    434                      ScanGraph();
   \   001F   9A....         CALL      ScanGraph
    435          
    436                      // TosSeq Call this Macro for simulate the LDB component
    437                      // This macro is empty in the LDB embedded
    438                      mLDBSimulateProcessingTime(cTOSSeqDureeTourGrapheSimulationNs/
    439                                                 (cLDBTick*(cTOSSeqGraphNumber+1)));
    440          
    441                      // Call the scheduler for give the hand again
    442                      TOSSchedule();
   \   0022   9A....         CALL      TOSSchedule
    443                  }
    444              }
   \                     ??TOSSeqMotor_6:
   \   0025   8E....         MOV       A,TOSSeqGraphNumber
   \   0028   41             INC       A
   \   0029   9E....         MOV       TOSSeqGraphNumber,A
   \   002C   63             MOV       A,B
   \   002D   48....         CMP       A,TOSSeqGraphNumber
   \   0030   9DDE           BNC       ??TOSSeqMotor_5
    445          
    446              TOSSeqGraphNumber = OldGraphNumber;     // Restore OldGraphNumber
   \                     ??TOSSeqMotor_4:
   \   0032   62             MOV       A,C
   \   0033   9E....         MOV       TOSSeqGraphNumber,A
    447          }
   \   0036   B2             POP       BC
   \   0037   AF             RET       
   \   0038                  REQUIRE ?CL78K_V4_6_L00
    448          

   Segment part sizes:

     Function/Label        Bytes
     --------------        -----
     TOSSeqGraphContext      94
     TOSSeqGraphNumber        1
     ScanGraph              172
     TOSSeqInitialize        20
     TOSSeqActivateGraph     18
     TOSSeqDeactivateGraph   12
     TOSSeqFreezeGraph       12
     TOSSeqUnfreezeGraph     12
     TOSSeqGraphState        10
     TOSSeqTrueEval           3
     TOSSeqNoAction           1
     TOSSeqMotor             56

 
 316 bytes in segment CODE
  95 bytes in segment NEAR_Z
 
 316 bytes of CODE memory
  95 bytes of DATA memory

Errors: none
Warnings: none
