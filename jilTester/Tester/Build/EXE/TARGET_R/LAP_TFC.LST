###############################################################################
#                                                                             #
# IAR C/C++ Compiler V4.61A/W32 for 78K0 and 78K0S      15/Feb/2011  13:27:07 #
# Copyright 1992-2008 IAR Systems AB.                                         #
#                                                                             #
#    Core         =  78k0                                                     #
#    Code model   =  Standard                                                 #
#                 =                                                           #
#    Source file  =  D:\X90_BCM\DEVELOPMENT\X90_BCM\K0\L7\BUILD\SOURCES\LAP\L #
#                    AP_TFC.C                                                 #
#    Command line =  --code_model standard --core 78k0 -e                     #
#                    -DMEM_TYPE=__banked -DMEM_FAST=__saddr                   #
#                    -DCALLT_TYPE=__callt -DX90_PROJECT                       #
#                    --generate_callt_runtime_library_calls -Ohs              #
#                    "-IC:\Program Files\IAR Systems\Embedded Workbench       #
#                    5.0\78k\inc" "-IC:\Program Files\IAR Systems\Embedded    #
#                    Workbench 5.0\78k\inc\clib" -I. -I..\EXE\GEN\            #
#                    -I..\SOURCES\DAT -I..\SOURCES\LAP -I..\SOURCES\LDB_API   #
#                    -I..\SOURCES\LIB -I..\SOURCES\TOS -I.\LDB -DROM          #
#                    -DUSE_LIBSTK -DDONT_KEEP_OLD_TYPE_COMPATIBILITY -l       #
#                    ..\EXE\TARGET_R\LAP_TFC.LST -o                           #
#                    ..\EXE\TARGET_R\LAP_TFC.R26                              #
#                    D:\X90_BCM\DEVELOPMENT\X90_BCM\K0\L7\BUILD\SOURCES\LAP\L #
#                    AP_TFC.C                                                 #
#    List file    =  ..\EXE\TARGET_R\LAP_TFC.LST                              #
#    Object file  =  ..\EXE\TARGET_R\LAP_TFC.R26                              #
#                                                                             #
#                                                                             #
###############################################################################

D:\X90_BCM\DEVELOPMENT\X90_BCM\K0\L7\BUILD\SOURCES\LAP\LAP_TFC.C
      1          #ifndef _QAC_
      2          //******************************************************************************
      3          // Company:      Johnson Controls Inc.
      4          // -----------------------------------------------------------------------------
      5          // Copyright:    This software is JCI property.
      6          //               Duplication or disclosure without JCI written authorization
      7          //               is prohibited.
      8          // -----------------------------------------------------------------------------
      9          // Project:      X90_BCM
     10          // Language:     ANSI-C
     11          // -----------------------------------------------------------------------------
     12          // Component:    LAP_TFC
     13          // -----------------------------------------------------------------------------
     14          // $Date:   Jun 18 2010 08:42:12  $
     15          // $Archive:   J:/_PVCSRoot/Renault/X90_BCM/SOFTWARE/PVCS/archives/DEVELOPMENT/X90_BCM/K0/L7/CMP/LAP/LAP_TFC/LAP_TFC.C-arc  $
     16          // $Revision:   1.33  $
     17          // -----------------------------------------------------------------------------
     18          // $Log::   J:/_PVCSRoot/Renault/X90_BCM/SOFTWARE/PVCS/archives/DEVELOPMENT/X90_BCM/K0/L7/CMP/LAP/LAP_TFC/LAP_TFC.C-arc  $
     19          // 
     20          //    Rev 1.33   Jun 18 2010 08:42:12   adzhelp
     21          // Cm009329: Frequency for buzzer I/O Control changed from 4khz to 2.4khz
     22          // 
     23          //    Rev 1.32   Mar 24 2010 17:44:20   adzhelp
     24          // Cm007987: NRC when there is no bootloader
     25          // 
     26          //    Rev 1.31   Mar 24 2010 15:08:02   adzhelp
     27          // Cm007987: $21$91 is partly filled from lastest application logzone.
     28          // 
     29          //    Rev 1.30   Mar 12 2010 13:54:18   adzhelp
     30          // Cm007695: Code review corrections
     31          // 
     32          //    Rev 1.29   Mar 08 2010 14:52:26   adzhelp
     33          // Cm007695: Request for Clearing System+Counter faults
     34          // 
     35          //    Rev 1.28   Mar 01 2010 12:28:06   adzhelp
     36          // Cm006824: Response to 21 91 shortened by 2, request '3B 96 ...' shortened by 2
     37          // 
     38          //    Rev 1.27   Feb 19 2010 10:08:42   adzhelp
     39          // Cm007575: Notify DAT layer for sleep request
     40          // 
     41          //    Rev 1.26   Feb 04 2010 14:25:32   adzhelp
     42          // Cm007297: Implementation of SRBLID 'F0' for EEPROM reprogramming
     43          // 
     44          //    Rev 1.25   Jan 28 2010 12:02:22   adzhelp
     45          // Cm007261: MANU: Request $21$91 should read ECU Reference from Log Zone
     46          // 
     47          //    Rev 1.24   Dec 04 2009 16:57:34   adzhelp
     48          // Cm006719: Change number of RC blocks received to ones with correct CRC
     49          // 
     50          //    Rev 1.23   Nov 23 2009 10:26:38   akodzhh
     51          // Cm005566: AutoTest - set errors on outputs.
     52          // 
     53          //    Rev 1.22   Nov 20 2009 09:52:44   akodzhh
     54          // Cm006705: QAC - warnings resolved and justified.
     55          // 
     56          //    Rev 1.21   Nov 19 2009 12:51:56   akodzhh
     57          // Cm006705: AutoTest: fix check for matrix validity.
     58          // 
     59          //    Rev 1.20   Oct 06 2009 16:27:46   akodzhh
     60          // Cm006406:  EEP_FlaCoeffLTrailer, EEP_FlaCoeffRTrailer fix.
     61          // 
     62          //    Rev 1.19   Oct 06 2009 15:48:22   akodzhh
     63          // Cm006406: EEP_RenaultPartNumber, EEP_BCMHWLevel replaced; EEP_FlaCoeffLTrailer_trailer, EEP_FlaCoeffRTrailer removed.
     64          // 
     65          //    Rev 1.18   Oct 05 2009 16:38:04   akodzhh
     66          // Cm005803: Update SL test ECM - start conditions.
     67          // 
     68          //    Rev 1.17   Oct 01 2009 11:38:26   akodzhh
     69          // Cm006291: RF test updated - status request treatment SPEC: Cm006290.
     70          // 
     71          //    Rev 1.16   Sep 30 2009 13:43:56   akodzhh
     72          // Cm005803: Update SL test for Immobilizer start conditions and ECM - start and status request.
     73          // 
     74          //    Rev 1.15   Sep 23 2009 11:49:08   akodzhh
     75          // Cm006229: SRBID Eeprom Test - Checksum List updated according to Eep Version 02.00.
     76          // 
     77          //    Rev 1.14   Sep 23 2009 10:04:34   adzhelp
     78          // Cm005554: ROM Checksum location updated
     79          // 
     80          //    Rev 1.13   Sep 21 2009 16:06:14   akodzhh
     81          // Cm005756: TFC AutoTest timeouts adjusted.
     82          // 
     83          //    Rev 1.12   Aug 05 2009 14:29:10   akodzhh
     84          // Cm005796: Added '#3 Option byte' for RDBLI_AnalogValues request&response frames.
     85          // 
     86          //    Rev 1.11   Aug 05 2009 10:55:18   akodzhh
     87          // Cm005793: Response length for 'RF_Test Start' is set to be 4 bytes.
     88          // 
     89          //    Rev 1.10   Aug 04 2009 15:01:54   akodzhh
     90          // Cm005802: Treatment of $3B $90 corrected for 'BCM Hardware Level'.
     91          // 
     92          //    Rev 1.9   Aug 04 2009 13:42:56   akodzhh
     93          // Cm005751: Delay reset, when session is closed due to StopComm request. CR issues fixed.
     94          // 
     95          //    Rev 1.8   Apr 29 2009 14:24:58   adzhelp
     96          // Cm003517: MEM_TYPE attribute added to service and static functions
     97          // 
     98          //    Rev 1.7   Apr 17 2009 19:12:20   akodzhh
     99          // Cm003517: Use a reset after the sleep request treatment.
    100          // 
    101          //    Rev 1.6   Apr 17 2009 15:46:20   akodzhh
    102          // Cm003517: TOSIsTimerElapsed() call corrected. AutoTest synchronization timeout - treat as timeout, not a delay.
    103          // 
    104          //    Rev 1.5   15 Apr 2009 19:26:20   akodzhh
    105          // Cm003517: StopAutoTest response - status corrected (OK\NOK inversion). Flasher test request wrong byte read.
    106          // 
    107          //    Rev 1.4   15 Apr 2009 12:03:22   akodzhh
    108          // Cm003517: Added SerialLine Immo and Eeprom Test. Constants for Flasher Test renamed. Checks for BCD formad removed from $38$90 frame. Analog values - read converted data 5s. OPEN_DOOR_LED/Alarm output - ensure diag control.
    109          // 
    110          //    Rev 1.3   31 Mar 2009 11:41:50   akodzhh
    111          // Cm003517:  on init TFC session set diag mask (notify DAT_PWM) for PWM_ROOMLAMP output direct control.
    112          // 
    113          //    Rev 1.2   30 Mar 2009 13:51:34   akodzhh
    114          // Cm003517: Read DI_ENGINE_RPM (replace ENGINE_RPM)
    115          // 
    116          //    Rev 1.1   20 Mar 2009 18:18:32   akodzhh
    117          // Cm003517 - fixes for warnings and some data names, Checksum calculation, sleep timeout measurement - use graph instead of task.
    118          // 
    119          //    Rev 1.0   Mar 17 2009 16:53:32   akodzhh
    120          // Initial revision.
    121          //******************************************************************************
    122          #endif
    123          
    124          
    125          //------------------------------------------------------------------------------
    126          // Body Identification
    127          //------------------------------------------------------------------------------
    128          
    129          #define lap_tfc  "lap_tfc"
    130          
    131          //------------------------------------------------------------------------------
    132          // Included files to resolve specific definitions in this file
    133          //------------------------------------------------------------------------------
    134          #include "lib.h"
    135          #include "dat.h"
    136          #include "tos.h"
    137          #include "lap_kwp.h"
    138          #include "lap_kwpp.h"
    139          #include "lap_tfc.h"
    140          #include "lap_tfc.hgr"

   \                                 In  segment CONST, align 2
   \   tTOSSeqRuleType const __near LAPTfcAutoTestIO[6]
   \                     LAPTfcAutoTestIO:
   \   0000   ........       DW IsAutoTestTimeOutElapsed, StartSetupTimeOut
   \   0004   FF01           DB 255, 1
   \   0006   ........       DW IsAutoTestTimeOutElapsed, ActivateOutputs
   \   000A   FF02           DB 255, 2
   \   000C   ........       DW IsAutoTestTimeOutElapsed, StartSynchronizationTimeout
   \   0010   FF03           DB 255, 3
   \   0012   ........       DW IsTimeoutElapsedOrInputsAreSet, FinishSequence
   \   0016   FF04           DB 255, 4
   \   0018   ........       DW IsAutoTestFinished, TOSSeqNoAction
   \   001C   05FF           DB 5, 255
   \   001E   ........       DW TOSSeqTrueEval, StartSetupTimeOut
   \   0022   FF01           DB 255, 1

   \                                 In  segment CONST, align 2
   \   tTOSSeqRuleType const __near LAPTfcGraph[1]
   \                     LAPTfcGraph:
   \   0000   ........       DW IsSleepTimeoutElapsed, SleepTimeoutElapsed
   \   0004   FFFF           DB 255, 255

   \                                 In  segment CONST, align 2
   \   tTOSSeqRuleType const __near LAPTfcEepTest[1]
   \                     LAPTfcEepTest:
   \   0000   ........       DW TOSSeqTrueEval, TreatEepromTest
   \   0004   FF00           DB 255, 0
    141          
    142          #ifdef BOOTLOADER_IS_SUPPORTED
    143              #include "LIB_BOO.h"
    144          #endif
    145          
    146          //------------------------------------------------------------------------------
    147          // Local constants
    148          //------------------------------------------------------------------------------
    149          
    150          /////////////////////////////////////////////////////
    151          // constants for ReadDataByLocalIdentifier (RDBLID)
    152          /////////////////////////////////////////////////////
    153          #define cRDBLIDReq_Lgth                         ((U8)2)
    154          #define cRDBLIDReq_AnalogValueLgth              ((U8)3)
    155          
    156          #define cRDBLID_SoftwareAndTFCVersionID         ((U8)0x90)
    157          #define cRDBLIDAns_SoftwareAndTFCVersion_Lgth   ((U8)10)
    158          
    159          #define cRDBLID_TFCDataID                       ((U8)0x91)
    160          #define cRDBLIDAns_TFCData_Lgth                 ((U8)28)
    161          
    162          #define cRDBLID_AnalogValueID                   ((U8)0x92)
    163          #define cRDBLIDAns_AnalogValue_Lgth             ((U8)17)
    164          
    165          #define cRDBLID_DigitalInputsID                 ((U8)0x93)
    166          #define cRDBLIDAns_DigitalInputs_Lgth           ((U8)6)
    167          
    168          ///////////////////////////////////////////////////////////////
    169          // constants for WriteDataByLocalIdentifier (WDBLID)
    170          ///////////////////////////////////////////////////////////////
    171          #define cWDBLIDReq_KilisRatio_Lgth              ((U8)4)
    172          #define cWDBLID_KilisRatioID                    ((U8)0x94)
    173          
    174          #define cWDBLIDReq_JCAEData_Lgth                ((U8)20)
    175          #define cWDBLID_JCAEDataID                      ((U8)0x90)
    176          
    177          #define cWDBLIDReq_TestCounter_Lgth             ((U8)3)
    178          #define cWDBLIDReq_FlashersCoeff_Lgth           ((U8)4)
    179          
    180          #define cWDBLID_InSituTestCounterID            ((U8)0x91)
    181          #define cWDBLID_FunctTestCounterID             ((U8)0x92)
    182          #define cWDBLID_RunningTestCounterID           ((U8)0x93)
    183          #define cWDBLID_RfTestCounterID                ((U8)0x94)
    184          #define cWDBLID_FinalTestCounterID             ((U8)0x95)
    185          #define cWDBLID_FlashersCoeffID                ((U8)0x96)
    186          
    187          ///////////////////////////////////////////////////////////////
    188          // constants for InputOutputControlByLocalIdentifier (IOCBLID)
    189          ///////////////////////////////////////////////////////////////
    190          #define cIOCBLIDReq_Lgth                        ((U8)5)
    191          #define cIOCBLIDAns_Lgth                        ((U8)3)
    192          
    193          #define cIOCBLID_StartPermanentCtrl             ((U8)0x20)
    194          
    195          
    196          #define cIOCBLID_ManualOutputMode               ((U8)0xFA)
    197          
    198          ///////////////////////////////////////////////////////////////
    199          // constants for StartRoutineByLocalIdentifier (SRBID)
    200          //              and StopRoutineByLocalIdentifier (SPRBID)
    201          ///////////////////////////////////////////////////////////////
    202          #define cSRBID_SequentielOutputModeReq_Lgth     ((U8)4)
    203          
    204          
    205          #define cSRBID_FlasherTestReq_Lgth          ((U8)3)
    206          #define cSRBID_RFTestReq_Lgth               ((U8)3)
    207          #define cSRBID_AutoTestTORReqStatic_Lgth    ((U8)9)
    208          #define cSRBID_SerialLineTestReq_Lgth       ((U8)4)
    209          #define cSRBID_SleepingModeReq_Lgth         ((U8)3)
    210          #define cSRBID_EepromTestReq_Lgth           ((U8)3)
    211          #define cSRBLID_StatusReq_Lgth              ((U8)3)
    212          
    213          #define cSRBLID_AutoTestTOR_RepLgth         ((U8)9)
    214          #define cSRBLID_StaticRepLgth               ((U8)3)
    215          #define cSRBLID_RFTestRepLgth               ((U8)4)
    216          #define cSRBID_ClearFaultsAndCountersLgth   ((U8)3)
    217          
    218          #define cSRBID_EepromReprogramming              ((U8)0xF0)
    219          #define cSRBID_ClearFaultsAndCounters           ((U8)0xF1)
    220          #define cSRBID_FlasherTest                      ((U8)0xF9)
    221          #define cSRBID_RFTest                           ((U8)0xFB)
    222          #define cSRBID_AutoTestTOR                      ((U8)0xFC) 
    223          #define cSRBID_SerialLineTest                   ((U8)0xFD)
    224          #define cSRBID_SleepingMode                     ((U8)0xFE)
    225          #define cSRBID_EepromTest                       ((U8)0xFF)
    226                                                    
    227                                                           
    228          #define cRoutineControlNumber                  ((U8)0x07)
    229          #define cRoutineIndexFlasherTest               0
    230          #define cRoutineIndexRFTest                    1
    231          #define cRoutineIndexAutoTestTOR               2
    232          #define cRoutineIndexSerialLineImmoTest        3
    233          #define cRoutineIndexSerialLineVerlogTest      4
    234          #define cRoutineIndexSleepingMode              5
    235          #define cRoutineIndexEepromTest                6
    236          
    237          
    238          // Routine status (TFC specific) 
    239          #define cRoutineNotActivated      ((U8) 0x00)
    240          #define cRoutineInProgress        ((U8) 0x10)
    241          #define cRoutineTerminatedOK      ((U8) 0x20)
    242          #define cRoutineTerminatedNOK     ((U8) 0x40)
    243                                                          
    244          #define cSRBID_StartRoutineID                   ((U8)0x00)
    245          #define cSRBID_ReadStatusID                     ((U8)0x01)
    246          
    247          ///////////////////////////////////////////////////////////////
    248          // constants for AutoTestTOR routine 
    249          ///////////////////////////////////////////////////////////////
    250          #define cOutputsNumber                    (U8)16
    251          #define cInputsNumber                     (U8)24
    252          #define cPouOutputsNumber                 (U8)cDATPouNumberOfDataDouGeneratorMessage 
    253          
    254          #define cOPEN_DOOR_LEDOutputPos           ((U8)10)
    255          #define cTxVerlogOutputPos                ((U8)12)
    256          #define cTxImmobilzerOutputPos            ((U8)13)
    257          #define cPwmRoomLampOutputPos             ((U8)14)
    258          #define cBuzzerOutputPos                  ((U8)15)
    259          #define cDiagBuzzFrequency           (U16)2400U     // 2.4kHZ
    260          
    261          #define cInvalidCurrentOutput             ((U8)0xFF)
    262          #define cInvalidSequentialOutput          ((U16)0xFFFF)
    263          
    264          #define cModeStopOnError                  (U8)0x00
    265          #define cModeContinueOnError              (U8)0x01
    266          #define cModeStopOnErrorTx                (U8)0x02
    267          #define cModeContinueOnErrorTx            (U8)0x03
    268          
    269          #define cSequenceModeBytePos                2  
    270          #define cStartDelayIn10msBytePos            3   // *10ms    
    271          #define cSetupTimeBytePos                   4   // *1ms     
    272          #define cActivationTimeOutBytePos           5   // *1ms     
    273          #define cFilterTimeConstantBytePos          6   // reserved for future use
    274          #define cSynchronizationTimeOutBytePos      7   // *10ms 
    275          #define cOrderingMatrixSizeBytePos          8       
    276          #define cOrderingMatrixBytePos              9
    277          
    278          #define cOrderingMatrixMaxSize             48 
    279          #define cMaxQuarterOutput               (U8)3
    280          #define cMaxQuarterInput                (U8)5
    281          #define cQuarter0                       (U8)0
    282          #define cQuarter1                       (U8)1
    283          #define cQuarter2                       (U8)2
    284          #define cQuarter3                       (U8)3
    285          #define cQuarter4                       (U8)4
    286          #define cQuarter5                       (U8)5
    287          #define cMatrixPairLng                     2  // one pair is containing one ouputs mask and one inputs mask
    288          #define cQuarterMask                    (U8)0xF0U 
    289          
    290          
    291          #define c10MsPerUnit                       10 
    292             
    293          
    294          // Inputs
    295          #define cIndexDI_ENGINE_RPM          0 
    296          #define cIndexPWR_IGN                1 
    297          #define cIndexRR_WASHER_SW           2 
    298          #define cIndexFR_FOG_SW              3  // HIGH_LOW_BEAM
    299          #define cIndexDI_DATA_IMMOBILIZER    4 
    300          #define cIndexDI_VERLOG              5 
    301          #define cIndexL_FLASHER_SW           6 
    302          #define cIndexFR_DOORS_SW            7 
    303          #define cIndexDOOR_LOCK_SW           8 
    304          #define cIndexFR_WIPER_INT_SW        9 
    305          #define cIndexRR_FOG_SW              10
    306          #define cIndexFR_WASHER_SW           11
    307          #define cIndexAIRBAG_CRASH           12
    308          #define cIndexVEHICLE_SPEED          13
    309          #define cIndexFR_AUTOSTOP_SW         14
    310          #define cIndexRR_AUTOSTOP_SW         15
    311          #define cIndexHAZARD_SW              16
    312          #define cIndexR_FLASHER_SW           17
    313          #define cIndexRR_WIPER_INT_SW        18
    314          #define cIndexPOSITION_LIGHTS        19     // DI_CTC_DIMMERS
    315          #define cIndexRR_DOORS_SW            20
    316          #define cIndexDOOR_UNLOCK_SW         21
    317          #define cIndexDEFROSTER_SW           22
    318          #define cIndexSEATBELT_REMINDER_SW   23
    319          
    320          #define cMaskDI_ENGINE_RPM          (U8)0x01
    321          #define cMaskPWR_IGN                (U8)0x02
    322          #define cMaskRR_WASHER_SW           (U8)0x04
    323          #define cMaskFR_FOG_SW              (U8)0x08    // HIGH_LOW_BEAM
    324          #define cMaskDI_DATA_IMMOBILIZER    (U8)0x11
    325          #define cMaskDI_VERLOG              (U8)0x12
    326          #define cMaskL_FLASHER_SW           (U8)0x14
    327          #define cMaskFR_DOORS_SW            (U8)0x18
    328          #define cMaskDOOR_LOCK_SW           (U8)0x21
    329          #define cMaskFR_WIPER_INT_SW        (U8)0x22
    330          #define cMaskRR_FOG_SW              (U8)0x24
    331          #define cMaskFR_WASHER_SW           (U8)0x28
    332          #define cMaskAIRBAG_CRASH           (U8)0x31
    333          #define cMaskVEHICLE_SPEED          (U8)0x32
    334          #define cMaskFR_AUTOSTOP_SW         (U8)0x34
    335          #define cMaskRR_AUTOSTOP_SW         (U8)0x38
    336          #define cMaskHAZARD_SW              (U8)0x41
    337          #define cMaskR_FLASHER_SW           (U8)0x42
    338          #define cMaskRR_WIPER_INT_SW        (U8)0x44
    339          #define cMaskPOSITION_LIGHTS        (U8)0x48    // DI_CTC_DIMMERS    
    340          #define cMaskRR_DOORS_SW            (U8)0x51
    341          #define cMaskDOOR_UNLOCK_SW         (U8)0x52
    342          #define cMaskDEFROSTER_SW           (U8)0x54
    343          #define cMaskSEATBELT_REMINDER_SW   (U8)0x58
    344          
    345          // common constants
    346          #define c8Bits  8
    347          #define c7Bits  7
    348          #define c6Bits  6
    349          #define c5Bits  5
    350          #define c4Bits  4
    351          #define c3Bits  3
    352          #define c2Bits  2
    353          #define c1Bits  1
    354          #define c16Bits  16
    355          #define cLSBMask       (U8)0xFFU
    356          #define cu16LSBMask    0x00FF
    357          #define cu16MSBMask    0xFF00
    358          
    359          #define cByte0  0
    360          #define cByte1  1
    361          #define cByte2  2
    362          #define cByte3  3
    363          #define cByte4  4
    364          
    365          
    366          // Pwm Output
    367          #define cPwmRoomLampDiagRatio   (U8)100
    368          
    369          // Eeprom data
    370          #define cEEP_ECUReferenceLength     5
    371          #define cEEP_PieNumberLength        5
    372          #define cEEP_PieIndexLength         2
    373          #define cEEP_SerialNumberLength     3
    374          #define cEEP_DateCodeLength         2
    375          
    376          #define cECUTypeByte    19
    377          #define cECUTypeMax     (U8)0x07
    378          
    379          ///////////////////////////////////////////////////////////////
    380          // constants for Checksum calculation
    381          ///////////////////////////////////////////////////////////////
    382          #ifndef COMPILATION_NATIVE
    383          //QACJ 3116: akodzhh: X90_BCM project specific checksum calculation
    384          #pragma segment="CHECKSUM"
    385          #define cRomChecksum        (*((U16*)__segment_begin("CHECKSUM")))
    386          #else
    387          #define cRomChecksum        0
    388          #endif
    389          
    390          #define cTimeoutBeforeEnterSleepInMs        100UL
    391          
    392          ///////////////////////////////////////////////////////////////
    393          // constants for EepromTest - Eep Checksum read
    394          ///////////////////////////////////////////////////////////////
    395          #define cNbEepBanks              (U8)(cNbDbk + cNbSbk)
    396          #define cDbkOffset         cDATDbkFirstProcessHandle
    397          // Bank Index in mDATEepDeclareBlocList
    398          #define cIndexErrorGroup            cDATSbkHandleErrorGroup          
    399          #define cIndexSupplierBank          cDATSbkHandleSupplierBank
    400          #define cIndexVersionBank           cDATSbkHandleVersionBank 
    401          #define cIndexVINBank               cDATSbkHandleVINBank
    402          #define cIndexSpareBank             cDATSbkHandleSpareBank
    403          #define cIndexDiagBank              (cDbkOffset+cDATDbkHandleDiagBank            )            
    404          #define cIndexGeneralParameterBank  (cDbkOffset+cDATDbkHandleGeneralParameterBank)
    405          #define cIndexFactoryConfigBank     (cDbkOffset+cDATDbkHandleFactoryConfigBank   )
    406          #define cIndexStaticImmoBank        (cDbkOffset+cDATDbkHandleStaticImmoBank      )
    407          #define cIndexDynamicImmoDataBank   (cDbkOffset+cDATDbkHandleDynamicImmoDataBank )     
    408          
    409          #define cCksLgth        (U8)2
    410          
    411          ///////////////////////////////////////////////////////////////
    412          // constants for SerialLineTest
    413          ///////////////////////////////////////////////////////////////
    414          #define cSerialLineVerlog       (U8)0x01
    415          #define cSerialLineImmobilizer  (U8)0x02
    416          
    417          ///////////////////////////////////////////////////////////////
    418          // constants for RDBLID AnalogValue
    419          ///////////////////////////////////////////////////////////////
    420          #define cReadingOptionDirect       (U8)0x00
    421          #define cReadingOptionCorrection   (U8)0xFF
    422          
    423          ///////////////////////////////////////////////////////////////
    424          // constants for RDBLID log zone / TFCData
    425          ///////////////////////////////////////////////////////////////
    426          // Response indexes (= specification index - 1)
    427          #define cInSituTestCounterIndex    (U8)21U
    428          #define cDateCodeIndex             (U8)17U
    429          #define cSerialNumberIndex         (U8)14U
    430          
    431          #define cLastLogZoneId             (U8)0xFEU
    432          #define cLogZoneSize               24U
    433          
    434          // Log zone IDENT indexes
    435          #define cLogZoneSparePartNumberIndex    0U
    436          #define cLogZoneHwNumberIndex           9U
    437          #define cLogZoneCalibrationNumberIndex  18U
    438          #define cLogZoneEcuTypeIndex            20U  // first byte of 'other system features'
    439          #define cLogZoneSerialNumberIndex       21U  // last 3 bytes of log zone
    440          // Log zone REPROG indexes
    441          #define cLogZoneDateIndex               16U
    442          
    443          //------------------------------------------------------------------------------
    444          // Local macros
    445          //------------------------------------------------------------------------------
    446          #define mInitTfcTabIdentifierServiceSupported()   \
    447          {                                                 \
    448            cLAPKwpIdReadDataByLocalIdentifier,                \
    449            cLAPKwpIdWriteDataByLocalIdentifier,               \
    450            cLAPKwpIdInputOutputControlByLocalIdentifier,      \
    451            cLAPKwpIdStartRoutineByLocalIdentifier             \
    452          }
    453          
    454          #define mInitTfcTabServiceSupported()                 \
    455          {                                                     \
    456            LAPTfcTreatReadDataByLocalIdentifierService,           \
    457            LAPTfcTreatWriteDataByLocalIdentifierService,          \
    458            LAPTfcTreatInputOutputControlByLocalIdentifierService, \
    459            LAPTfcTreatStartRoutineByLocalIdentifierService        \
    460          }
    461          //QACJ 3435: akodzhh: There is no side effect
    462          //QACJ 3456: akodzhh: There is no side effect
    463          #define mGetQuarterMask(Index)   (U8)( (U8)( (Index)>>2 ) | (U8)( 1 << (U8)((Index)&3 )))
    464          
    465          #define mSetInputError(InputIndex)   (u32ErrorsOnInput |= (U32)((U32)1 << (InputIndex)))
    466          #define mSetOutputError(OutputIndex)   (u16ErrorsOnOutput |= (U16)((U16)1 << (OutputIndex)))
    467          
    468          //------------------------------------------------------------------------------
    469          // Local types
    470          //------------------------------------------------------------------------------
    471          typedef struct EepBankCks
    472          {
    473              U8  u8BankIndex;
    474              U8  u8BankCksMSB;
    475              U8  u8BankCksLSB;
    476          }tEepBankCks;
    477          
    478          //------------------------------------------------------------------------------
    479          // Local data
    480          //------------------------------------------------------------------------------
    481          // TODO: update order of banks when eeprom mapping is changed 

   \                                 In  segment NEAR_I, align 1, align-sorted
    482          static tEepBankCks BanksCksTable[cNbEepBanks]= 
   \                     BanksCksTable:
   \   0000                  DS 30
   \   001E                  REQUIRE `?<Initializer for BanksCksTable>`
   \   001E                  REQUIRE __INIT_NEAR_I
    483          {    
    484              {(U8)cIndexErrorGroup          ,0,0},
    485              {(U8)cIndexSupplierBank        ,0,0},
    486              {(U8)cIndexVersionBank         ,0,0},
    487              {(U8)cIndexVINBank             ,0,0},
    488              {(U8)cIndexSpareBank           ,0,0},
    489              {(U8)cIndexDiagBank            ,0,0},
    490              {(U8)cIndexGeneralParameterBank,0,0},
    491              {(U8)cIndexFactoryConfigBank   ,0,0},
    492              {(U8)cIndexStaticImmoBank      ,0,0},
    493              {(U8)cIndexDynamicImmoDataBank ,0,0}
    494          };
    495          

   \                                 In  segment NEAR_Z, align 1, align-sorted
    496          static U8         RoutineRequestInProgress[cRoutineControlNumber];
   \                     RoutineRequestInProgress:
   \   0000                  DS 7
   \   0007                  REQUIRE __INIT_NEAR_Z
    497          

   \                                 In  segment NEAR_Z, align 2, align-sorted
    498          static U16        u16ErrorsOnOutput;  // 16 Outputs
   \                     u16ErrorsOnOutput:
   \   0000                  DS 2
   \   0002                  REQUIRE __INIT_NEAR_Z

   \                                 In  segment NEAR_Z, align 2, align-sorted
    499          static U32        u32ErrorsOnInput;   // 24 Inputs 
   \                     u32ErrorsOnInput:
   \   0000                  DS 4
   \   0004                  REQUIRE __INIT_NEAR_Z

   \                                 In  segment NEAR_Z, align 1, align-sorted
    500          static U8         u8SequenceMode;
   \                     u8SequenceMode:
   \   0000                  DS 1
   \   0001                  REQUIRE __INIT_NEAR_Z
    501          

   \                                 In  segment NEAR_Z, align 2, align-sorted
    502          static tTOSTimer  AutoTestTimer;
   \                     AutoTestTimer:
   \   0000                  DS 2
   \   0002                  REQUIRE __INIT_NEAR_Z

   \                                 In  segment NEAR_Z, align 2, align-sorted
    503          static tTOSTimer  AutoTestTimeOutValueInTick;
   \                     AutoTestTimeOutValueInTick:
   \   0000                  DS 2
   \   0002                  REQUIRE __INIT_NEAR_Z

   \                                 In  segment NEAR_Z, align 2, align-sorted
    504          static tTOSTimer  SleepTimer;
   \                     SleepTimer:
   \   0000                  DS 2
   \   0002                  REQUIRE __INIT_NEAR_Z
    505          

   \                                 In  segment NEAR_Z, align 1, align-sorted
    506          static U8  u8EepTestCounter;
   \                     u8EepTestCounter:
   \   0000                  DS 1
   \   0001                  REQUIRE __INIT_NEAR_Z
    507          

   \                                 In  segment NEAR_Z, align 1, align-sorted
    508          static U8  u8AutoTestSetupTimeOut;
   \                     u8AutoTestSetupTimeOut:
   \   0000                  DS 1
   \   0001                  REQUIRE __INIT_NEAR_Z

   \                                 In  segment NEAR_Z, align 1, align-sorted
    509          static U8  u8AutoTestActivTimeOut;
   \                     u8AutoTestActivTimeOut:
   \   0000                  DS 1
   \   0001                  REQUIRE __INIT_NEAR_Z

   \                                 In  segment NEAR_Z, align 1, align-sorted
    510          static U8  u8AutoTestSynchroTimeOutIn10msUnit;
   \                     u8AutoTestSynchroTimeOutIn10msUnit:
   \   0000                  DS 1
   \   0001                  REQUIRE __INIT_NEAR_Z

   \                                 In  segment NEAR_Z, align 1, align-sorted
    511          static U8  u8OrderingMatrixSize;
   \                     u8OrderingMatrixSize:
   \   0000                  DS 1
   \   0001                  REQUIRE __INIT_NEAR_Z

   \                                 In  segment NEAR_Z, align 1, align-sorted
    512          static U8  u8OrderingMatrix[cOrderingMatrixMaxSize];
   \                     u8OrderingMatrix:
   \   0000                  DS 48
   \   0030                  REQUIRE __INIT_NEAR_Z

   \                                 In  segment NEAR_Z, align 1, align-sorted
    513          static U8  u8OrderingMatrixCounter;
   \                     u8OrderingMatrixCounter:
   \   0000                  DS 1
   \   0001                  REQUIRE __INIT_NEAR_Z
    514          

   \                                 In  segment NEAR_Z, align 1, align-sorted
    515          static BOOL bOutputsActivated;
   \                     bOutputsActivated:
   \   0000                  DS 1
   \   0001                  REQUIRE __INIT_NEAR_Z
    516          
    517          
    518          //------------------------------------------------------------------------------
    519          // Constant local data
    520          //------------------------------------------------------------------------------

   \                                 In  segment CONST, align 2
    521          static const U16 u16OutputTab[cOutputsNumber] =
   \                     u16OutputTab:
   \   0000   03060307       DW 1539, 1795, 1283, 3, 259, 771, 1027, 515, 257, 514, 768, 512, 65535
   \          03050300
   \          03010303
   \          03040302
   \          01010202
   \          00030002
   \          FFFF    
   \   001A   FFFFFFFF       DW 65535, 65535, 65535
   \          FFFF    
    522          {
    523              ((U16)cDATPouDI_LEFTByteIndex              | (U16)((U16)cDATPouDI_LEFTBitIndex              << c8Bits)),    //    1    HS    DO_DRIVE_LEFT_FLASHER_CAR
    524              ((U16)cDATPouDI_RIGHTByteIndex             | (U16)((U16)cDATPouDI_RIGHTBitIndex             << c8Bits)),    //    2    HS    DO_DRIVE_RIGHT_FLASHER_CAR
    525              ((U16)cDATPouRR_WIPER_RR_FOG_LAMPByteIndex | (U16)((U16)cDATPouRR_WIPER_RR_FOG_LAMPBitIndex << c8Bits)),    //    3    HS    DO_DRIVE_REAR_WIPER_CAR
    526              ((U16)cDATPouLOCK_DOORSByteIndex           | (U16)((U16)cDATPouLOCK_DOORSBitIndex           << c8Bits)),    //    4    HS    DO_RELAY_DOORS-LOCK_CAR
    527              ((U16)cDATPouUNLOCK_DOORSByteIndex         | (U16)((U16)cDATPouUNLOCK_DOORSBitIndex         << c8Bits)),    //    5    HS    DO_RELAY_DOORS-UNLOCK_CAR
    528              ((U16)cDATPouUNLOCK_DRIVER_DOORByteIndex   | (U16)((U16)cDATPouUNLOCK_DRIVER_DOORBitIndex   << c8Bits)),    //    6    HS    DO_RELAY_DRV-DOOR-UNLOCK_CAR
    529              ((U16)cDATPouFRONT_WIPERByteIndex          | (U16)((U16)cDATPouFRONT_WIPERBitIndex          << c8Bits)),    //    7    HS    DO_RELAY_FRONT_WIPER_CAR
    530              ((U16)cDATPouBAT_LIGHT_TEMPOByteIndex      | (U16)((U16)cDATPouBAT_LIGHT_TEMPOBitIndex      << c8Bits)),    //    8    HS    DO_RELAY_ALIM_TEMPO_CAR
    531              ((U16)cDATPouDEFROSTERByteIndex            | (U16)((U16)cDATPouDEFROSTERBitIndex            << c8Bits)),    //    9    LS    DO_DRIVE_DEFROSTER_CAR
    532              ((U16)cDATPouHORN_RLByteIndex              | (U16)((U16)cDATPouHORN_RLBitIndex              << c8Bits)),    //    0A    LS    DO_DRIVE_KLAXON_CAR
    533              ((U16)cDATPouOPEN_DOOR_LEDByteIndex        | (U16)((U16)cDATPouOPEN_DOOR_LEDBitIndex        << c8Bits)),    //    0B    LS    DO_DOOR-LOCK_LED_CAR
    534              ((U16)cDATPouVERLOG_LEDByteIndex           | (U16)((U16)cDATPouVERLOG_LEDBitIndex           << c8Bits)),    //    0C    LS    DO_DRIVE_LED-VERLOG_CAR
    535              ((U16)cInvalidSequentialOutput                                                                   ),    //    0D    LS    DIO_ECM_CAR
    536              ((U16)cInvalidSequentialOutput                                                                   ),    //    0E    LS    DIO_IMMOBILIZER_CAR
    537              ((U16)cInvalidSequentialOutput                                                                   ),    //    0F    LS    DO_DRIVE_CEILING_LIGHT_CAR
    538              ((U16)cInvalidSequentialOutput                                                                   )     //    10    NA    BUZZER
    539          
    540          };
    541          

   \                                 In  segment CONST, align 2
    542          static const tDATEepBloc EepBanksList[cNbEepBanks+1] = {mDATEepDeclareBlocList()}; 
   \                     EepBanksList:
   \   0000   0000           DW 0
   \   0002   0600           DB 6, 0
   \   0004   0600           DW 6
   \   0006   0E00           DB 14, 0
   \   0008   2E00           DW 46
   \   000A   0200           DB 2, 0
   \   000C   6000           DW 96
   \   000E   0B00           DB 11, 0
   \   0010   FD00           DW 253
   \   0012   0200           DB 2, 0
   \   0014   1400           DW 20
   \   0016   1A01           DB 26, 1
   \   0018   3000           DW 48
   \   001A   0801           DB 8, 1
   \   001C   3800           DW 56
   \   001E   2801           DB 40, 1
   \   0020   6B00           DW 107
   \   0022   4E01           DB 78, 1
   \   0024   B900           DW 185
   \   0026   4401           DB 68, 1
   \   0028   0000           DW 0
   \   002A   0002           DB 0, 2
    543          //------------------------------------------------------------------------------
    544          // Exported data
    545          //------------------------------------------------------------------------------
    546          
    547          
    548          //------------------------------------------------------------------------------
    549          // Constant exported data
    550          //------------------------------------------------------------------------------
    551          //QACJ 3211: akodzhh: Identifier is exported and used in LAP_KWP to init TFC session

   \                                 In  segment CONST, align 1
    552          const U8 TabIdentifierServiceSupportedInTfcSession[cNbServicesSupportedInTFC] =
   \                     TabIdentifierServiceSupportedInTfcSession:
   \   0000   213B3031       DB 33, 59, 48, 49
    553                    mInitTfcTabIdentifierServiceSupported();
    554          //QACJ 3211: akodzhh: Identifier is exported and used in LAP_KWP to init TFC session

   \                                 In  segment CONST, align 2
    555          const tLAPKwpServiceFunction TabServiceSupportedInTfcSession[cNbServicesSupportedInTFC] =
   \                     TabServiceSupportedInTfcSession:
   \   0000   ........       DD LAPTfcTreatReadDataByLocalIdentifierService
   \   0004   ........       DD LAPTfcTreatWriteDataByLocalIdentifierService
   \   0008   ........       DD LAPTfcTreatInputOutputControlByLocalIdentifierService
   \   000C   ........       DD LAPTfcTreatStartRoutineByLocalIdentifierService
    556                    mInitTfcTabServiceSupported();
    557          
    558          //------------------------------------------------------------------------------
    559          // Local function prototypes
    560          //------------------------------------------------------------------------------
    561          static MEM_TYPE U16  ROMChecksumCalculation(void);
    562          static MEM_TYPE void SetOutput  (const U8 u8OutputNumberP);
    563          static MEM_TYPE void ClearOutput(const U8 u8OutputNumberP);
    564          static MEM_TYPE BOOL IsOrderingMatrixDataValid(void);
    565          static MEM_TYPE void ClearOutputAndSetResult(const U8 u8OutputNumberP);
    566          static MEM_TYPE void DeactivateOutputs(const BOOL bSetResultsP);
    567          static MEM_TYPE BOOL ReadInputsAndSetResult(void);
    568          
    569          static MEM_TYPE U8   StartAutoTestTOR (void);
    570          static MEM_TYPE void StopAutoTestTOR  (void);
    571          
    572          #ifdef BOOTLOADER_IS_SUPPORTED
    573          static MEM_TYPE U8   ReadECU_LOG(void);
    574          #endif
    575          
    576          #ifdef X90_PROJECT
    577          static MEM_TYPE void ActivateOutputs_Static(void);
    578          static MEM_TYPE BOOL IsAutoTestFinished_Static(void);
    579          static MEM_TYPE void TreatEepromTest_Static(void);
    580          #endif
    581          
    582          //==============================================================================
    583          //=========================== LOCAL FUNCTIONS ==================================
    584          //==============================================================================
    585          //==============================================================================
    586          // DESCRIPTION:         ROMChecksumCalculation
    587          //
    588          // PARAMETERS:          none
    589          //
    590          // RETURN VALUE:        U16
    591          //
    592          // DESIGN INFORMATION:  refer to Detailed Design Document
    593          //==============================================================================
    594          static MEM_TYPE U16 ROMChecksumCalculation(void)
    595          {
    596              //QACJ 0306: akodzhh: X90_BCM project specific checksum calculation
    597              //QACJ 0506: akodzhh: X90_BCM project specific checksum calculation
    598              //QACJ 1302: akodzhh: X90_BCM project specific checksum calculation
    599              //QACJ 3335: akodzhh: X90_BCM project specific checksum calculation
    600              return( cRomChecksum );
    601          }
    602          
    603          //==============================================================================
    604          // DESCRIPTION:         SetOutput
    605          //
    606          // PARAMETERS:          U8
    607          //
    608          // RETURN VALUE:        none
    609          //
    610          // DESIGN INFORMATION:  refer to Detailed Design Document
    611          //==============================================================================

   \                                 In  segment BCODE, align 1, keep-with-next
    612          static MEM_TYPE void SetOutput(const U8 u8OutputNumberP)
   \                     SetOutput:
    613          {
   \   0000                  ; * Stack frame (at entry) *
   \   0000                  ; Param size: 0
   \   0000   B3             PUSH      BC
   \   0001                  ; Total Auto size: 0
   \   0001   72             MOV       C,A
    614              mLIBassert(u8OutputNumberP < cOutputsNumber);
    615              if (u8OutputNumberP == cPwmRoomLampOutputPos)
   \   0002   4D0E           CMP       A,#14
   \   0004   BD14           BNZ       ??TreatEepromTest_Static_0
    616              {
    617                  mLIBassert(u16OutputTab[cPwmRoomLampOutputPos] == cInvalidSequentialOutput);
    618                  mDATWrite(U8Bit,PWM_ROOMLAMPDiagRatio, cPwmRoomLampDiagRatio, Default);
   \   0006   A064           MOV       X,#100
   \   0008   60             MOV       A,X
   \   0009   74             MOV       E,A
   \   000A   02....         MOVW      AX,DATPwmHardBuffer
   \   000D   D2             MOVW      BC,AX
   \   000E   64             MOV       A,E
   \   000F   70             MOV       X,A
   \   0010   A100           MOV       A,#0
   \   0012   16....         MOVW      HL,#LWRD(DATPwmWriteDiagOutput)
   \   0015   A4..           MOV       E,#BYTE3(DATPwmWriteDiagOutput)
   \   0017   ..             CALLT     [__T_?FAR_CALL_L07]
   \   0018   FA7D           BR        ??TreatEepromTest_Static_1
    619              }
    620              else if(u8OutputNumberP == cBuzzerOutputPos)
   \                     ??TreatEepromTest_Static_0:
   \   001A   4D0F           CMP       A,#15
   \   001C   BD08           BNZ       ??TreatEepromTest_Static_2
    621              {
    622                  mDATWrite(U16Bit,DATBuzDiagBuzz, cDiagBuzzFrequency, Default);
   \   001E   106009         MOVW      AX,#2400
   \   0021   9A....         CALL      DATBuzDiagBuzzStart
   \   0024   FA71           BR        ??TreatEepromTest_Static_1
    623              }
    624              else if(u8OutputNumberP == cTxVerlogOutputPos)
   \                     ??TreatEepromTest_Static_2:
   \   0026   4D0C           CMP       A,#12
   \   0028   BD1D           BNZ       ??TreatEepromTest_Static_3
    625              {
    626                  mDATWrite(U1Bit,DO_VERLOGDiagEnabled, cTrue, Default);
   \   002A   A101           MOV       A,#1
   \   002C   9E....         MOV       bDO_VERLOGDiagEnabled,A
    627                  mDATWrite(U1Bit,DO_VERLOGDiag, 1, Default);    
   \   002F   9E....         MOV       bDO_VERLOG,A
   \   0032   8E....         MOV       A,bDO_VERLOGProtected
   \   0035   4D00           CMP       A,#0
   \   0037   BD04           BNZ       ??TreatEepromTest_Static_4
   \   0039   A105           MOV       A,#5
   \   003B   FA02           BR        ??TreatEepromTest_Static_5
   \                     ??TreatEepromTest_Static_4:
   \   003D   A106           MOV       A,#6
   \                     ??TreatEepromTest_Static_5:
   \   003F   16....         MOVW      HL,#LWRD(LDBDouControl)
   \   0042   A4..           MOV       E,#BYTE3(LDBDouControl)
   \   0044   ..             CALLT     [__T_?FAR_CALL_L07]
   \   0045   FA50           BR        ??TreatEepromTest_Static_1
    628              }
    629              else if(u8OutputNumberP == cTxImmobilzerOutputPos)
   \                     ??TreatEepromTest_Static_3:
   \   0047   4D0D           CMP       A,#13
   \   0049   BD0C           BNZ       ??TreatEepromTest_Static_6
    630              {
    631                  mDATWrite(U1Bit,DO_DATA_IMMOBILIZERDiagEnabled, cTrue, Default);
   \   004B   A101           MOV       A,#1
   \   004D   9E....         MOV       bDO_DATA_IMMOBILIZERDiagEnabled,A
   \   0050   A10C           MOV       A,#12
   \   0052   ..             CALLT     [__T_DATTrpControl]
    632                  mDATWrite(U1Bit,DO_DATA_IMMOBILIZERDiag, 1, Default);
   \   0053   A103           MOV       A,#3
   \   0055   FAE8           BR        ??TreatEepromTest_Static_5
    633              }
    634              else    // Set digital output
    635              {   // output shared with Alarm - stop Alarm
    636                  if((u8OutputNumberP == cOPEN_DOOR_LEDOutputPos)
    637                   &&(mDATRead(U1Bit,IsAlaDiagEnabled, Default ) == cFalse) )
   \                     ??TreatEepromTest_Static_6:
   \   0057   4D0A           CMP       A,#10
   \   0059   BD0A           BNZ       ??TreatEepromTest_Static_7
   \   005B   8E....         MOV       A,bIsAlaDiagEnabled
   \   005E   4D00           CMP       A,#0
   \   0060   BD03           BNZ       ??TreatEepromTest_Static_7
    638                  {            
    639                      TOSSendControl(cTOSControlAlaDiagEnable);
   \   0062   A11B           MOV       A,#27
   \   0064   ..             CALLT     [__T_TOSSendControl]
    640                  }
    641                 
    642                  mDATWriteTable(U1Bit,DATPouDiagBuffer,u16OutputTab[u8OutputNumberP],1,Default);
   \                     ??TreatEepromTest_Static_7:
   \   0065   62             MOV       A,C
   \   0066   A002           MOV       X,#2
   \   0068   3188           MULU      X
   \   006A   CA....         ADDW      AX,#u16OutputTab
   \   006D   D6             MOVW      HL,AX
   \   006E   87             MOV       A,[HL]
   \   006F   70             MOV       X,A
   \   0070   AE01           MOV       A,[HL+0x01]
   \   0072   73             MOV       B,A
   \   0073   60             MOV       A,X
   \   0074   33             XCH       A,B
   \   0075   72             MOV       C,A
   \   0076   100100         MOVW      AX,#1
   \   0079   ..             CALLT     [__T_?I_LSH_L02]
   \   007A   60             MOV       A,X
   \   007B   74             MOV       E,A
   \   007C   100100         MOVW      AX,#1
   \   007F   ..             CALLT     [__T_?I_LSH_L02]
   \   0080   60             MOV       A,X
   \   0081   7DFF           XOR       A,#255
   \   0083   70             MOV       X,A
   \   0084   16....         MOVW      HL,#S:DATPouDiagBuffer
   \   0087   AB             MOV       A,[HL+B]
   \   0088   6158           AND       A,X
   \   008A   616C           OR        A,E
   \   008C   72             MOV       C,A
   \   008D   C6             MOVW      AX,HL
   \   008E   30             XCH       A,X
   \   008F   610B           ADD       A,B
   \   0091   30             XCH       A,X
   \   0092   2D00           ADDC      A,#0
   \   0094   D6             MOVW      HL,AX
   \   0095   62             MOV       A,C
   \   0096   97             MOV       [HL],A
    643              }
    644          
    645          }
   \                     ??TreatEepromTest_Static_1:
   \   0097   B2             POP       BC
   \   0098   AF             RET       
   \   0099                  REQUIRE ?CL78K_V4_6_L00
    646          
    647          //==============================================================================
    648          // DESCRIPTION:         ClearOutput
    649          //
    650          // PARAMETERS:          U8
    651          //
    652          // RETURN VALUE:        none
    653          //
    654          // DESIGN INFORMATION:  refer to Detailed Design Document
    655          //==============================================================================

   \                                 In  segment BCODE, align 1, keep-with-next
    656          static MEM_TYPE void ClearOutput(const U8 u8OutputNumberP)
   \                     ClearOutput:
    657          {
   \   0000                  ; * Stack frame (at entry) *
   \   0000                  ; Param size: 0
   \   0000   B3             PUSH      BC
   \   0001                  ; Total Auto size: 0
   \   0001   74             MOV       E,A
    658              mLIBassert(u8OutputNumberP < cOutputsNumber);
    659              // Clear PwmRoomLamp
    660              if (u8OutputNumberP == cPwmRoomLampOutputPos)
   \   0002   4D0E           CMP       A,#14
   \   0004   BD12           BNZ       ??TreatEepromTest_Static_8
    661              {
    662                  mLIBassert(u16OutputTab[cPwmRoomLampOutputPos] == cInvalidSequentialOutput);
    663                  mDATWrite(U8Bit,PWM_ROOMLAMPDiagRatio, 0, Default);
   \   0006   A000           MOV       X,#0
   \   0008   60             MOV       A,X
   \   0009   74             MOV       E,A
   \   000A   02....         MOVW      AX,DATPwmHardBuffer
   \   000D   D2             MOVW      BC,AX
   \   000E   64             MOV       A,E
   \   000F   70             MOV       X,A
   \   0010   16....         MOVW      HL,#LWRD(DATPwmWriteDiagOutput)
   \   0013   A4..           MOV       E,#BYTE3(DATPwmWriteDiagOutput)
   \   0015   ..             CALLT     [__T_?FAR_CALL_L07]
   \   0016   FA78           BR        ??TreatEepromTest_Static_9
    664              }
    665              else if(u8OutputNumberP == cBuzzerOutputPos)
   \                     ??TreatEepromTest_Static_8:
   \   0018   4D0F           CMP       A,#15
   \   001A   BD05           BNZ       ??TreatEepromTest_Static_10
    666              {
    667                  mDATControl(DATBuzDiagBuzz, Stop);
   \   001C   9A....         CALL      DATBuzDiagBuzzStop
   \   001F   FA6F           BR        ??TreatEepromTest_Static_9
    668              }
    669              else if(u8OutputNumberP == cTxVerlogOutputPos)
   \                     ??TreatEepromTest_Static_10:
   \   0021   4D0C           CMP       A,#12
   \   0023   BD14           BNZ       ??TreatEepromTest_Static_11
    670              {
    671                  mDATWrite(U1Bit,DO_VERLOGDiag, 0, Default);
   \   0025   A100           MOV       A,#0
   \   0027   9E....         MOV       bDO_VERLOG,A
   \   002A   A106           MOV       A,#6
   \   002C   16....         MOVW      HL,#LWRD(LDBDouControl)
   \   002F   A4..           MOV       E,#BYTE3(LDBDouControl)
   \   0031   ..             CALLT     [__T_?FAR_CALL_L07]
    672                  mDATWrite(U1Bit,DO_VERLOGDiagEnabled, cFalse, Default);    
   \   0032   A100           MOV       A,#0
   \   0034   9E....         MOV       bDO_VERLOGDiagEnabled,A
   \   0037   FA57           BR        ??TreatEepromTest_Static_9
    673              }
    674              else if(u8OutputNumberP == cTxImmobilzerOutputPos)
   \                     ??TreatEepromTest_Static_11:
   \   0039   4D0D           CMP       A,#13
   \   003B   BD12           BNZ       ??TreatEepromTest_Static_12
    675              {
    676                  mDATWrite(U1Bit,DO_DATA_IMMOBILIZERDiag, 0, Default);
   \   003D   A104           MOV       A,#4
   \   003F   16....         MOVW      HL,#LWRD(LDBDouControl)
   \   0042   A4..           MOV       E,#BYTE3(LDBDouControl)
   \   0044   ..             CALLT     [__T_?FAR_CALL_L07]
    677                  mDATWrite(U1Bit,DO_DATA_IMMOBILIZERDiagEnabled, cFalse, Default);
   \   0045   A100           MOV       A,#0
   \   0047   9E....         MOV       bDO_DATA_IMMOBILIZERDiagEnabled,A
   \   004A   A10D           MOV       A,#13
   \   004C   ..             CALLT     [__T_DATTrpControl]
   \   004D   FA41           BR        ??TreatEepromTest_Static_9
    678          
    679              }
    680              else
    681              {
    682                  mDATWriteTable(U1Bit,DATPouDiagBuffer,u16OutputTab[u8OutputNumberP],0,Default);
   \                     ??TreatEepromTest_Static_12:
   \   004F   A002           MOV       X,#2
   \   0051   3188           MULU      X
   \   0053   CA....         ADDW      AX,#u16OutputTab
   \   0056   D6             MOVW      HL,AX
   \   0057   87             MOV       A,[HL]
   \   0058   70             MOV       X,A
   \   0059   AE01           MOV       A,[HL+0x01]
   \   005B   75             MOV       D,A
   \   005C   60             MOV       A,X
   \   005D   35             XCH       A,D
   \   005E   72             MOV       C,A
   \   005F   100000         MOVW      AX,#0
   \   0062   ..             CALLT     [__T_?I_LSH_L02]
   \   0063   60             MOV       A,X
   \   0064   73             MOV       B,A
   \   0065   100100         MOVW      AX,#1
   \   0068   ..             CALLT     [__T_?I_LSH_L02]
   \   0069   60             MOV       A,X
   \   006A   7DFF           XOR       A,#255
   \   006C   70             MOV       X,A
   \   006D   65             MOV       A,D
   \   006E   16....         MOVW      HL,#S:DATPouDiagBuffer
   \   0071   72             MOV       C,A
   \   0072   AA             MOV       A,[HL+C]
   \   0073   6158           AND       A,X
   \   0075   616B           OR        A,B
   \   0077   72             MOV       C,A
   \   0078   C6             MOVW      AX,HL
   \   0079   30             XCH       A,X
   \   007A   610D           ADD       A,D
   \   007C   30             XCH       A,X
   \   007D   2D00           ADDC      A,#0
   \   007F   D6             MOVW      HL,AX
   \   0080   62             MOV       A,C
   \   0081   97             MOV       [HL],A
    683          
    684                  if((u8OutputNumberP == cOPEN_DOOR_LEDOutputPos)
    685                   &&(mDATRead(U1Bit,IsAlaDiagEnabled, Default ) == cTrue) )
   \   0082   64             MOV       A,E
   \   0083   4D0A           CMP       A,#10
   \   0085   BD09           BNZ       ??TreatEepromTest_Static_9
   \   0087   8E....         MOV       A,bIsAlaDiagEnabled
   \   008A   51             DEC       A
   \   008B   BD03           BNZ       ??TreatEepromTest_Static_9
    686                  {            
    687                      TOSSendControl(cTOSControlAlaDiagDisable);
   \   008D   A11C           MOV       A,#28
   \   008F   ..             CALLT     [__T_TOSSendControl]
    688                  }
    689              }
    690          
    691          }
   \                     ??TreatEepromTest_Static_9:
   \   0090   B2             POP       BC
   \   0091   AF             RET       
   \   0092                  REQUIRE ?CL78K_V4_6_L00
    692          
    693          //==============================================================================
    694          // DESCRIPTION:         ClearOutputAndSetResult
    695          //
    696          // PARAMETERS:          U8
    697          //
    698          // RETURN VALUE:        none
    699          //
    700          // DESIGN INFORMATION:  refer to Detailed Design Document
    701          //==============================================================================

   \                                 In  segment BCODE, align 1, keep-with-next
    702          static MEM_TYPE void ClearOutputAndSetResult(const U8 u8OutputNumberP)
   \                     ClearOutputAndSetResult:
    703          {
   \   0000                  ; * Stack frame (at entry) *
   \   0000                  ; Param size: 0
   \   0000   B3             PUSH      BC
   \   0001                  ; Total Auto size: 0
   \   0001   74             MOV       E,A
    704              mLIBassert(u8OutputNumberP < cOutputsNumber);
    705              // Clear PwmRoomLamp
    706              if (u8OutputNumberP == cPwmRoomLampOutputPos)
   \   0002   4D0E           CMP       A,#14
   \   0004   BD13           BNZ       ??TreatEepromTest_Static_13
    707              {
    708                  mLIBassert(u16OutputTab[cPwmRoomLampOutputPos] == cInvalidSequentialOutput);
    709                  // HW protection for this output is not available
    710                  mDATWrite(U8Bit,PWM_ROOMLAMPDiagRatio, 0, Default);
   \   0006   A000           MOV       X,#0
   \   0008   60             MOV       A,X
   \   0009   74             MOV       E,A
   \   000A   02....         MOVW      AX,DATPwmHardBuffer
   \   000D   D2             MOVW      BC,AX
   \   000E   64             MOV       A,E
   \   000F   70             MOV       X,A
   \   0010   16....         MOVW      HL,#LWRD(DATPwmWriteDiagOutput)
   \   0013   A4..           MOV       E,#BYTE3(DATPwmWriteDiagOutput)
   \   0015   ..             CALLT     [__T_?FAR_CALL_L07]
   \   0016   9B....         BR        N:??TreatEepromTest_Static_14
    711              }
    712              else if(u8OutputNumberP == cBuzzerOutputPos)
   \                     ??TreatEepromTest_Static_13:
   \   0019   4D0F           CMP       A,#15
   \   001B   BD06           BNZ       ??TreatEepromTest_Static_15
    713              {
    714                  // TODO: HW protection for this output is not available for now
    715                  mDATControl(DATBuzDiagBuzz, Stop);
   \   001D   9A....         CALL      DATBuzDiagBuzzStop
   \   0020   9B....         BR        N:??TreatEepromTest_Static_14
    716              }
    717              else if(u8OutputNumberP == cTxVerlogOutputPos)
   \                     ??TreatEepromTest_Static_15:
   \   0023   4D0C           CMP       A,#12
   \   0025   BD21           BNZ       ??TreatEepromTest_Static_16
    718              {
    719                  if(mDATRead(U1Bit,DO_VERLOGProtection ,Default) == 1)
   \   0027   8E....         MOV       A,bDO_VERLOGProtected
   \   002A   51             DEC       A
   \   002B   BD06           BNZ       ??TreatEepromTest_Static_17
    720                  {
    721                      mSetOutputError(u8OutputNumberP);
   \   002D   16....         MOVW      HL,#u16ErrorsOnOutput
   \   0030   86             INCW      HL
   \   0031   71C2           SET1      [HL].4
    722                  }
    723                  mDATWrite(U1Bit,DO_VERLOGDiag, 0, Default);
   \                     ??TreatEepromTest_Static_17:
   \   0033   A100           MOV       A,#0
   \   0035   9E....         MOV       bDO_VERLOG,A
   \   0038   A106           MOV       A,#6
   \   003A   16....         MOVW      HL,#LWRD(LDBDouControl)
   \   003D   A4..           MOV       E,#BYTE3(LDBDouControl)
   \   003F   ..             CALLT     [__T_?FAR_CALL_L07]
    724                  mDATWrite(U1Bit,DO_VERLOGDiagEnabled, cFalse, Default);    
   \   0040   A100           MOV       A,#0
   \   0042   9E....         MOV       bDO_VERLOGDiagEnabled,A
   \   0045   9B....         BR        N:??TreatEepromTest_Static_14
    725              }
    726              else if(u8OutputNumberP == cTxImmobilzerOutputPos)
   \                     ??TreatEepromTest_Static_16:
   \   0048   4D0D           CMP       A,#13
   \   004A   BD1E           BNZ       ??TreatEepromTest_Static_18
    727              {
    728                  if(mDATRead(U1Bit,DO_DATA_IMMOBILIZERProtection ,Default) == 1)
   \   004C   8E....         MOV       A,bDO_DATA_IMMOBILIZERProtected
   \   004F   51             DEC       A
   \   0050   BD06           BNZ       ??TreatEepromTest_Static_19
    729                  {
    730                      mSetOutputError(u8OutputNumberP);
   \   0052   16....         MOVW      HL,#u16ErrorsOnOutput
   \   0055   86             INCW      HL
   \   0056   71D2           SET1      [HL].5
    731                  }
    732                  mDATWrite(U1Bit,DO_DATA_IMMOBILIZERDiag, 0, Default);
   \                     ??TreatEepromTest_Static_19:
   \   0058   A104           MOV       A,#4
   \   005A   16....         MOVW      HL,#LWRD(LDBDouControl)
   \   005D   A4..           MOV       E,#BYTE3(LDBDouControl)
   \   005F   ..             CALLT     [__T_?FAR_CALL_L07]
    733                  mDATWrite(U1Bit,DO_DATA_IMMOBILIZERDiagEnabled, cFalse, Default);
   \   0060   A100           MOV       A,#0
   \   0062   9E....         MOV       bDO_DATA_IMMOBILIZERDiagEnabled,A
   \   0065   A10D           MOV       A,#13
   \   0067   ..             CALLT     [__T_DATTrpControl]
   \   0068   FA6E           BR        ??TreatEepromTest_Static_14
    734              }
    735              else
    736              {
    737                  mLIBassert(u8OutputNumberP < cPouOutputsNumber);
    738                  if(mDATReadTable(U1Bit,DATPouHardMaskBuffer,u16OutputTab[u8OutputNumberP],Default) == 1)
   \                     ??TreatEepromTest_Static_18:
   \   006A   A002           MOV       X,#2
   \   006C   3188           MULU      X
   \   006E   CA....         ADDW      AX,#u16OutputTab
   \   0071   D6             MOVW      HL,AX
   \   0072   AE01           MOV       A,[HL+0x01]
   \   0074   72             MOV       C,A
   \   0075   87             MOV       A,[HL]
   \   0076   16....         MOVW      HL,#S:DATPouHardMaskBuffer
   \   0079   73             MOV       B,A
   \   007A   AB             MOV       A,[HL+B]
   \   007B   70             MOV       X,A
   \   007C   A100           MOV       A,#0
   \   007E   9A....         CALL      ?SI_RSH_L02
   \   0081   60             MOV       A,X
   \   0082   310F11         BF        A.0, ??TreatEepromTest_Static_20
    739                  {
    740                      mSetOutputError(u8OutputNumberP);
   \   0085   64             MOV       A,E
   \   0086   72             MOV       C,A
   \   0087   100100         MOVW      AX,#1
   \   008A   ..             CALLT     [__T_?I_LSH_L02]
   \   008B   30             XCH       A,X
   \   008C   68....         OR        A,u16ErrorsOnOutput
   \   008F   30             XCH       A,X
   \   0090   68....         OR        A,u16ErrorsOnOutput+1
   \   0093   03....         MOVW      u16ErrorsOnOutput,AX
    741                  }
    742                  mDATWriteTable(U1Bit,DATPouDiagBuffer,u16OutputTab[u8OutputNumberP],0,Default);
   \                     ??TreatEepromTest_Static_20:
   \   0096   64             MOV       A,E
   \   0097   A002           MOV       X,#2
   \   0099   3188           MULU      X
   \   009B   CA....         ADDW      AX,#u16OutputTab
   \   009E   D6             MOVW      HL,AX
   \   009F   87             MOV       A,[HL]
   \   00A0   70             MOV       X,A
   \   00A1   AE01           MOV       A,[HL+0x01]
   \   00A3   75             MOV       D,A
   \   00A4   60             MOV       A,X
   \   00A5   35             XCH       A,D
   \   00A6   72             MOV       C,A
   \   00A7   100000         MOVW      AX,#0
   \   00AA   ..             CALLT     [__T_?I_LSH_L02]
   \   00AB   60             MOV       A,X
   \   00AC   73             MOV       B,A
   \   00AD   100100         MOVW      AX,#1
   \   00B0   ..             CALLT     [__T_?I_LSH_L02]
   \   00B1   60             MOV       A,X
   \   00B2   7DFF           XOR       A,#255
   \   00B4   70             MOV       X,A
   \   00B5   65             MOV       A,D
   \   00B6   16....         MOVW      HL,#S:DATPouDiagBuffer
   \   00B9   72             MOV       C,A
   \   00BA   AA             MOV       A,[HL+C]
   \   00BB   6158           AND       A,X
   \   00BD   616B           OR        A,B
   \   00BF   72             MOV       C,A
   \   00C0   C6             MOVW      AX,HL
   \   00C1   30             XCH       A,X
   \   00C2   610D           ADD       A,D
   \   00C4   30             XCH       A,X
   \   00C5   2D00           ADDC      A,#0
   \   00C7   D6             MOVW      HL,AX
   \   00C8   62             MOV       A,C
   \   00C9   97             MOV       [HL],A
    743          
    744                  if((u8OutputNumberP == cOPEN_DOOR_LEDOutputPos)
    745                   &&(mDATRead(U1Bit,IsAlaDiagEnabled, Default ) == cTrue) )
   \   00CA   64             MOV       A,E
   \   00CB   4D0A           CMP       A,#10
   \   00CD   BD09           BNZ       ??TreatEepromTest_Static_14
   \   00CF   8E....         MOV       A,bIsAlaDiagEnabled
   \   00D2   51             DEC       A
   \   00D3   BD03           BNZ       ??TreatEepromTest_Static_14
    746                  {            
    747                      TOSSendControl(cTOSControlAlaDiagDisable);
   \   00D5   A11C           MOV       A,#28
   \   00D7   ..             CALLT     [__T_TOSSendControl]
    748                  }
    749              }
    750          
    751          }
   \                     ??TreatEepromTest_Static_14:
   \   00D8   B2             POP       BC
   \   00D9   AF             RET       
   \   00DA                  REQUIRE ?CL78K_V4_6_L00
    752          
    753          //==============================================================================
    754          // DESCRIPTION:         IsOrderingMatrixDataValid
    755          //
    756          // PARAMETERS:          none
    757          //
    758          // RETURN VALUE:        BOOL
    759          //
    760          // DESIGN INFORMATION:  refer to Detailed Design Document
    761          //==============================================================================
    762          static MEM_TYPE BOOL IsOrderingMatrixDataValid(void)
    763          {
    764              BOOL  bIsDataValid;
    765              U8    u8IndexL;
    766          
    767              bIsDataValid = cTrue;
    768              for( u8IndexL = 0; bIsDataValid && (u8IndexL < LAPKwpReadDiagnosticRequest(cOrderingMatrixSizeBytePos));  )
    769              {
    770                  if(  ((U8)(LAPKwpReadDiagnosticRequest(cOrderingMatrixBytePos+ u8IndexL   )>>c4Bits) > cMaxQuarterOutput)  // Outputs
    771                     ||((U8)(LAPKwpReadDiagnosticRequest(cOrderingMatrixBytePos+(u8IndexL+1))>>c4Bits) > cMaxQuarterInput )) // Inputs
    772                  {
    773                      bIsDataValid = cFalse;
    774                  }
    775                  //QACJ 2469: akodzhh: keep for readability
    776                  u8IndexL += cMatrixPairLng;
    777              }
    778              
    779              return (bIsDataValid);
    780          }
    781          
    782          //==============================================================================
    783          // DESCRIPTION:         
    784          //
    785          // PARAMETERS:          none
    786          //
    787          // RETURN VALUE:        none
    788          //
    789          // DESIGN INFORMATION:  refer to Detailed Design Document
    790          //==============================================================================

   \                                 In  segment CODE, align 1, keep-with-next
    791          void ActivateOutputs(void)
   \                     ActivateOutputs:
    792          {
   \   0000                  ; * Stack frame (at entry) *
   \   0000                  ; Param size: 0
   \   0000   B5             PUSH      DE
   \   0001                  ; Total Auto size: 0
    793          #ifdef X90_PROJECT
    794              ActivateOutputs_Static();
   \   0001   16....         MOVW      HL,#LWRD(ActivateOutputs_Static)
   \   0004   A4..           MOV       E,#BYTE3(ActivateOutputs_Static)
   \   0006   ..             CALLT     [__T_?FAR_CALL_L07]
    795          }
   \   0007   B4             POP       DE
   \   0008   AF             RET       
   \   0009                  REQUIRE ?CL78K_V4_6_L00
    796          #pragma optimize=no_inline

   \                                 In  segment BCODE, align 1, keep-with-next
    797          static MEM_TYPE void ActivateOutputs_Static(void)
   \                     ActivateOutputs_Static:
    798          {
   \   0000                  ; * Stack frame (at entry) *
   \   0000                  ; Param size: 0
   \   0000   B3             PUSH      BC
   \   0001                  ; Total Auto size: 0
    799          #endif    
    800              U8      u8BitNumber;
    801              U8      u8OutputIndex;
    802              BOOL    bBitIsSet;
    803          
    804              for(u8BitNumber = 0; u8BitNumber < c4Bits; u8BitNumber++)
   \   0001   A200           MOV       C,#0
    805              {
    806                  bBitIsSet = ((u8OrderingMatrix[u8OrderingMatrixCounter] >> u8BitNumber)&1) == 1;
    807                  if (bBitIsSet == cTrue)
   \                     ??ActivateOutputs_Static_0:
   \   0003   8E....         MOV       A,u8OrderingMatrixCounter
   \   0006   73             MOV       B,A
   \   0007   16....         MOVW      HL,#u8OrderingMatrix
   \   000A   AB             MOV       A,[HL+B]
   \   000B   70             MOV       X,A
   \   000C   A100           MOV       A,#0
   \   000E   9A....         CALL      ?SI_RSH_L02
   \   0011   60             MOV       A,X
   \   0012   310F0E         BF        A.0, ??TreatEepromTest_Static_21
    808                  {
    809                      // quartermask 18 -> 1*4+ bit3 -> index=7
    810                      // quartermask 34 -> 3*4+ bit2 -> index=14
    811                      u8OutputIndex = (U8)(((u8OrderingMatrix[u8OrderingMatrixCounter] & cQuarterMask)>>c2Bits) | u8BitNumber); 
    812                      SetOutput(u8OutputIndex);
   \   0015   AB             MOV       A,[HL+B]
   \   0016   5DF0           AND       A,#240
   \   0018   21             CLR1      CY
   \   0019   25             RORC      A,0x1
   \   001A   25             RORC      A,0x1
   \   001B   616A           OR        A,C
   \   001D   16....         MOVW      HL,#LWRD(SetOutput)
   \   0020   A4..           MOV       E,#BYTE3(SetOutput)
   \   0022   ..             CALLT     [__T_?FAR_FAST_CALL_L07]
    813                  }
    814              }
   \                     ??TreatEepromTest_Static_21:
   \   0023   42             INC       C
   \   0024   62             MOV       A,C
   \   0025   4D04           CMP       A,#4
   \   0027   8DDA           BC        ??ActivateOutputs_Static_0
    815              
    816          
    817              AutoTestTimeOutValueInTick = mTOSConvMsInTimerTick((U32)u8AutoTestActivTimeOut);
   \   0029   8E....         MOV       A,u8AutoTestActivTimeOut
   \   002C   A20A           MOV       C,#10
   \   002E   70             MOV       X,A
   \   002F   A100           MOV       A,#0
   \   0031   3182           DIVUW     C
   \   0033   A100           MOV       A,#0
   \   0035   03....         MOVW      AutoTestTimeOutValueInTick,AX
    818              if(AutoTestTimeOutValueInTick > 0)
   \   0038   6168           OR        A,X
   \   003A   AD07           BZ        ??TreatEepromTest_Static_22
    819              {
    820                  // -1 tick because of Cm005756:TOS Timers introduce an additional delay of 1 graph/task cycle
    821                  AutoTestTimeOutValueInTick--;
   \   003C   8E....         MOV       A,AutoTestTimeOutValueInTick+1
   \   003F   90             DECW      AX
   \   0040   03....         MOVW      AutoTestTimeOutValueInTick,AX
    822              }
    823          
    824              TOSStartTimer(&AutoTestTimer);
   \                     ??TreatEepromTest_Static_22:
   \   0043   10....         MOVW      AX,#AutoTestTimer
   \   0046   ..             CALLT     [__T_TOSStartTimer]
    825          
    826              bOutputsActivated = cTrue;
   \   0047   A101           MOV       A,#1
   \   0049   9E....         MOV       bOutputsActivated,A
    827          }
   \   004C   B2             POP       BC
   \   004D   AF             RET       
   \   004E                  REQUIRE ?CL78K_V4_6_L00
    828          
    829          //==============================================================================
    830          // DESCRIPTION:         DeactivateOutputs
    831          //
    832          // PARAMETERS:          BOOL bSetResultsP
    833          //
    834          // RETURN VALUE:        none
    835          //
    836          // DESIGN INFORMATION:  refer to Detailed Design Document
    837          //==============================================================================

   \                                 In  segment BCODE, align 1, keep-with-next
    838          static MEM_TYPE void DeactivateOutputs(const BOOL bSetResultsP)
   \                     DeactivateOutputs:
    839          {
   \   0000                  ; * Stack frame (at entry) *
   \   0000                  ; Param size: 0
   \   0000   B3             PUSH      BC
   \   0001   B1             PUSH      AX
   \   0002                  ; Total Auto size: 2
    840              U8      u8BitNumber;
    841              U8      u8OutputIndex;
    842              BOOL    bBitIsSet;
    843          
    844              for(u8BitNumber = 0; u8BitNumber < c4Bits; u8BitNumber++)
   \   0002   A300           MOV       B,#0
    845              {
    846                  bBitIsSet = ((u8OrderingMatrix[u8OrderingMatrixCounter] >> u8BitNumber)&1) == 1;
    847                  if (bBitIsSet == cTrue)
   \                     ??DeactivateOutputs_0:
   \   0004   8E....         MOV       A,u8OrderingMatrixCounter
   \   0007   72             MOV       C,A
   \   0008   16....         MOVW      HL,#u8OrderingMatrix
   \   000B   AA             MOV       A,[HL+C]
   \   000C   70             MOV       X,A
   \   000D   A100           MOV       A,#0
   \   000F   72             MOV       C,A
   \   0010   63             MOV       A,B
   \   0011   32             XCH       A,C
   \   0012   9A....         CALL      ?SI_RSH_L02
   \   0015   60             MOV       A,X
   \   0016   310F23         BF        A.0, ??TreatEepromTest_Static_23
    848                  {
    849                      u8OutputIndex = (U8)(((u8OrderingMatrix[u8OrderingMatrixCounter] & cQuarterMask)>>c2Bits)| u8BitNumber);
   \   0019   8E....         MOV       A,u8OrderingMatrixCounter
   \   001C   72             MOV       C,A
   \   001D   AA             MOV       A,[HL+C]
   \   001E   5DF0           AND       A,#240
   \   0020   21             CLR1      CY
   \   0021   25             RORC      A,0x1
   \   0022   25             RORC      A,0x1
   \   0023   616B           OR        A,B
   \   0025   72             MOV       C,A
    850                      if(bSetResultsP == cTrue)
   \   0026   891C           MOVW      AX,SP
   \   0028   D6             MOVW      HL,AX
   \   0029   AE01           MOV       A,[HL+0x01]
   \   002B   51             DEC       A
   \   002C   62             MOV       A,C
   \   002D   BD07           BNZ       ??TreatEepromTest_Static_24
    851                      {
    852                          ClearOutputAndSetResult(u8OutputIndex);
   \   002F   16....         MOVW      HL,#LWRD(ClearOutputAndSetResult)
   \   0032   A4..           MOV       E,#BYTE3(ClearOutputAndSetResult)
   \   0034   FA05           BR        ??TreatEepromTest_Static_25
    853                      }
    854                      else
    855                      {
    856                          ClearOutput(u8OutputIndex);
   \                     ??TreatEepromTest_Static_24:
   \   0036   16....         MOVW      HL,#LWRD(ClearOutput)
   \   0039   A4..           MOV       E,#BYTE3(ClearOutput)
   \                     ??TreatEepromTest_Static_25:
   \   003B   ..             CALLT     [__T_?FAR_FAST_CALL_L07]
    857                      }
    858                  }
    859              }
   \                     ??TreatEepromTest_Static_23:
   \   003C   43             INC       B
   \   003D   63             MOV       A,B
   \   003E   4D04           CMP       A,#4
   \   0040   8DC2           BC        ??DeactivateOutputs_0
    860          
    861              bOutputsActivated = cFalse;
   \   0042   A100           MOV       A,#0
   \   0044   9E....         MOV       bOutputsActivated,A
    862          
    863          }
   \   0047   B0             POP       AX
   \   0048   B2             POP       BC
   \   0049   AF             RET       
   \   004A                  REQUIRE ?CL78K_V4_6_L00
    864          
    865          //==============================================================================
    866          // DESCRIPTION:         ReadInputsAndSetResult 
    867          //
    868          // PARAMETERS:          none
    869          //
    870          // RETURN VALUE:        BOOL
    871          //
    872          // DESIGN INFORMATION:  refer to Detailed Design Document
    873          //==============================================================================
    874          // akodzhh: Size of this function exceeds 100 lines.Keep for readability.

   \                                 In  segment BCODE, align 1, keep-with-next
    875          static MEM_TYPE BOOL ReadInputsAndSetResult(void)
   \                     ReadInputsAndSetResult:
    876          {
   \   0000                  ; * Stack frame (at entry) *
   \   0000                  ; Param size: 0
   \   0000   B3             PUSH      BC
   \   0001                  ; Total Auto size: 2
   \   0001   B7             PUSH      HL
    877              BOOL    bInputIsSet;
    878              U8      u8QuarterNb;
    879              BOOL    bAllExpectedInputsAreSet;
    880          
    881              u8QuarterNb = (U8)((u8OrderingMatrix[u8OrderingMatrixCounter+1]&cQuarterMask )>>c4Bits);
    882              bAllExpectedInputsAreSet = cTrue;
   \   0002   A201           MOV       C,#1
    883             
    884             
    885              switch(u8QuarterNb)
   \   0004   8E....         MOV       A,u8OrderingMatrixCounter
   \   0007   70             MOV       X,A
   \   0008   A100           MOV       A,#0
   \   000A   CA....         ADDW      AX,#u8OrderingMatrix
   \   000D   B6             POP       HL
   \   000E   B1             PUSH      AX
   \   000F   891C           MOVW      AX,SP
   \   0011   D6             MOVW      HL,AX
   \   0012   87             MOV       A,[HL]
   \   0013   70             MOV       X,A
   \   0014   AE01           MOV       A,[HL+0x01]
   \   0016   D6             MOVW      HL,AX
   \   0017   AE01           MOV       A,[HL+0x01]
   \   0019   74             MOV       E,A
   \   001A   24             ROR       A,0x1
   \   001B   25             RORC      A,0x1
   \   001C   25             RORC      A,0x1
   \   001D   25             RORC      A,0x1
   \   001E   5D0F           AND       A,#15
   \   0020   AD26           BZ        ??TreatEepromTest_Static_26
   \   0022   4D01           CMP       A,#1
   \   0024   BD03           BNZ       $+5
   \   0026   9B....         BR        N:??TreatEepromTest_Static_27
   \   0029   4D02           CMP       A,#2
   \   002B   BD03           BNZ       $+5
   \   002D   9B....         BR        N:??TreatEepromTest_Static_28
   \   0030   4D03           CMP       A,#3
   \   0032   BD03           BNZ       $+5
   \   0034   9B....         BR        N:??TreatEepromTest_Static_29
   \   0037   4D04           CMP       A,#4
   \   0039   BD03           BNZ       $+5
   \   003B   9B....         BR        N:??TreatEepromTest_Static_30
   \   003E   4D05           CMP       A,#5
   \   0040   BD03           BNZ       $+5
   \   0042   9B....         BR        N:??TreatEepromTest_Static_31
   \   0045   9B....         BR        N:??TreatEepromTest_Static_32
    886              {
    887              case cQuarter0:
    888                  if( (U8)(u8OrderingMatrix[u8OrderingMatrixCounter+1] & cMaskDI_ENGINE_RPM) ==  cMaskDI_ENGINE_RPM)  
   \                     ??TreatEepromTest_Static_26:
   \   0048   891C           MOVW      AX,SP
   \   004A   D6             MOVW      HL,AX
   \   004B   87             MOV       A,[HL]
   \   004C   70             MOV       X,A
   \   004D   AE01           MOV       A,[HL+0x01]
   \   004F   D6             MOVW      HL,AX
   \   0050   86             INCW      HL
   \   0051   31871D         BF        [HL].0, ??TreatEepromTest_Static_33
    889                  {
    890                      bInputIsSet = (BOOL)( mDATRead(U1Bit, DI_ENGINE_RPM , Default)&1 );
    891                      if( bInputIsSet == cFalse )
   \   0054   8C..1A         BT        S:DATDinInputBuffers+7.0, ??TreatEepromTest_Static_33
    892                      {    
    893                          mSetInputError(cIndexDI_ENGINE_RPM);
   \   0057   100000         MOVW      AX,#0
   \   005A   B1             PUSH      AX
   \   005B   80             INCW      AX
   \   005C   B1             PUSH      AX
   \   005D   02....         MOVW      AX,u32ErrorsOnInput
   \   0060   D2             MOVW      BC,AX
   \   0061   02....         MOVW      AX,u32ErrorsOnInput+2
   \   0064   E2             XCHW      AX,BC
   \   0065   9A....         CALL      ?L_IOR_L03
   \   0068   03....         MOVW      u32ErrorsOnInput,AX
   \   006B   C2             MOVW      AX,BC
   \   006C   03....         MOVW      u32ErrorsOnInput+2,AX
    894                          bAllExpectedInputsAreSet = cFalse;
   \   006F   A200           MOV       C,#0
    895                      }
    896                  }
    897                  if( (U8)(u8OrderingMatrix[u8OrderingMatrixCounter+1] & cMaskPWR_IGN) ==  cMaskPWR_IGN)  
   \                     ??TreatEepromTest_Static_33:
   \   0071   891C           MOVW      AX,SP
   \   0073   D6             MOVW      HL,AX
   \   0074   87             MOV       A,[HL]
   \   0075   70             MOV       X,A
   \   0076   AE01           MOV       A,[HL+0x01]
   \   0078   D6             MOVW      HL,AX
   \   0079   86             INCW      HL
   \   007A   31971E         BF        [HL].1, ??TreatEepromTest_Static_34
    898                  {
    899                      bInputIsSet = (BOOL)( mDATRead(U1Bit, PWR_IGN, Default)&1 );
    900                      if( bInputIsSet == cFalse )
   \   007D   8C..1B         BT        S:DATDinInputBuffers+6.0, ??TreatEepromTest_Static_34
    901                      {
    902                          mSetInputError(cIndexPWR_IGN);
   \   0080   100000         MOVW      AX,#0
   \   0083   B1             PUSH      AX
   \   0084   A002           MOV       X,#2
   \   0086   B1             PUSH      AX
   \   0087   02....         MOVW      AX,u32ErrorsOnInput
   \   008A   D2             MOVW      BC,AX
   \   008B   02....         MOVW      AX,u32ErrorsOnInput+2
   \   008E   E2             XCHW      AX,BC
   \   008F   9A....         CALL      ?L_IOR_L03
   \   0092   03....         MOVW      u32ErrorsOnInput,AX
   \   0095   C2             MOVW      AX,BC
   \   0096   03....         MOVW      u32ErrorsOnInput+2,AX
    903                          bAllExpectedInputsAreSet = cFalse;
   \   0099   A200           MOV       C,#0
    904                      } 
    905                  }
    906                  if( (U8)(u8OrderingMatrix[u8OrderingMatrixCounter+1] & cMaskRR_WASHER_SW) ==  cMaskRR_WASHER_SW)  
   \                     ??TreatEepromTest_Static_34:
   \   009B   891C           MOVW      AX,SP
   \   009D   D6             MOVW      HL,AX
   \   009E   87             MOV       A,[HL]
   \   009F   70             MOV       X,A
   \   00A0   AE01           MOV       A,[HL+0x01]
   \   00A2   D6             MOVW      HL,AX
   \   00A3   86             INCW      HL
   \   00A4   31A71E         BF        [HL].2, ??TreatEepromTest_Static_35
    907                  {
    908                      bInputIsSet = (BOOL)( mDATRead(U1Bit, RR_WASHER_SW, Default)&1 );
    909                      if( bInputIsSet == cFalse )
   \   00A7   AC..1B         BT        S:DATDinInputBuffers+5.2, ??TreatEepromTest_Static_35
    910                      {
    911                          mSetInputError(cIndexRR_WASHER_SW);
   \   00AA   100000         MOVW      AX,#0
   \   00AD   B1             PUSH      AX
   \   00AE   A004           MOV       X,#4
   \   00B0   B1             PUSH      AX
   \   00B1   02....         MOVW      AX,u32ErrorsOnInput
   \   00B4   D2             MOVW      BC,AX
   \   00B5   02....         MOVW      AX,u32ErrorsOnInput+2
   \   00B8   E2             XCHW      AX,BC
   \   00B9   9A....         CALL      ?L_IOR_L03
   \   00BC   03....         MOVW      u32ErrorsOnInput,AX
   \   00BF   C2             MOVW      AX,BC
   \   00C0   03....         MOVW      u32ErrorsOnInput+2,AX
    912                          bAllExpectedInputsAreSet = cFalse;
   \   00C3   A200           MOV       C,#0
    913                      } 
    914                  }
    915                  if( (U8)(u8OrderingMatrix[u8OrderingMatrixCounter+1] & cMaskFR_FOG_SW) ==  cMaskFR_FOG_SW)  
   \                     ??TreatEepromTest_Static_35:
   \   00C5   891C           MOVW      AX,SP
   \   00C7   D6             MOVW      HL,AX
   \   00C8   87             MOV       A,[HL]
   \   00C9   70             MOV       X,A
   \   00CA   AE01           MOV       A,[HL+0x01]
   \   00CC   D6             MOVW      HL,AX
   \   00CD   86             INCW      HL
   \   00CE   31B603         BT        [HL].3, $+6
   \   00D1   9B....         BR        N:??TreatEepromTest_Static_36
    916                  {
    917                      bInputIsSet = (BOOL)( mDATRead(U1Bit, HIGH_LOW_BEAM, Default)&1 );
    918                      if( bInputIsSet == cFalse )
   \   00D4   3103..03       BF        S:DATDinInputBuffers+5.0, $+7
   \   00D8   9B....         BR        N:??TreatEepromTest_Static_36
    919                      {
    920                          mSetInputError(cIndexFR_FOG_SW);
   \   00DB   100000         MOVW      AX,#0
   \   00DE   B1             PUSH      AX
   \   00DF   A008           MOV       X,#8
   \   00E1   B1             PUSH      AX
   \   00E2   02....         MOVW      AX,u32ErrorsOnInput
   \   00E5   D2             MOVW      BC,AX
   \   00E6   02....         MOVW      AX,u32ErrorsOnInput+2
   \   00E9   E2             XCHW      AX,BC
   \   00EA   9A....         CALL      ?L_IOR_L03
   \   00ED   9B....         BR        N:??TreatEepromTest_Static_37
    921                          bAllExpectedInputsAreSet = cFalse;
    922                      } 
    923                  }
    924                  break;
    925              case cQuarter1:
    926                  if( (U8)(u8OrderingMatrix[u8OrderingMatrixCounter+1] & cMaskDI_DATA_IMMOBILIZER) ==  cMaskDI_DATA_IMMOBILIZER)  
   \                     ??TreatEepromTest_Static_27:
   \   00F0   64             MOV       A,E
   \   00F1   5D11           AND       A,#17
   \   00F3   4D11           CMP       A,#17
   \   00F5   BD1E           BNZ       ??TreatEepromTest_Static_38
    927                  {
    928                      bInputIsSet = (BOOL)( mDATRead(U1Bit, DI_DATA_IMMOBILIZER, Default)&1 );
    929                      if( bInputIsSet == cFalse )
   \   00F7   DC..1B         BT        S:DATDinInputBuffers.5, ??TreatEepromTest_Static_38
    930                      {
    931                          mSetInputError(cIndexDI_DATA_IMMOBILIZER);
   \   00FA   100000         MOVW      AX,#0
   \   00FD   B1             PUSH      AX
   \   00FE   A010           MOV       X,#16
   \   0100   B1             PUSH      AX
   \   0101   02....         MOVW      AX,u32ErrorsOnInput
   \   0104   D2             MOVW      BC,AX
   \   0105   02....         MOVW      AX,u32ErrorsOnInput+2
   \   0108   E2             XCHW      AX,BC
   \   0109   9A....         CALL      ?L_IOR_L03
   \   010C   03....         MOVW      u32ErrorsOnInput,AX
   \   010F   C2             MOVW      AX,BC
   \   0110   03....         MOVW      u32ErrorsOnInput+2,AX
    932                          bAllExpectedInputsAreSet = cFalse; 
   \   0113   A200           MOV       C,#0
    933                      }
    934                  }
    935                  if( (U8)(u8OrderingMatrix[u8OrderingMatrixCounter+1] & cMaskDI_VERLOG) ==  cMaskDI_VERLOG)  
   \                     ??TreatEepromTest_Static_38:
   \   0115   64             MOV       A,E
   \   0116   5D12           AND       A,#18
   \   0118   4D12           CMP       A,#18
   \   011A   BD1E           BNZ       ??TreatEepromTest_Static_39
    936                  {
    937                      bInputIsSet = (BOOL)( mDATRead(U1Bit, DI_VERLOG, Default)&1 );
    938                      if( bInputIsSet == cFalse )
   \   011C   8C..1B         BT        S:DATDinInputBuffers+2.0, ??TreatEepromTest_Static_39
    939                      {
    940                          mSetInputError(cIndexDI_VERLOG);
   \   011F   100000         MOVW      AX,#0
   \   0122   B1             PUSH      AX
   \   0123   A020           MOV       X,#32
   \   0125   B1             PUSH      AX
   \   0126   02....         MOVW      AX,u32ErrorsOnInput
   \   0129   D2             MOVW      BC,AX
   \   012A   02....         MOVW      AX,u32ErrorsOnInput+2
   \   012D   E2             XCHW      AX,BC
   \   012E   9A....         CALL      ?L_IOR_L03
   \   0131   03....         MOVW      u32ErrorsOnInput,AX
   \   0134   C2             MOVW      AX,BC
   \   0135   03....         MOVW      u32ErrorsOnInput+2,AX
    941                          bAllExpectedInputsAreSet = cFalse;
   \   0138   A200           MOV       C,#0
    942                      } 
    943                  }
    944                  if( (U8)(u8OrderingMatrix[u8OrderingMatrixCounter+1] & cMaskL_FLASHER_SW) ==  cMaskL_FLASHER_SW)  
   \                     ??TreatEepromTest_Static_39:
   \   013A   64             MOV       A,E
   \   013B   5D14           AND       A,#20
   \   013D   4D14           CMP       A,#20
   \   013F   BD1E           BNZ       ??TreatEepromTest_Static_40
    945                  {
    946                      bInputIsSet = (BOOL)( mDATRead(U1Bit, L_FLASHER_SW, Default)&1 );
    947                      if( bInputIsSet == cFalse )
   \   0141   BC..1B         BT        S:DATDinInputBuffers+3.3, ??TreatEepromTest_Static_40
    948                      {
    949                          mSetInputError(cIndexL_FLASHER_SW);
   \   0144   100000         MOVW      AX,#0
   \   0147   B1             PUSH      AX
   \   0148   A040           MOV       X,#64
   \   014A   B1             PUSH      AX
   \   014B   02....         MOVW      AX,u32ErrorsOnInput
   \   014E   D2             MOVW      BC,AX
   \   014F   02....         MOVW      AX,u32ErrorsOnInput+2
   \   0152   E2             XCHW      AX,BC
   \   0153   9A....         CALL      ?L_IOR_L03
   \   0156   03....         MOVW      u32ErrorsOnInput,AX
   \   0159   C2             MOVW      AX,BC
   \   015A   03....         MOVW      u32ErrorsOnInput+2,AX
    950                          bAllExpectedInputsAreSet = cFalse;
   \   015D   A200           MOV       C,#0
    951                      } 
    952                  }
    953                  if( (U8)(u8OrderingMatrix[u8OrderingMatrixCounter+1] & cMaskFR_DOORS_SW) ==  cMaskFR_DOORS_SW)  
   \                     ??TreatEepromTest_Static_40:
   \   015F   64             MOV       A,E
   \   0160   5D18           AND       A,#24
   \   0162   4D18           CMP       A,#24
   \   0164   AD03           BZ        $+5
   \   0166   9B....         BR        N:??TreatEepromTest_Static_36
    954                  {
    955                      bInputIsSet = (BOOL)( mDATRead(U1Bit, FR_DOORS_SW, Default)&1 );
    956                      if( bInputIsSet == cFalse )
   \   0169   3133..03       BF        S:DATDinInputBuffers+6.3, $+7
   \   016D   9B....         BR        N:??TreatEepromTest_Static_36
    957                      {
    958                          mSetInputError(cIndexFR_DOORS_SW);
   \   0170   100000         MOVW      AX,#0
   \   0173   B1             PUSH      AX
   \   0174   A080           MOV       X,#128
   \   0176   B1             PUSH      AX
   \   0177   02....         MOVW      AX,u32ErrorsOnInput
   \   017A   D2             MOVW      BC,AX
   \   017B   02....         MOVW      AX,u32ErrorsOnInput+2
   \   017E   E2             XCHW      AX,BC
   \   017F   9A....         CALL      ?L_IOR_L03
   \   0182   9B....         BR        N:??TreatEepromTest_Static_37
    959                          bAllExpectedInputsAreSet = cFalse;
    960                      } 
    961                  }
    962                  break;
    963              case cQuarter2:
    964                  if( (U8)(u8OrderingMatrix[u8OrderingMatrixCounter+1] & cMaskDOOR_LOCK_SW) ==  cMaskDOOR_LOCK_SW)  
   \                     ??TreatEepromTest_Static_28:
   \   0185   64             MOV       A,E
   \   0186   5D21           AND       A,#33
   \   0188   4D21           CMP       A,#33
   \   018A   BD1E           BNZ       ??TreatEepromTest_Static_41
    965                  {
    966                      bInputIsSet = (BOOL)( mDATRead(U1Bit, DOOR_LOCK_SW, Default)&1 );
    967                      if( bInputIsSet == cFalse )
   \   018C   CC..1B         BT        S:DATDinInputBuffers+6.4, ??TreatEepromTest_Static_41
    968                      {
    969                          mSetInputError(cIndexDOOR_LOCK_SW);
   \   018F   100000         MOVW      AX,#0
   \   0192   B1             PUSH      AX
   \   0193   A101           MOV       A,#1
   \   0195   B1             PUSH      AX
   \   0196   02....         MOVW      AX,u32ErrorsOnInput
   \   0199   D2             MOVW      BC,AX
   \   019A   02....         MOVW      AX,u32ErrorsOnInput+2
   \   019D   E2             XCHW      AX,BC
   \   019E   9A....         CALL      ?L_IOR_L03
   \   01A1   03....         MOVW      u32ErrorsOnInput,AX
   \   01A4   C2             MOVW      AX,BC
   \   01A5   03....         MOVW      u32ErrorsOnInput+2,AX
    970                          bAllExpectedInputsAreSet = cFalse;
   \   01A8   A200           MOV       C,#0
    971                      } 
    972                  }
    973                  if( (U8)(u8OrderingMatrix[u8OrderingMatrixCounter+1] & cMaskFR_WIPER_INT_SW) ==  cMaskFR_WIPER_INT_SW)  
   \                     ??TreatEepromTest_Static_41:
   \   01AA   64             MOV       A,E
   \   01AB   5D22           AND       A,#34
   \   01AD   4D22           CMP       A,#34
   \   01AF   BD1E           BNZ       ??TreatEepromTest_Static_42
    974                  {
    975                      bInputIsSet = (BOOL)( mDATRead(U1Bit, FR_WIPER_INT_SW, Default)&1 );
    976                      if( bInputIsSet == cFalse )
   \   01B1   AC..1B         BT        S:DATDinInputBuffers+8.2, ??TreatEepromTest_Static_42
    977                      {
    978                          mSetInputError(cIndexFR_WIPER_INT_SW);
   \   01B4   100000         MOVW      AX,#0
   \   01B7   B1             PUSH      AX
   \   01B8   A102           MOV       A,#2
   \   01BA   B1             PUSH      AX
   \   01BB   02....         MOVW      AX,u32ErrorsOnInput
   \   01BE   D2             MOVW      BC,AX
   \   01BF   02....         MOVW      AX,u32ErrorsOnInput+2
   \   01C2   E2             XCHW      AX,BC
   \   01C3   9A....         CALL      ?L_IOR_L03
   \   01C6   03....         MOVW      u32ErrorsOnInput,AX
   \   01C9   C2             MOVW      AX,BC
   \   01CA   03....         MOVW      u32ErrorsOnInput+2,AX
    979                          bAllExpectedInputsAreSet = cFalse;
   \   01CD   A200           MOV       C,#0
    980                      } 
    981                  }
    982                  if( (U8)(u8OrderingMatrix[u8OrderingMatrixCounter+1] & cMaskRR_FOG_SW) ==  cMaskRR_FOG_SW)  
   \                     ??TreatEepromTest_Static_42:
   \   01CF   64             MOV       A,E
   \   01D0   5D24           AND       A,#36
   \   01D2   4D24           CMP       A,#36
   \   01D4   BD1E           BNZ       ??TreatEepromTest_Static_43
    983                  {
    984                      bInputIsSet = (BOOL)( mDATRead(U1Bit, RR_FOG_SW, Default)&1 );
    985                      if( bInputIsSet == cFalse )
   \   01D6   9C..1B         BT        S:DATDinInputBuffers+5.1, ??TreatEepromTest_Static_43
    986                      {
    987                          mSetInputError(cIndexRR_FOG_SW);
   \   01D9   100000         MOVW      AX,#0
   \   01DC   B1             PUSH      AX
   \   01DD   A104           MOV       A,#4
   \   01DF   B1             PUSH      AX
   \   01E0   02....         MOVW      AX,u32ErrorsOnInput
   \   01E3   D2             MOVW      BC,AX
   \   01E4   02....         MOVW      AX,u32ErrorsOnInput+2
   \   01E7   E2             XCHW      AX,BC
   \   01E8   9A....         CALL      ?L_IOR_L03
   \   01EB   03....         MOVW      u32ErrorsOnInput,AX
   \   01EE   C2             MOVW      AX,BC
   \   01EF   03....         MOVW      u32ErrorsOnInput+2,AX
    988                          bAllExpectedInputsAreSet = cFalse;
   \   01F2   A200           MOV       C,#0
    989                      } 
    990                  }
    991                  if( (U8)(u8OrderingMatrix[u8OrderingMatrixCounter+1] & cMaskFR_WASHER_SW) ==  cMaskFR_WASHER_SW)  
   \                     ??TreatEepromTest_Static_43:
   \   01F4   64             MOV       A,E
   \   01F5   5D28           AND       A,#40
   \   01F7   4D28           CMP       A,#40
   \   01F9   AD03           BZ        $+5
   \   01FB   9B....         BR        N:??TreatEepromTest_Static_36
    992                  {
    993                      bInputIsSet = (BOOL)( mDATRead(U1Bit, FR_WASHER_SW, Default)&1 );
    994                      if( bInputIsSet == cFalse )
   \   01FE   3103..03       BF        S:DATDinInputBuffers+4.0, $+7
   \   0202   9B....         BR        N:??TreatEepromTest_Static_36
    995                      {
    996                          mSetInputError(cIndexFR_WASHER_SW);
   \   0205   100000         MOVW      AX,#0
   \   0208   B1             PUSH      AX
   \   0209   A108           MOV       A,#8
   \   020B   B1             PUSH      AX
   \   020C   02....         MOVW      AX,u32ErrorsOnInput
   \   020F   D2             MOVW      BC,AX
   \   0210   02....         MOVW      AX,u32ErrorsOnInput+2
   \   0213   E2             XCHW      AX,BC
   \   0214   9A....         CALL      ?L_IOR_L03
   \   0217   9B....         BR        N:??TreatEepromTest_Static_37
    997                          bAllExpectedInputsAreSet = cFalse;
    998                      } 
    999                  }
   1000                  break;
   1001              case cQuarter3:
   1002                  if( (U8)(u8OrderingMatrix[u8OrderingMatrixCounter+1] & cMaskAIRBAG_CRASH) ==  cMaskAIRBAG_CRASH)  
   \                     ??TreatEepromTest_Static_29:
   \   021A   64             MOV       A,E
   \   021B   5D31           AND       A,#49
   \   021D   4D31           CMP       A,#49
   \   021F   BD1E           BNZ       ??TreatEepromTest_Static_44
   1003                  {
   1004                      bInputIsSet = (BOOL)( mDATRead(U1Bit, AIRBAG_CRASH, Default)&1 );
   1005                      if( bInputIsSet == cFalse )
   \   0221   9C..1B         BT        S:DATDinInputBuffers.1, ??TreatEepromTest_Static_44
   1006                      {
   1007                          mSetInputError(cIndexAIRBAG_CRASH);
   \   0224   100000         MOVW      AX,#0
   \   0227   B1             PUSH      AX
   \   0228   A110           MOV       A,#16
   \   022A   B1             PUSH      AX
   \   022B   02....         MOVW      AX,u32ErrorsOnInput
   \   022E   D2             MOVW      BC,AX
   \   022F   02....         MOVW      AX,u32ErrorsOnInput+2
   \   0232   E2             XCHW      AX,BC
   \   0233   9A....         CALL      ?L_IOR_L03
   \   0236   03....         MOVW      u32ErrorsOnInput,AX
   \   0239   C2             MOVW      AX,BC
   \   023A   03....         MOVW      u32ErrorsOnInput+2,AX
   1008                          bAllExpectedInputsAreSet = cFalse;
   \   023D   A200           MOV       C,#0
   1009                      } 
   1010                  }
   1011                  if( (U8)(u8OrderingMatrix[u8OrderingMatrixCounter+1] & cMaskVEHICLE_SPEED) ==  cMaskVEHICLE_SPEED)  
   \                     ??TreatEepromTest_Static_44:
   \   023F   64             MOV       A,E
   \   0240   5D32           AND       A,#50
   \   0242   4D32           CMP       A,#50
   \   0244   BD1E           BNZ       ??TreatEepromTest_Static_45
   1012                  {
   1013                      bInputIsSet = (BOOL)( mDATRead(U1Bit, DI_VEHICLE_SPEED, Default)&1 );
   1014                      if( bInputIsSet == cFalse )
   \   0246   BC..1B         BT        S:DATDinInputBuffers+2.3, ??TreatEepromTest_Static_45
   1015                      {
   1016                          mSetInputError(cIndexVEHICLE_SPEED);
   \   0249   100000         MOVW      AX,#0
   \   024C   B1             PUSH      AX
   \   024D   A120           MOV       A,#32
   \   024F   B1             PUSH      AX
   \   0250   02....         MOVW      AX,u32ErrorsOnInput
   \   0253   D2             MOVW      BC,AX
   \   0254   02....         MOVW      AX,u32ErrorsOnInput+2
   \   0257   E2             XCHW      AX,BC
   \   0258   9A....         CALL      ?L_IOR_L03
   \   025B   03....         MOVW      u32ErrorsOnInput,AX
   \   025E   C2             MOVW      AX,BC
   \   025F   03....         MOVW      u32ErrorsOnInput+2,AX
   1017                          bAllExpectedInputsAreSet = cFalse;
   \   0262   A200           MOV       C,#0
   1018                      } 
   1019                  }
   1020                  if( (U8)(u8OrderingMatrix[u8OrderingMatrixCounter+1] & cMaskFR_AUTOSTOP_SW) ==  cMaskFR_AUTOSTOP_SW)  
   \                     ??TreatEepromTest_Static_45:
   \   0264   64             MOV       A,E
   \   0265   5D34           AND       A,#52
   \   0267   4D34           CMP       A,#52
   \   0269   BD1E           BNZ       ??TreatEepromTest_Static_46
   1021                  {
   1022                      bInputIsSet = (BOOL)( mDATRead(U1Bit, FR_AUTOSTOP_SW, Default)&1 );
   1023                      if( bInputIsSet == cFalse )
   \   026B   AC..1B         BT        S:DATDinInputBuffers+2.2, ??TreatEepromTest_Static_46
   1024                      {
   1025                          mSetInputError(cIndexFR_AUTOSTOP_SW);
   \   026E   100000         MOVW      AX,#0
   \   0271   B1             PUSH      AX
   \   0272   A140           MOV       A,#64
   \   0274   B1             PUSH      AX
   \   0275   02....         MOVW      AX,u32ErrorsOnInput
   \   0278   D2             MOVW      BC,AX
   \   0279   02....         MOVW      AX,u32ErrorsOnInput+2
   \   027C   E2             XCHW      AX,BC
   \   027D   9A....         CALL      ?L_IOR_L03
   \   0280   03....         MOVW      u32ErrorsOnInput,AX
   \   0283   C2             MOVW      AX,BC
   \   0284   03....         MOVW      u32ErrorsOnInput+2,AX
   1026                          bAllExpectedInputsAreSet = cFalse;
   \   0287   A200           MOV       C,#0
   1027                      } 
   1028                  }
   1029                  if( (U8)(u8OrderingMatrix[u8OrderingMatrixCounter+1] & cMaskRR_AUTOSTOP_SW) ==  cMaskRR_AUTOSTOP_SW)  
   \                     ??TreatEepromTest_Static_46:
   \   0289   64             MOV       A,E
   \   028A   5D38           AND       A,#56
   \   028C   4D38           CMP       A,#56
   \   028E   AD03           BZ        $+5
   \   0290   9B....         BR        N:??TreatEepromTest_Static_36
   1030                  {
   1031                      bInputIsSet = (BOOL)( mDATRead(U1Bit, RR_AUTOSTOP_SW, Default)&1 );
   1032                      if( bInputIsSet == cFalse )
   \   0293   3113..03       BF        S:DATDinInputBuffers+2.1, $+7
   \   0297   9B....         BR        N:??TreatEepromTest_Static_36
   1033                      {
   1034                          mSetInputError(cIndexRR_AUTOSTOP_SW);
   \   029A   100000         MOVW      AX,#0
   \   029D   B1             PUSH      AX
   \   029E   A180           MOV       A,#128
   \   02A0   B1             PUSH      AX
   \   02A1   02....         MOVW      AX,u32ErrorsOnInput
   \   02A4   D2             MOVW      BC,AX
   \   02A5   02....         MOVW      AX,u32ErrorsOnInput+2
   \   02A8   E2             XCHW      AX,BC
   \   02A9   9A....         CALL      ?L_IOR_L03
   \   02AC   9B....         BR        N:??TreatEepromTest_Static_37
   1035                          bAllExpectedInputsAreSet = cFalse;
   1036                      } 
   1037                  }
   1038                  break;
   1039              case cQuarter4:
   1040                  if( (U8)(u8OrderingMatrix[u8OrderingMatrixCounter+1] & cMaskHAZARD_SW) ==  cMaskHAZARD_SW)  
   \                     ??TreatEepromTest_Static_30:
   \   02AF   64             MOV       A,E
   \   02B0   5D41           AND       A,#65
   \   02B2   4D41           CMP       A,#65
   \   02B4   BD1D           BNZ       ??TreatEepromTest_Static_47
   1041                  {
   1042                      bInputIsSet = (BOOL)( mDATRead(U1Bit, HAZARD_SW, Default)&1 );
   1043                      if( bInputIsSet == cFalse )
   \   02B6   CC..1A         BT        S:DATDinInputBuffers+1.4, ??TreatEepromTest_Static_47
   1044                      {
   1045                          mSetInputError(cIndexHAZARD_SW);
   \   02B9   100100         MOVW      AX,#1
   \   02BC   B1             PUSH      AX
   \   02BD   70             MOV       X,A
   \   02BE   B1             PUSH      AX
   \   02BF   02....         MOVW      AX,u32ErrorsOnInput
   \   02C2   D2             MOVW      BC,AX
   \   02C3   02....         MOVW      AX,u32ErrorsOnInput+2
   \   02C6   E2             XCHW      AX,BC
   \   02C7   9A....         CALL      ?L_IOR_L03
   \   02CA   03....         MOVW      u32ErrorsOnInput,AX
   \   02CD   C2             MOVW      AX,BC
   \   02CE   03....         MOVW      u32ErrorsOnInput+2,AX
   1046                          bAllExpectedInputsAreSet = cFalse;
   \   02D1   A200           MOV       C,#0
   1047                      } 
   1048                  }
   1049                  if( (U8)(u8OrderingMatrix[u8OrderingMatrixCounter+1] & cMaskR_FLASHER_SW) ==  cMaskR_FLASHER_SW)  
   \                     ??TreatEepromTest_Static_47:
   \   02D3   64             MOV       A,E
   \   02D4   5D42           AND       A,#66
   \   02D6   4D42           CMP       A,#66
   \   02D8   BD1D           BNZ       ??TreatEepromTest_Static_48
   1050                  {
   1051                      bInputIsSet = (BOOL)( mDATRead(U1Bit, R_FLASHER_SW, Default)&1 );
   1052                      if( bInputIsSet == cFalse )
   \   02DA   AC..1A         BT        S:DATDinInputBuffers+3.2, ??TreatEepromTest_Static_48
   1053                      {
   1054                          mSetInputError(cIndexR_FLASHER_SW);
   \   02DD   100200         MOVW      AX,#2
   \   02E0   B1             PUSH      AX
   \   02E1   70             MOV       X,A
   \   02E2   B1             PUSH      AX
   \   02E3   02....         MOVW      AX,u32ErrorsOnInput
   \   02E6   D2             MOVW      BC,AX
   \   02E7   02....         MOVW      AX,u32ErrorsOnInput+2
   \   02EA   E2             XCHW      AX,BC
   \   02EB   9A....         CALL      ?L_IOR_L03
   \   02EE   03....         MOVW      u32ErrorsOnInput,AX
   \   02F1   C2             MOVW      AX,BC
   \   02F2   03....         MOVW      u32ErrorsOnInput+2,AX
   1055                          bAllExpectedInputsAreSet = cFalse;
   \   02F5   A200           MOV       C,#0
   1056                      } 
   1057                  }
   1058                  if( (U8)(u8OrderingMatrix[u8OrderingMatrixCounter+1] & cMaskRR_WIPER_INT_SW) ==  cMaskRR_WIPER_INT_SW)  
   \                     ??TreatEepromTest_Static_48:
   \   02F7   64             MOV       A,E
   \   02F8   5D44           AND       A,#68
   \   02FA   4D44           CMP       A,#68
   \   02FC   BD1D           BNZ       ??TreatEepromTest_Static_49
   1059                  {
   1060                      bInputIsSet = (BOOL)( mDATRead(U1Bit, RR_WIPER_INT_SW, Default)&1 );
   1061                      if( bInputIsSet == cFalse )
   \   02FE   BC..1A         BT        S:DATDinInputBuffers+5.3, ??TreatEepromTest_Static_49
   1062                      {
   1063                          mSetInputError(cIndexRR_WIPER_INT_SW);
   \   0301   100400         MOVW      AX,#4
   \   0304   B1             PUSH      AX
   \   0305   70             MOV       X,A
   \   0306   B1             PUSH      AX
   \   0307   02....         MOVW      AX,u32ErrorsOnInput
   \   030A   D2             MOVW      BC,AX
   \   030B   02....         MOVW      AX,u32ErrorsOnInput+2
   \   030E   E2             XCHW      AX,BC
   \   030F   9A....         CALL      ?L_IOR_L03
   \   0312   03....         MOVW      u32ErrorsOnInput,AX
   \   0315   C2             MOVW      AX,BC
   \   0316   03....         MOVW      u32ErrorsOnInput+2,AX
   1064                          bAllExpectedInputsAreSet = cFalse;
   \   0319   A200           MOV       C,#0
   1065                      } 
   1066                  }
   1067                  if( (U8)(u8OrderingMatrix[u8OrderingMatrixCounter+1] & cMaskPOSITION_LIGHTS) ==  cMaskPOSITION_LIGHTS)  
   \                     ??TreatEepromTest_Static_49:
   \   031B   64             MOV       A,E
   \   031C   5D48           AND       A,#72
   \   031E   4D48           CMP       A,#72
   \   0320   AD03           BZ        $+5
   \   0322   9B....         BR        N:??TreatEepromTest_Static_36
   1068                  {
   1069                      bInputIsSet = (BOOL)( mDATRead(U1Bit, POSITION_LIGHTS, Default)&1 );
   1070                      if( bInputIsSet == cFalse )
   \   0325   3133..03       BF        S:DATDinInputBuffers+4.3, $+7
   \   0329   9B....         BR        N:??TreatEepromTest_Static_36
   1071                      {
   1072                          mSetInputError(cIndexPOSITION_LIGHTS);
   \   032C   100800         MOVW      AX,#8
   \   032F   B1             PUSH      AX
   \   0330   70             MOV       X,A
   \   0331   B1             PUSH      AX
   \   0332   02....         MOVW      AX,u32ErrorsOnInput
   \   0335   D2             MOVW      BC,AX
   \   0336   02....         MOVW      AX,u32ErrorsOnInput+2
   \   0339   E2             XCHW      AX,BC
   \   033A   9A....         CALL      ?L_IOR_L03
   \   033D   9B....         BR        N:??TreatEepromTest_Static_37
   1073                          bAllExpectedInputsAreSet = cFalse;
   1074                      }
   1075                  }
   1076                  break;
   1077              case cQuarter5:
   1078                  if( (U8)(u8OrderingMatrix[u8OrderingMatrixCounter+1] & cMaskRR_DOORS_SW) ==  cMaskRR_DOORS_SW)  
   \                     ??TreatEepromTest_Static_31:
   \   0340   64             MOV       A,E
   \   0341   5D51           AND       A,#81
   \   0343   4D51           CMP       A,#81
   \   0345   BD1D           BNZ       ??TreatEepromTest_Static_50
   1079                  {
   1080                      bInputIsSet = (BOOL)( mDATRead(U1Bit, RR_DOORS_SW, Default)&1 ); 
   1081                      if( bInputIsSet == cFalse )
   \   0347   8C..1A         BT        S:DATDinInputBuffers+8.0, ??TreatEepromTest_Static_50
   1082                      {
   1083                          mSetInputError(cIndexRR_DOORS_SW);
   \   034A   101000         MOVW      AX,#16
   \   034D   B1             PUSH      AX
   \   034E   70             MOV       X,A
   \   034F   B1             PUSH      AX
   \   0350   02....         MOVW      AX,u32ErrorsOnInput
   \   0353   D2             MOVW      BC,AX
   \   0354   02....         MOVW      AX,u32ErrorsOnInput+2
   \   0357   E2             XCHW      AX,BC
   \   0358   9A....         CALL      ?L_IOR_L03
   \   035B   03....         MOVW      u32ErrorsOnInput,AX
   \   035E   C2             MOVW      AX,BC
   \   035F   03....         MOVW      u32ErrorsOnInput+2,AX
   1084                          bAllExpectedInputsAreSet = cFalse;
   \   0362   A200           MOV       C,#0
   1085                      } 
   1086                  }
   1087                  if( (U8)(u8OrderingMatrix[u8OrderingMatrixCounter+1] & cMaskDOOR_UNLOCK_SW) ==  cMaskDOOR_UNLOCK_SW)  
   \                     ??TreatEepromTest_Static_50:
   \   0364   64             MOV       A,E
   \   0365   5D52           AND       A,#82
   \   0367   4D52           CMP       A,#82
   \   0369   BD1D           BNZ       ??TreatEepromTest_Static_51
   1088                  {
   1089                      bInputIsSet = (BOOL)( mDATRead(U1Bit, DOOR_UNLOCK_SW, Default)&1 );
   1090                      if( bInputIsSet == cFalse )
   \   036B   9C..1A         BT        S:DATDinInputBuffers+8.1, ??TreatEepromTest_Static_51
   1091                      {
   1092                          mSetInputError(cIndexDOOR_UNLOCK_SW);
   \   036E   102000         MOVW      AX,#32
   \   0371   B1             PUSH      AX
   \   0372   70             MOV       X,A
   \   0373   B1             PUSH      AX
   \   0374   02....         MOVW      AX,u32ErrorsOnInput
   \   0377   D2             MOVW      BC,AX
   \   0378   02....         MOVW      AX,u32ErrorsOnInput+2
   \   037B   E2             XCHW      AX,BC
   \   037C   9A....         CALL      ?L_IOR_L03
   \   037F   03....         MOVW      u32ErrorsOnInput,AX
   \   0382   C2             MOVW      AX,BC
   \   0383   03....         MOVW      u32ErrorsOnInput+2,AX
   1093                          bAllExpectedInputsAreSet = cFalse;
   \   0386   A200           MOV       C,#0
   1094                      } 
   1095                  }
   1096                  if( (U8)(u8OrderingMatrix[u8OrderingMatrixCounter+1] & cMaskDEFROSTER_SW) ==  cMaskDEFROSTER_SW)  
   \                     ??TreatEepromTest_Static_51:
   \   0388   64             MOV       A,E
   \   0389   5D54           AND       A,#84
   \   038B   4D54           CMP       A,#84
   \   038D   BD1D           BNZ       ??TreatEepromTest_Static_52
   1097                  {
   1098                      bInputIsSet = (BOOL)( mDATRead(U1Bit, DEFROSTER_SW, Default)&1 );
   1099                      if( bInputIsSet == cFalse )
   \   038F   8C..1A         BT        S:DATDinInputBuffers+3.0, ??TreatEepromTest_Static_52
   1100                      {
   1101                          mSetInputError(cIndexDEFROSTER_SW);
   \   0392   104000         MOVW      AX,#64
   \   0395   B1             PUSH      AX
   \   0396   70             MOV       X,A
   \   0397   B1             PUSH      AX
   \   0398   02....         MOVW      AX,u32ErrorsOnInput
   \   039B   D2             MOVW      BC,AX
   \   039C   02....         MOVW      AX,u32ErrorsOnInput+2
   \   039F   E2             XCHW      AX,BC
   \   03A0   9A....         CALL      ?L_IOR_L03
   \   03A3   03....         MOVW      u32ErrorsOnInput,AX
   \   03A6   C2             MOVW      AX,BC
   \   03A7   03....         MOVW      u32ErrorsOnInput+2,AX
   1102                          bAllExpectedInputsAreSet = cFalse;
   \   03AA   A200           MOV       C,#0
   1103                      } 
   1104                  }
   1105                  if( (U8)(u8OrderingMatrix[u8OrderingMatrixCounter+1] & cMaskSEATBELT_REMINDER_SW ) ==  cMaskSEATBELT_REMINDER_SW)
   \                     ??TreatEepromTest_Static_52:
   \   03AC   64             MOV       A,E
   \   03AD   5D58           AND       A,#88
   \   03AF   4D58           CMP       A,#88
   \   03B1   BD1D           BNZ       ??TreatEepromTest_Static_36
   1106                  {
   1107                      bInputIsSet = (BOOL)( mDATRead(U1Bit, SEATBELT_REMINDER_SW, Default)&1 );
   1108                      if( bInputIsSet == cFalse )
   \   03B3   9C..1A         BT        S:DATDinInputBuffers+4.1, ??TreatEepromTest_Static_36
   1109                      {
   1110                          mSetInputError(cIndexSEATBELT_REMINDER_SW);
   \   03B6   108000         MOVW      AX,#128
   \   03B9   B1             PUSH      AX
   \   03BA   70             MOV       X,A
   \   03BB   B1             PUSH      AX
   \   03BC   02....         MOVW      AX,u32ErrorsOnInput
   \   03BF   D2             MOVW      BC,AX
   \   03C0   02....         MOVW      AX,u32ErrorsOnInput+2
   \   03C3   E2             XCHW      AX,BC
   \   03C4   9A....         CALL      ?L_IOR_L03
   \                     ??TreatEepromTest_Static_37:
   \   03C7   03....         MOVW      u32ErrorsOnInput,AX
   \   03CA   C2             MOVW      AX,BC
   \   03CB   03....         MOVW      u32ErrorsOnInput+2,AX
   1111                          bAllExpectedInputsAreSet = cFalse;
   1112                      } 
   1113                  }
   1114                  break;
   1115              
   1116              default:
   1117                  //CCOV: akodzhh: can't be covered, no other Quarter
   1118                  mLIBassert(cFalse);
   1119                  bAllExpectedInputsAreSet = cFalse;
   \                     ??TreatEepromTest_Static_32:
   \   03CE   A200           MOV       C,#0
   1120                  break;
   1121              }
   1122          
   1123              return bAllExpectedInputsAreSet;
   \                     ??TreatEepromTest_Static_36:
   \   03D0   62             MOV       A,C
   \   03D1   B2             POP       BC
   \   03D2   B2             POP       BC
   \   03D3   AF             RET       
   \   03D4                  REQUIRE ?CL78K_V4_6_L00
   1124             
   1125          }
   1126          
   1127          #ifdef BOOTLOADER_IS_SUPPORTED
   1128          //==============================================================================
   1129          // DESCRIPTION:         ReadECU_LOG
   1130          //
   1131          // PARAMETERS:          None
   1132          //
   1133          // RETURN VALUE:        U8 Request Status
   1134          //
   1135          // DESIGN INFORMATION:  refer to Detailed Design Document
   1136          //==============================================================================

   \                                 In  segment BCODE, align 1, keep-with-next
   1137          static MEM_TYPE U8 ReadECU_LOG (void)
   \                     ReadECU_LOG:
   1138          {
   \   0000                  ; * Stack frame (at entry) *
   \   0000                  ; Param size: 0
   \   0000   B3             PUSH      BC
   \   0001                  ; Total Auto size: 48
   \   0001   ..             CALLT     [__T_?FUNC_ENTER_L06]
   \   0002   3000           DW        0x30
   1139              U8 u8RequestStatusL;
   1140              BOOL bResult;
   1141              //QACJ 3672: akodzhh: Pointer value is correct
   1142              tpRetreiveLogZoneRecord RetreiveLogZoneRecord;
   1143          
   1144              U8 IdentRecordL[cLogZoneSize];
   1145              U8 ReprogRecordL[cLogZoneSize];
   1146              U8* pSvcResponseL;
   1147              U8 u8IndexL;
   1148          
   1149              //QACJ 0305: akodzhh: Cast is intentional and safety
   1150              if ((BOOL)mLAPKwpCheckBootloaderPresent() != cFalse)
   \   0004   020C68         MOVW      AX,0x680C
   \   0007   EA6F42         CMPW      AX,#17007
   \   000A   BD2D           BNZ       ??TreatEepromTest_Static_53
   \   000C   020E68         MOVW      AX,0x680E
   \   000F   EA746F         CMPW      AX,#28532
   \   0012   BD25           BNZ       ??TreatEepromTest_Static_53
   1151              {
   1152                  RetreiveLogZoneRecord = 
   1153                      ((tBootLinkTable*)cLIBBooBootLinkTableAddress)->pRetreiveLogZoneRecord;
   \   0014   020268         MOVW      AX,0x6802
   \   0017   D4             MOVW      DE,AX
   1154          
   1155                  // call bootloader function to read log zone
   1156                  bResult = RetreiveLogZoneRecord(IdentRecordL, cLastLogZoneId); // IDENT
   1157          
   1158                  if (bResult != cFalse)
   \   0018   A3FE           MOV       B,#254
   \   001A   891C           MOVW      AX,SP
   \   001C   B1             PUSH      AX
   \   001D   C4             MOVW      AX,DE
   \   001E   D6             MOVW      HL,AX
   \   001F   B0             POP       AX
   \   0020   9A....         CALL      ?IND_CALL_L06
   \   0023   4D00           CMP       A,#0
   \   0025   AD12           BZ        ??TreatEepromTest_Static_53
   1159                  {
   1160                      bResult = RetreiveLogZoneRecord(ReprogRecordL, (U8)(cLastLogZoneId + (U8)1U)); // REPROG
   1161                  }
   1162                  
   1163                  if( bResult == cFalse )
   \   0027   A3FF           MOV       B,#255
   \   0029   891C           MOVW      AX,SP
   \   002B   CA1800         ADDW      AX,#24
   \   002E   B1             PUSH      AX
   \   002F   C4             MOVW      AX,DE
   \   0030   D6             MOVW      HL,AX
   \   0031   B0             POP       AX
   \   0032   9A....         CALL      ?IND_CALL_L06
   \   0035   4D00           CMP       A,#0
   \   0037   BD04           BNZ       ??TreatEepromTest_Static_54
   1164                  {
   1165                      u8RequestStatusL = cLAPKwpInvalidFormat;
   \                     ??TreatEepromTest_Static_53:
   \   0039   A212           MOV       C,#18
   \   003B   FA5A           BR        ??TreatEepromTest_Static_55
   1166                  }
   1167                  else
   1168                  {
   1169                      u8RequestStatusL = cLAPKwpServiceIsCorrect;
   \                     ??TreatEepromTest_Static_54:
   \   003D   A200           MOV       C,#0
   1170          
   1171                      // Copy data from log zone into response //
   1172          
   1173                      pSvcResponseL = LAPKwpGetPtrDiagnosticResponse(cByte2);
   1174                      u8IndexL = 0;
   1175          
   1176                      // Copy ECU reference / part number
   1177                      mLIBmemcpy(pSvcResponseL , &IdentRecordL[cLogZoneSparePartNumberIndex], cEEP_ECUReferenceLength);
   \   003F   891C           MOVW      AX,SP
   \   0041   D4             MOVW      DE,AX
   \   0042   16....         MOVW      HL,#DATKwpTxBuffer+5
   \   0045   A305           MOV       B,#5
   \                     ??ReadECU_LOG_0:
   \   0047   85             MOV       A,[DE]
   \   0048   97             MOV       [HL],A
   \   0049   86             INCW      HL
   \   004A   84             INCW      DE
   \   004B   8BFA           DBNZ      B, ??ReadECU_LOG_0
   1178                      u8IndexL += cEEP_ECUReferenceLength;
   1179          
   1180                      // Copy PIE number / HW number
   1181                      mLIBmemcpy(&pSvcResponseL[u8IndexL], &IdentRecordL[cLogZoneHwNumberIndex], cEEP_PieNumberLength);
   \   004D   891C           MOVW      AX,SP
   \   004F   CA0900         ADDW      AX,#9
   \   0052   D4             MOVW      DE,AX
   \   0053   16....         MOVW      HL,#DATKwpTxBuffer+10
   \   0056   A305           MOV       B,#5
   \                     ??ReadECU_LOG_1:
   \   0058   85             MOV       A,[DE]
   \   0059   97             MOV       [HL],A
   \   005A   86             INCW      HL
   \   005B   84             INCW      DE
   \   005C   8BFA           DBNZ      B, ??ReadECU_LOG_1
   1182                      u8IndexL += cEEP_PieNumberLength;
   1183          
   1184                      // Copy PIE index / calibration number
   1185                      pSvcResponseL[u8IndexL] = IdentRecordL[cLogZoneCalibrationNumberIndex];
   \   005E   891C           MOVW      AX,SP
   \   0060   CA1200         ADDW      AX,#18
   \   0063   D6             MOVW      HL,AX
   \   0064   87             MOV       A,[HL]
   \   0065   9E....         MOV       DATKwpTxBuffer+15,A
   1186                      u8IndexL++;
   1187                      pSvcResponseL[u8IndexL] = IdentRecordL[cLogZoneCalibrationNumberIndex + 1U];
   \   0068   AE01           MOV       A,[HL+0x01]
   \   006A   9E....         MOV       DATKwpTxBuffer+16,A
   1188                      u8IndexL++;
   1189          
   1190                      // Copy serial number
   1191                      mLIBmemcpy(&pSvcResponseL[u8IndexL], &IdentRecordL[cLogZoneSerialNumberIndex], cEEP_SerialNumberLength);
   \   006D   891C           MOVW      AX,SP
   \   006F   CA1500         ADDW      AX,#21
   \   0072   D4             MOVW      DE,AX
   \   0073   16....         MOVW      HL,#DATKwpTxBuffer+17
   \   0076   A303           MOV       B,#3
   \                     ??ReadECU_LOG_2:
   \   0078   85             MOV       A,[DE]
   \   0079   97             MOV       [HL],A
   \   007A   86             INCW      HL
   \   007B   84             INCW      DE
   \   007C   8BFA           DBNZ      B, ??ReadECU_LOG_2
   1192                      u8IndexL += cEEP_SerialNumberLength;
   1193          
   1194                      // Copy date code
   1195                      mLIBmemcpy(&pSvcResponseL[u8IndexL], &ReprogRecordL[cLogZoneDateIndex], cEEP_DateCodeLength + 1);
   \   007E   891C           MOVW      AX,SP
   \   0080   CA2800         ADDW      AX,#40
   \   0083   D4             MOVW      DE,AX
   \   0084   16....         MOVW      HL,#DATKwpTxBuffer+20
   \   0087   A303           MOV       B,#3
   \                     ??ReadECU_LOG_3:
   \   0089   85             MOV       A,[DE]
   \   008A   97             MOV       [HL],A
   \   008B   86             INCW      HL
   \   008C   84             INCW      DE
   \   008D   8BFA           DBNZ      B, ??ReadECU_LOG_3
   1196                      u8IndexL += cEEP_DateCodeLength + 1;
   1197          
   1198                      // Copy ECU Type
   1199                      pSvcResponseL[u8IndexL] = IdentRecordL[cLogZoneEcuTypeIndex];
   \   008F   891C           MOVW      AX,SP
   \   0091   D6             MOVW      HL,AX
   \   0092   AE14           MOV       A,[HL+0x14]
   \   0094   9E....         MOV       DATKwpTxBuffer+23,A
   1200                  }        
   1201              }
   1202              else // bootloader not present
   1203              {
   1204                  u8RequestStatusL = cLAPKwpInvalidFormat;
   1205              }
   1206              return u8RequestStatusL;
   \                     ??TreatEepromTest_Static_55:
   \   0097   62             MOV       A,C
   \   0098   ..             CALLT     [__T_?FUNC_DEALL_L06]
   \   0099   3000           DW        0x30
   \   009B   B2             POP       BC
   \   009C   AF             RET       
   \   009D                  REQUIRE ?CL78K_V4_6_L00
   1207          }
   1208          #endif // BOOTLOADER_IS_SUPPORTED
   1209          
   1210          
   1211          //==============================================================================
   1212          //=========================== EXPORTED FUNCTIONS ===============================
   1213          //==============================================================================
   1214          //==============================================================================
   1215          // DESCRIPTION:         LAPTfcTreatReadDataByLocalIdentifierService
   1216          //
   1217          // PARAMETERS:          none
   1218          //
   1219          // RETURN VALUE:        none
   1220          //
   1221          // DESIGN INFORMATION:  refer to Detailed Design Document
   1222          //==============================================================================
   1223          // akodzhh: Size of this function exceeds 100 lines. It is AW1092 reuse, keep for readability.

   \                                 In  segment BCODE, align 1, keep-with-next
   1224          MEM_TYPE void LAPTfcTreatReadDataByLocalIdentifierService(void)
   \                     LAPTfcTreatReadDataByLocalIdentifierService:
   1225          {  
   \   0000                  ; * Stack frame (at entry) *
   \   0000                  ; Param size: 0
   \   0000   B3             PUSH      BC
   \   0001                  ; Total Auto size: 2
   \   0001   B7             PUSH      HL
   1226              U8  u8RequestStatus;
   1227              U8  u8ResponseLength;
   1228              U16 u16Checksum;
   1229              U8  u8Index;
   1230              U8  u8TempVar;
   1231              U8  u8ByteNb;
   1232            
   1233              u8ResponseLength = 0;
   1234              u8RequestStatus = cLAPKwpServiceIsCorrect;
   \   0002   A200           MOV       C,#0
   1235              if(  ((mDATRead(U8Bit,DATKwpRxFrameLgth,Default) == cRDBLIDReq_Lgth)
   1236                  &&(LAPKwpReadDiagnosticRequest(1) != cRDBLID_AnalogValueID ))
   1237                 ||((mDATRead(U8Bit,DATKwpRxFrameLgth,Default) == cRDBLIDReq_AnalogValueLgth)
   1238                  &&(LAPKwpReadDiagnosticRequest(1) == cRDBLID_AnalogValueID ) ))
   \   0004   8E....         MOV       A,DATKwpRxFrameLgth
   \   0007   4D02           CMP       A,#2
   \   0009   BD0F           BNZ       ??TreatEepromTest_Static_56
   \   000B   8E....         MOV       A,DATKwpRxBuffer+4
   \   000E   4D92           CMP       A,#146
   \   0010   AD03           BZ        $+5
   \   0012   9B....         BR        N:??TreatEepromTest_Static_57
   1239              {  
   1240                  switch (LAPKwpReadDiagnosticRequest(1))
   1241                  {
   1242          
   1243                  case cRDBLID_SoftwareAndTFCVersionID :
   1244                      u8ByteNb = cByte2;  // first data byte in response
   1245                      // Software version and revision
   1246                      LAPKwpWriteDiagnosticResponse(u8ByteNb,mDATRead(U8Bit,TfcVersionNum,Default));
   1247                      u8ByteNb++;
   1248                      LAPKwpWriteDiagnosticResponse(u8ByteNb,mDATRead(U8Bit,TfcRevisionNum,Default));
   1249                      u8ByteNb++;
   1250          
   1251          
   1252                      // EEP version and revision 
   1253                      LAPKwpWriteDiagnosticResponse(u8ByteNb,mDATRead(U8Bit,EEP_VersionEEPROM,Default));
   1254                      u8ByteNb++;
   1255                      LAPKwpWriteDiagnosticResponse(u8ByteNb,mDATRead(U8Bit,EEP_RevisionEEPROM,Default));
   1256                      u8ByteNb++;
   1257          
   1258                      // Checksum  
   1259                      u16Checksum = ROMChecksumCalculation();  
   1260                      LAPKwpWriteDiagnosticResponse(u8ByteNb,0x00);
   1261                      u8ByteNb++;
   1262                      LAPKwpWriteDiagnosticResponse(u8ByteNb,0x00);
   1263                      u8ByteNb++;
   1264                      LAPKwpWriteDiagnosticResponse(u8ByteNb,(((U8)(u16Checksum>>c8Bits ) &cLSBMask)));
   1265                      u8ByteNb++;
   1266                      LAPKwpWriteDiagnosticResponse(u8ByteNb,(((U8)(u16Checksum    ) &cLSBMask)));
   1267          
   1268          
   1269                      u8ResponseLength = cRDBLIDAns_SoftwareAndTFCVersion_Lgth;
   1270                      break;
   1271          
   1272                  case cRDBLID_TFCDataID :
   1273                      // MPR
   1274                      u8TempVar = ReadECU_LOG();
   1275                      //CCOV adzhelp: Bootloader is not available in unit test framework
   1276                      if (u8TempVar == cLAPKwpServiceIsCorrect)
   1277                      {
   1278                          // if Date is present in EEP substitute log zone content
   1279                          if (  (mDATReadTable(U8Bit,EEP_DateCode, 0,Default) != 0)
   1280                              ||(mDATReadTable(U8Bit,EEP_DateCode, 1,Default) != 0) )
   1281                          {
   1282                              LAPKwpWriteDiagnosticResponse(((U8)cDateCodeIndex+(U8)cByte0), 0);
   1283                              LAPKwpWriteDiagnosticResponse(((U8)cDateCodeIndex+(U8)cByte1), 
   1284                                  mDATReadTable(U8Bit, EEP_DateCode, 0U, Default));
   1285                              LAPKwpWriteDiagnosticResponse(((U8)cDateCodeIndex+(U8)cByte2), 
   1286                                  mDATReadTable(U8Bit, EEP_DateCode, 1U, Default));
   1287                          }
   1288                          // Serial number is obtained from EEP if it exists
   1289                          if (   (mDATReadTable(U8Bit, EEP_SerialNumber, cByte0, Default) != 0) 
   1290                               ||(mDATReadTable(U8Bit, EEP_SerialNumber, cByte1, Default) != 0) 
   1291                               ||(mDATReadTable(U8Bit, EEP_SerialNumber, cByte2, Default) != 0) )
   1292                          {
   1293                              // Serial number exists in EEP, use it
   1294                              for (u8Index = 0; u8Index < cEEP_SerialNumberLength; u8Index++)
   1295                              {
   1296                                  LAPKwpWriteDiagnosticResponse(((U8)cSerialNumberIndex+(U8)u8Index),
   1297                                      mDATReadTable(U8Bit, EEP_SerialNumber, u8Index, Default));
   1298                              }
   1299                          }
   1300                      }
   1301                      else
   1302                      {
   1303                      #if defined(COMPILATION_NATIVE) || defined(UTEST) || defined(DEBUG)
   1304                          u8ByteNb = cByte2;
   1305          
   1306                          // ECU reference cannot be obtained from log zone, get it from ROM
   1307                          for (u8Index=0; u8Index<cEEP_ECUReferenceLength; u8Index++)
   1308                          {
   1309                              LAPKwpWriteDiagnosticResponse(u8ByteNb+u8Index,mDATReadTable(U8Bit,EEP_ECUReference,u8Index,Default));
   1310                          }
   1311          
   1312                          u8ByteNb += cEEP_ECUReferenceLength;
   1313                          // PIE
   1314                          for (u8Index=0; u8Index<cEEP_PieNumberLength; u8Index++)
   1315                          {
   1316                              LAPKwpWriteDiagnosticResponse(u8ByteNb+u8Index,mDATReadTable(U8Bit,EEP_PieNumber,u8Index,Default));
   1317                          }
   1318                          u8ByteNb += cEEP_PieNumberLength;
   1319                          // Indice PIE
   1320                          for (u8Index=0; u8Index<cEEP_PieIndexLength; u8Index++)
   1321                          {
   1322                              LAPKwpWriteDiagnosticResponse(u8ByteNb+u8Index,mDATReadTable(U8Bit,EEP_PieIndex,u8Index,Default));
   1323                          }
   1324                          u8ByteNb += cEEP_PieIndexLength;
   1325                          // Numro de srie
   1326                          for (u8Index=0; u8Index<cEEP_SerialNumberLength; u8Index++)
   1327                          {
   1328                              LAPKwpWriteDiagnosticResponse(u8ByteNb+u8Index,mDATReadTable(U8Bit,EEP_SerialNumber,u8Index,Default));
   1329                          }
   1330                          u8ByteNb += cEEP_SerialNumberLength;
   1331                          // Code date
   1332                          LAPKwpWriteDiagnosticResponse(u8ByteNb, 0);
   1333                          u8ByteNb++; // date is placed in LSBs
   1334                          for (u8Index=0; u8Index<cEEP_DateCodeLength; u8Index++)
   1335                          {
   1336                              LAPKwpWriteDiagnosticResponse(u8ByteNb+u8Index,mDATReadTable(U8Bit,EEP_DateCode,u8Index,Default));
   1337                          }
   1338                          u8ByteNb += cEEP_DateCodeLength;    
   1339                          LAPKwpWriteDiagnosticResponse(u8ByteNb,mDATRead(U8Bit,EEP_ECUType,Default));
   1340                          
   1341                      #else
   1342                          // target with no bootloader
   1343                          u8RequestStatus = cLAPKwpConditionNotCorrect;
   1344                      #endif
   1345                      }
   1346          
   1347                      u8ByteNb = cInSituTestCounterIndex;
   1348                      
   1349                      // Cmpt passage Test Final
   1350                      LAPKwpWriteDiagnosticResponse(u8ByteNb,mDATRead(U8Bit,EEP_InSituTestCounter,Default));
   1351                      u8ByteNb++;
   1352                      // FunctTestCounter              
   1353                      LAPKwpWriteDiagnosticResponse(u8ByteNb,mDATRead(U8Bit,EEP_PassingTestCounter  ,Default));
   1354                      u8ByteNb++;
   1355                      // RunningTestCounter
   1356                      LAPKwpWriteDiagnosticResponse(u8ByteNb,mDATRead(U8Bit,EEP_ReliabilityTestCounter,Default));
   1357                      u8ByteNb++;
   1358                      LAPKwpWriteDiagnosticResponse(u8ByteNb,mDATRead(U8Bit,EEP_RfTestCounter     ,Default));
   1359                      u8ByteNb++;
   1360                      LAPKwpWriteDiagnosticResponse(u8ByteNb,mDATRead(U8Bit,EEP_FinalTestCounter  ,Default));
   1361                      u8ByteNb++;
   1362          
   1363                      LAPKwpWriteDiagnosticResponse(u8ByteNb,mDATRead(U8Bit,EEP_FlaCoeffLNormal , Default));
   1364                      u8ByteNb++;
   1365                      LAPKwpWriteDiagnosticResponse(u8ByteNb,mDATRead(U8Bit,EEP_FlaCoeffRNormal , Default));
   1366          
   1367                      u8ResponseLength = cRDBLIDAns_TFCData_Lgth;
   1368                      break;
   1369          
   1370                  case cRDBLID_DigitalInputsID :
   1371                      u8ByteNb = cByte2;    
   1372                      //QACJ 3198: akodzhh: Variable is initialized and then modified bit by bit before being used
   1373                      u8TempVar = 0x00; // Byte 1
   1374                      u8TempVar =  (mDATRead(U1Bit, DI_ENGINE_RPM ,Default ) << 0)    // DI_ENGINE_RPM (P14.0)
   1375                                  |(mDATRead(U1Bit, PWR_IGN       ,Default ) << 1)    // APC / WAKE-UP_BCM (P0.1)
   1376                                  // Fixed value
   1377                                  |(mDATRead(U1Bit, RR_WASHER_SW        ,Default ) << c3Bits)    // DI_CMD_REAR_WASHER (P0.3)
   1378                                  |(mDATRead(U1Bit, HIGH_LOW_BEAM       ,Default ) << c4Bits)    // DI_CTC_FRONT_FOG / DI_CTC_LOW-HIGH_BEAM (P0.4)
   1379                                  |(mDATRead(U1Bit, DI_DATA_IMMOBILIZER ,Default ) << c5Bits)    // RX_DIO_IMOBILIZER (P0.5)
   1380                                  // Fixed value
   1381                                  |(mDATRead(U1Bit, DI_VERLOG     , Default ) << c7Bits);   // RX_DIO_ECM_MOTOR (P1.7)
   1382                      LAPKwpWriteDiagnosticResponse(u8ByteNb,u8TempVar);
   1383                      u8ByteNb++;
   1384          
   1385                      //QACJ 3198: akodzhh: Variable is initialized and then modified bit by bit before being used
   1386                      u8TempVar = 0x00; // Byte 2
   1387                      u8TempVar =   (mDATRead(U1Bit, L_FLASHER_SW      , Default ) << 0)    // DI_CMD_LEFT_INDICATOR (P12.0)
   1388                                   // Fixed value
   1389                                   // Fixed value
   1390                                   |(mDATRead(U1Bit, FR_DOORS_SW       , Default ) << c3Bits)    // DI_CTC_FRONT_DOORS (P12.3)
   1391                                   |(mDATRead(U1Bit, DOOR_LOCK_SW      , Default ) << c4Bits)    // DI_CMD_DOOR-LOCK (P12.4)
   1392                                   |(mDATRead(U1Bit, FR_WIPER_INT_SW   , Default ) << c5Bits)    // DI_CMD_FRONT_WIPER_INT (P2.5)  - !!!Ana
   1393                                   |(mDATRead(U1Bit, RR_FOG_SW         , Default ) << c6Bits)    // DI_CTC_REAR_FOG (P2.6)
   1394                                   |(mDATRead(U1Bit, FR_WASHER_SW      , Default ) << c7Bits);   // DI_CMD_FRONT_WASHER (P2.7)
   1395                      LAPKwpWriteDiagnosticResponse(u8ByteNb,u8TempVar);
   1396                      u8ByteNb++;
   1397          
   1398                      //QACJ 3198: akodzhh: Variable is initialized and then modified bit by bit before being used
   1399                      u8TempVar = 0x00;// Byte 3
   1400                      u8TempVar =   (mDATRead(U1Bit, AIRBAG_CRASH     , Default ) << 0)    // DI_AIRBAG_CRASH (P3.0)
   1401                                   |(mDATRead(U1Bit, DI_VEHICLE_SPEED , Default ) << 1)    // DI_VEHICLE_SPEED (P3.1)    - !!!
   1402                                   |(mDATRead(U1Bit, FR_AUTOSTOP_SW   , Default ) << c2Bits)    // DI_RELAY_FRONT_WIPER_STOP_CAR (P3.2)  - !!!
   1403                                   |(mDATRead(U1Bit, RR_AUTOSTOP_SW   , Default ) << c3Bits)    // DI_CTC_REAR_WIPER_STOP (P3.3) - !!!
   1404                                  // Fixed value
   1405                                  // Fixed value
   1406                                   |(mDATRead(U1Bit, HAZARD_SW        , Default ) << c6Bits)    // DI_CMD_WARNING (P4.2) - !!!
   1407                                   |(mDATRead(U1Bit, R_FLASHER_SW     , Default ) << c7Bits);   // DI_CMD_RIGHT_INDICATOR (P4.3)
   1408                      LAPKwpWriteDiagnosticResponse(u8ByteNb,u8TempVar);
   1409                      u8ByteNb++;
   1410          
   1411                      //QACJ 3198: akodzhh: Variable is initialized and then modified bit by bit before being used
   1412                      u8TempVar = 0x00; // Byte 4
   1413                      u8TempVar =  (mDATRead(U1Bit, RR_WIPER_INT_SW       , Default ) << 1)    // DI_CMD_REAR_WIPER (P5.1) - ???
   1414                                  // Fixed value
   1415                                   |(mDATRead(U1Bit, POSITION_LIGHTS      , Default ) << c3Bits)    // DI_CTC_DIMMERS (P5.3)   - !!!
   1416                                   |(mDATRead(U1Bit, RR_DOORS_SW          , Default ) << c4Bits)    // DI_CTC_REAR_DOOR (P6.0)
   1417                                   |(mDATRead(U1Bit, DOOR_UNLOCK_SW       , Default ) << c5Bits)    // DI_CMD_DOOR-UNLOCK (P6.1)
   1418                                   |(mDATRead(U1Bit, DEFROSTER_SW         , Default ) << c6Bits)    // DI_CMD_DEFROSTER (P6.2)
   1419                                   |(mDATRead(U1Bit, SEATBELT_REMINDER_SW , Default ) << c7Bits);   // DI_CTC_SEAT-BELT (P6.3)
   1420                      LAPKwpWriteDiagnosticResponse(u8ByteNb,u8TempVar);
   1421          
   1422                      u8ResponseLength = cRDBLIDAns_DigitalInputs_Lgth;
   1423                      break;
   1424          
   1425                  case cRDBLID_AnalogValueID :
   1426                      if(   (LAPKwpReadDiagnosticRequest(cByte2)== cReadingOptionDirect)
   1427                          ||(LAPKwpReadDiagnosticRequest(cByte2)== cReadingOptionCorrection))
   1428                      {
   1429                          u8ByteNb = cByte2;
   1430                          LAPKwpWriteDiagnosticResponse(u8ByteNb,  LAPKwpReadDiagnosticRequest(cByte2));  // #3 ReadingOption
   1431                          u8ByteNb++;
   1432                          LAPKwpWriteDiagnosticResponse(u8ByteNb,  (U8)((mDATRead(U16Bit, BATTERY_VOLTAGE, Immediate) & cu16MSBMask)  >> c8Bits));
   1433                          u8ByteNb++;
   1434                          LAPKwpWriteDiagnosticResponse(u8ByteNb,  (U8)( mDATRead(U16Bit, BATTERY_VOLTAGE, Immediate) & cu16LSBMask));
   1435                          u8ByteNb++;
   1436                          LAPKwpWriteDiagnosticResponse(u8ByteNb,  (U8)((mDATRead(U16Bit, ULQCurrentInMilliAmpers, Immediate) & cu16MSBMask)  >> c8Bits));
   1437                          u8ByteNb++;
   1438                          LAPKwpWriteDiagnosticResponse(u8ByteNb,  (U8)( mDATRead(U16Bit, ULQCurrentInMilliAmpers, Immediate) & cu16LSBMask)); 
   1439                          u8ByteNb++;
   1440                          LAPKwpWriteDiagnosticResponse(u8ByteNb,  (U8)((mDATRead(U16Bit, KlaxonCurrentInMilliAmpers, Immediate) & cu16MSBMask)  >> c8Bits));
   1441                          u8ByteNb++;
   1442                          LAPKwpWriteDiagnosticResponse(u8ByteNb,  (U8)( mDATRead(U16Bit, KlaxonCurrentInMilliAmpers, Immediate) & cu16LSBMask)); 
   1443                          u8ByteNb++;
   1444                          LAPKwpWriteDiagnosticResponse(u8ByteNb,  (U8)((mDATRead(U16Bit, FlashersCurrentInMilliAmpers, Immediate) & cu16MSBMask)  >> c8Bits));
   1445                          u8ByteNb++;
   1446                          LAPKwpWriteDiagnosticResponse(u8ByteNb, (U8)( mDATRead(U16Bit, FlashersCurrentInMilliAmpers, Immediate) & cu16LSBMask)); 
   1447                          u8ByteNb++;
   1448                          LAPKwpWriteDiagnosticResponse(u8ByteNb, (U8)((mDATRead(U16Bit, PDOInMilliVolt, Immediate) & cu16MSBMask)  >> c8Bits));
   1449                          u8ByteNb++;
   1450                          LAPKwpWriteDiagnosticResponse(u8ByteNb, (U8)( mDATRead(U16Bit, PDOInMilliVolt, Immediate) & cu16LSBMask)); 
   1451                          u8ByteNb++;
   1452                          LAPKwpWriteDiagnosticResponse(u8ByteNb, 0x00);
   1453                          u8ByteNb++;
   1454                          LAPKwpWriteDiagnosticResponse(u8ByteNb, mDATRead(U8Bit, VEHICLE_SPEED, Default));
   1455                          u8ByteNb++;
   1456                          LAPKwpWriteDiagnosticResponse(u8ByteNb, 0x00);
   1457                          u8ByteNb++;
   1458                          LAPKwpWriteDiagnosticResponse(u8ByteNb, (U8)mDATRead(U1Bit,ENGINE_RPM,    Default));
   1459          
   1460                          u8ResponseLength = cRDBLIDAns_AnalogValue_Lgth;
   1461                      }
   1462                      else
   1463                      {
   1464                          u8RequestStatus = cLAPKwpInvalidFormat;
   \                     ??LAPTfcTreatReadDataByLocalIdentifierService_0:
   \   0015   A212           MOV       C,#18
   \   0017   9B....         BR        N:??TreatEepromTest_Static_58
   1465                      }
   \                     ??TreatEepromTest_Static_56:
   \   001A   4D03           CMP       A,#3
   \   001C   BDF7           BNZ       ??LAPTfcTreatReadDataByLocalIdentifierService_0
   \   001E   8E....         MOV       A,DATKwpRxBuffer+4
   \   0021   4D92           CMP       A,#146
   \   0023   BDF0           BNZ       ??LAPTfcTreatReadDataByLocalIdentifierService_0
   \                     ??LAPTfcTreatReadDataByLocalIdentifierService_1:
   \   0025   8E....         MOV       A,DATKwpRxBuffer+5
   \   0028   4D00           CMP       A,#0
   \   002A   AD04           BZ        ??TreatEepromTest_Static_59
   \   002C   4DFF           CMP       A,#255
   \   002E   BDE5           BNZ       ??LAPTfcTreatReadDataByLocalIdentifierService_0
   \                     ??TreatEepromTest_Static_59:
   \   0030   9E....         MOV       DATKwpTxBuffer+5,A
   \   0033   16....         MOVW      HL,#LWRD(DATPanCalculateBatteryVoltage)
   \   0036   A4..           MOV       E,#BYTE3(DATPanCalculateBatteryVoltage)
   \   0038   ..             CALLT     [__T_?FAR_CALL_L07]
   \   0039   9E....         MOV       DATKwpTxBuffer+6,A
   \   003C   16....         MOVW      HL,#LWRD(DATPanCalculateBatteryVoltage)
   \   003F   A4..           MOV       E,#BYTE3(DATPanCalculateBatteryVoltage)
   \   0041   ..             CALLT     [__T_?FAR_CALL_L07]
   \   0042   60             MOV       A,X
   \   0043   9E....         MOV       DATKwpTxBuffer+7,A
   \   0046   8E....         MOV       A,DATAnaDivisorValueNow+5
   \   0049   72             MOV       C,A
   \   004A   02....         MOVW      AX,DATAnaFilteredBuffer+10
   \   004D   9A....         CALL      ?UI_RSH_L02
   \   0050   9E....         MOV       DATKwpTxBuffer+8,A
   \   0053   8E....         MOV       A,DATAnaDivisorValueNow+5
   \   0056   72             MOV       C,A
   \   0057   02....         MOVW      AX,DATAnaFilteredBuffer+10
   \   005A   9A....         CALL      ?UI_RSH_L02
   \   005D   60             MOV       A,X
   \   005E   9E....         MOV       DATKwpTxBuffer+9,A
   \   0061   8E....         MOV       A,DATAnaDivisorValueNow+3
   \   0064   72             MOV       C,A
   \   0065   02....         MOVW      AX,DATAnaFilteredBuffer+6
   \   0068   9A....         CALL      ?UI_RSH_L02
   \   006B   9E....         MOV       DATKwpTxBuffer+10,A
   \   006E   8E....         MOV       A,DATAnaDivisorValueNow+3
   \   0071   72             MOV       C,A
   \   0072   02....         MOVW      AX,DATAnaFilteredBuffer+6
   \   0075   9A....         CALL      ?UI_RSH_L02
   \   0078   60             MOV       A,X
   \   0079   9E....         MOV       DATKwpTxBuffer+11,A
   \   007C   16....         MOVW      HL,#LWRD(DATPanCalculateFlashersCurrent)
   \   007F   A4..           MOV       E,#BYTE3(DATPanCalculateFlashersCurrent)
   \   0081   ..             CALLT     [__T_?FAR_CALL_L07]
   \   0082   9E....         MOV       DATKwpTxBuffer+12,A
   \   0085   16....         MOVW      HL,#LWRD(DATPanCalculateFlashersCurrent)
   \   0088   A4..           MOV       E,#BYTE3(DATPanCalculateFlashersCurrent)
   \   008A   ..             CALLT     [__T_?FAR_CALL_L07]
   \   008B   60             MOV       A,X
   \   008C   9E....         MOV       DATKwpTxBuffer+13,A
   \   008F   8E....         MOV       A,DATAnaDivisorValueNow
   \   0092   72             MOV       C,A
   \   0093   02....         MOVW      AX,DATAnaFilteredBuffer
   \   0096   9A....         CALL      ?UI_RSH_L02
   \   0099   9E....         MOV       DATKwpTxBuffer+14,A
   \   009C   8E....         MOV       A,DATAnaDivisorValueNow
   \   009F   72             MOV       C,A
   \   00A0   02....         MOVW      AX,DATAnaFilteredBuffer
   \   00A3   9A....         CALL      ?UI_RSH_L02
   \   00A6   60             MOV       A,X
   \   00A7   9E....         MOV       DATKwpTxBuffer+15,A
   \   00AA   A100           MOV       A,#0
   \   00AC   16....         MOVW      HL,#DATKwpTxBuffer+16
   \   00AF   97             MOV       [HL],A
   \   00B0   8E....         MOV       A,u8DATSpdVEHICLE_SPEED
   \   00B3   9E....         MOV       DATKwpTxBuffer+17,A
   \   00B6   A100           MOV       A,#0
   \   00B8   16....         MOVW      HL,#DATKwpTxBuffer+18
   \   00BB   97             MOV       [HL],A
   \   00BC   8E....         MOV       A,bDATSpdENGINE_RPM
   \   00BF   9E....         MOV       DATKwpTxBuffer+19,A
   \   00C2   A011           MOV       X,#17
   1466                      break;
   1467          
   1468                  default :   
   1469                      u8RequestStatus = cLAPKwpInvalidFormat;
   1470                      break;
   1471                  }
   1472                        
   1473              }
   1474              else
   1475              {
   1476                  u8RequestStatus = cLAPKwpInvalidFormat;
   1477              }
   1478          
   1479              if(u8RequestStatus == cLAPKwpServiceIsCorrect)
   1480              {
   1481                  LAPKwpWriteDiagnosticResponse(1,LAPKwpReadDiagnosticRequest(1));
   \                     ??LAPTfcTreatReadDataByLocalIdentifierService_2:
   \   00C4   8E....         MOV       A,DATKwpRxBuffer+4
   \   00C7   9E....         MOV       DATKwpTxBuffer+4,A
   1482                  LAPKwpPreparePositiveResponse(u8ResponseLength);
   \   00CA   60             MOV       A,X
   \   00CB   9A....         CALL      LAPKwpPreparePositiveResponse
   \   00CE   9B....         BR        N:??TreatEepromTest_Static_60
   1483              }
   \                     ??TreatEepromTest_Static_57:
   \   00D1   4D90           CMP       A,#144
   \   00D3   AD15           BZ        ??TreatEepromTest_Static_61
   \   00D5   4D91           CMP       A,#145
   \   00D7   AD41           BZ        ??TreatEepromTest_Static_62
   \   00D9   4D92           CMP       A,#146
   \   00DB   BD03           BNZ       $+5
   \   00DD   9B....         BR        N:??LAPTfcTreatReadDataByLocalIdentifierService_1
   \   00E0   4D93           CMP       A,#147
   \   00E2   BD03           BNZ       $+5
   \   00E4   9B....         BR        N:??TreatEepromTest_Static_63
   \   00E7   9B....         BR        N:??LAPTfcTreatReadDataByLocalIdentifierService_0
   \                     ??TreatEepromTest_Static_61:
   \   00EA   8E....         MOV       A,DATCmnTfcVersionNum
   \   00ED   9E....         MOV       DATKwpTxBuffer+5,A
   \   00F0   8E....         MOV       A,DATCmnTfcRevisionNum
   \   00F3   9E....         MOV       DATKwpTxBuffer+6,A
   \   00F6   8E....         MOV       A,DATSbkMirrors+36
   \   00F9   9E....         MOV       DATKwpTxBuffer+7,A
   \   00FC   8E....         MOV       A,DATSbkMirrors+37
   \   00FF   9E....         MOV       DATKwpTxBuffer+8,A
   \   0102   02....         MOVW      AX,SFB(CHECKSUM)
   \   0105   D4             MOVW      DE,AX
   \   0106   A100           MOV       A,#0
   \   0108   16....         MOVW      HL,#DATKwpTxBuffer+9
   \   010B   97             MOV       [HL],A
   \   010C   86             INCW      HL
   \   010D   97             MOV       [HL],A
   \   010E   65             MOV       A,D
   \   010F   9E....         MOV       DATKwpTxBuffer+11,A
   \   0112   64             MOV       A,E
   \   0113   9E....         MOV       DATKwpTxBuffer+12,A
   \   0116   A00A           MOV       X,#10
   \   0118   FAAA           BR        ??LAPTfcTreatReadDataByLocalIdentifierService_2
   \                     ??TreatEepromTest_Static_62:
   \   011A   16....         MOVW      HL,#LWRD(ReadECU_LOG)
   \   011D   A4..           MOV       E,#BYTE3(ReadECU_LOG)
   \   011F   ..             CALLT     [__T_?FAR_FAST_CALL_L07]
   \   0120   4D00           CMP       A,#0
   \   0122   BD5C           BNZ       ??TreatEepromTest_Static_64
   \   0124   8E....         MOV       A,DATSbkMirrors+25
   \   0127   4D00           CMP       A,#0
   \   0129   BD07           BNZ       ??TreatEepromTest_Static_65
   \   012B   8E....         MOV       A,DATSbkMirrors+26
   \   012E   4D00           CMP       A,#0
   \   0130   AD12           BZ        ??TreatEepromTest_Static_66
   \                     ??TreatEepromTest_Static_65:
   \   0132   A100           MOV       A,#0
   \   0134   16....         MOVW      HL,#DATKwpTxBuffer+20
   \   0137   97             MOV       [HL],A
   \   0138   8E....         MOV       A,DATSbkMirrors+25
   \   013B   9E....         MOV       DATKwpTxBuffer+21,A
   \   013E   8E....         MOV       A,DATSbkMirrors+26
   \   0141   9E....         MOV       DATKwpTxBuffer+22,A
   \                     ??TreatEepromTest_Static_66:
   \   0144   8E....         MOV       A,DATSbkMirrors+20
   \   0147   4D00           CMP       A,#0
   \   0149   BD0E           BNZ       ??TreatEepromTest_Static_67
   \   014B   8E....         MOV       A,DATSbkMirrors+21
   \   014E   4D00           CMP       A,#0
   \   0150   BD07           BNZ       ??TreatEepromTest_Static_67
   \   0152   8E....         MOV       A,DATSbkMirrors+22
   \   0155   4D00           CMP       A,#0
   \   0157   AD29           BZ        ??TreatEepromTest_Static_68
   \                     ??TreatEepromTest_Static_67:
   \   0159   10....         MOVW      AX,#DATSbkMirrors
   \   015C   14....         MOVW      DE,#DATKwpTxBuffer+17
   \   015F   B6             POP       HL
   \   0160   B1             PUSH      AX
   \   0161   A303           MOV       B,#3
   \                     ??LAPTfcTreatReadDataByLocalIdentifierService_3:
   \   0163   891C           MOVW      AX,SP
   \   0165   D6             MOVW      HL,AX
   \   0166   87             MOV       A,[HL]
   \   0167   70             MOV       X,A
   \   0168   AE01           MOV       A,[HL+0x01]
   \   016A   D6             MOVW      HL,AX
   \   016B   AE14           MOV       A,[HL+0x14]
   \   016D   95             MOV       [DE],A
   \   016E   891C           MOVW      AX,SP
   \   0170   D6             MOVW      HL,AX
   \   0171   87             MOV       A,[HL]
   \   0172   70             MOV       X,A
   \   0173   AE01           MOV       A,[HL+0x01]
   \   0175   D6             MOVW      HL,AX
   \   0176   86             INCW      HL
   \   0177   C6             MOVW      AX,HL
   \   0178   B6             POP       HL
   \   0179   B1             PUSH      AX
   \   017A   84             INCW      DE
   \   017B   53             DEC       B
   \   017C   AD04           BZ        ??TreatEepromTest_Static_68
   \   017E   FAE3           BR        ??LAPTfcTreatReadDataByLocalIdentifierService_3
   \                     ??TreatEepromTest_Static_64:
   \   0180   A222           MOV       C,#34
   \                     ??TreatEepromTest_Static_68:
   \   0182   8E....         MOV       A,DATSbkMirrors+27
   \   0185   9E....         MOV       DATKwpTxBuffer+24,A
   \   0188   8E....         MOV       A,DATSbkMirrors+28
   \   018B   9E....         MOV       DATKwpTxBuffer+25,A
   \   018E   8E....         MOV       A,DATSbkMirrors+31
   \   0191   9E....         MOV       DATKwpTxBuffer+26,A
   \   0194   8E....         MOV       A,DATSbkMirrors+30
   \   0197   9E....         MOV       DATKwpTxBuffer+27,A
   \   019A   8E....         MOV       A,DATSbkMirrors+29
   \   019D   9E....         MOV       DATKwpTxBuffer+28,A
   \   01A0   8E....         MOV       A,DATSbkMirrors+33
   \   01A3   9E....         MOV       DATKwpTxBuffer+29,A
   \   01A6   8E....         MOV       A,DATSbkMirrors+34
   \   01A9   9E....         MOV       DATKwpTxBuffer+30,A
   \   01AC   62             MOV       A,C
   \   01AD   A01C           MOV       X,#28
   \   01AF   4D00           CMP       A,#0
   \   01B1   BD03           BNZ       $+5
   \   01B3   9B....         BR        N:??LAPTfcTreatReadDataByLocalIdentifierService_2
   1484              else
   1485              {
   1486                  LAPKwpPrepareNegativeResponse(u8RequestStatus);
   \                     ??TreatEepromTest_Static_58:
   \   01B6   62             MOV       A,C
   \   01B7   9A....         CALL      LAPKwpPrepareNegativeResponse
   1487              }
   1488              LAPKwpSetServiceIsFinished();
   \                     ??TreatEepromTest_Static_60:
   \   01BA   A103           MOV       A,#3
   \   01BC   9E....         MOV       u8LAPKwpRequestStatus,A
   1489          }
   \   01BF   B0             POP       AX
   \   01C0   B2             POP       BC
   \   01C1   AF             RET       
   \                     ??TreatEepromTest_Static_63:
   \   01C2   3123..04       BF        S:DATDinInputBuffers+5.2, ??TreatEepromTest_Static_69
   \   01C6   A201           MOV       C,#1
   \   01C8   FA02           BR        ??TreatEepromTest_Static_70
   \                     ??TreatEepromTest_Static_69:
   \   01CA   A200           MOV       C,#0
   \                     ??TreatEepromTest_Static_70:
   \   01CC   3153..04       BF        S:DATDinInputBuffers.5, ??TreatEepromTest_Static_71
   \   01D0   A301           MOV       B,#1
   \   01D2   FA02           BR        ??TreatEepromTest_Static_72
   \                     ??TreatEepromTest_Static_71:
   \   01D4   A300           MOV       B,#0
   \                     ??TreatEepromTest_Static_72:
   \   01D6   F0..           MOV       A,S:DATDinInputBuffers+2
   \   01D8   5D01           AND       A,#1
   \   01DA   A080           MOV       X,#128
   \   01DC   3188           MULU      X
   \   01DE   60             MOV       A,X
   \   01DF   74             MOV       E,A
   \   01E0   63             MOV       A,B
   \   01E1   A020           MOV       X,#32
   \   01E3   3188           MULU      X
   \   01E5   60             MOV       A,X
   \   01E6   73             MOV       B,A
   \   01E7   F0..           MOV       A,S:DATDinInputBuffers+5
   \   01E9   5D01           AND       A,#1
   \   01EB   A010           MOV       X,#16
   \   01ED   3188           MULU      X
   \   01EF   60             MOV       A,X
   \   01F0   75             MOV       D,A
   \   01F1   62             MOV       A,C
   \   01F2   A008           MOV       X,#8
   \   01F4   3188           MULU      X
   \   01F6   60             MOV       A,X
   \   01F7   72             MOV       C,A
   \   01F8   F0..           MOV       A,S:DATDinInputBuffers+6
   \   01FA   5D01           AND       A,#1
   \   01FC   21             CLR1      CY
   \   01FD   27             ROLC      A,0x1
   \   01FE   70             MOV       X,A
   \   01FF   F0..           MOV       A,S:DATDinInputBuffers+7
   \   0201   5D01           AND       A,#1
   \   0203   30             XCH       A,X
   \   0204   6160           OR        X,A
   \   0206   62             MOV       A,C
   \   0207   6160           OR        X,A
   \   0209   65             MOV       A,D
   \   020A   6160           OR        X,A
   \   020C   63             MOV       A,B
   \   020D   6160           OR        X,A
   \   020F   64             MOV       A,E
   \   0210   6160           OR        X,A
   \   0212   60             MOV       A,X
   \   0213   9E....         MOV       DATKwpTxBuffer+5,A
   \   0216   3133..04       BF        S:DATDinInputBuffers+3.3, ??TreatEepromTest_Static_73
   \   021A   A201           MOV       C,#1
   \   021C   FA02           BR        ??TreatEepromTest_Static_74
   \                     ??TreatEepromTest_Static_73:
   \   021E   A200           MOV       C,#0
   \                     ??TreatEepromTest_Static_74:
   \   0220   3133..04       BF        S:DATDinInputBuffers+6.3, ??TreatEepromTest_Static_75
   \   0224   A301           MOV       B,#1
   \   0226   FA02           BR        ??TreatEepromTest_Static_76
   \                     ??TreatEepromTest_Static_75:
   \   0228   A300           MOV       B,#0
   \                     ??TreatEepromTest_Static_76:
   \   022A   3143..04       BF        S:DATDinInputBuffers+6.4, ??TreatEepromTest_Static_77
   \   022E   A401           MOV       E,#1
   \   0230   FA02           BR        ??TreatEepromTest_Static_78
   \                     ??TreatEepromTest_Static_77:
   \   0232   A400           MOV       E,#0
   \                     ??TreatEepromTest_Static_78:
   \   0234   3123..04       BF        S:DATDinInputBuffers+8.2, ??TreatEepromTest_Static_79
   \   0238   A501           MOV       D,#1
   \   023A   FA02           BR        ??TreatEepromTest_Static_80
   \                     ??TreatEepromTest_Static_79:
   \   023C   A500           MOV       D,#0
   \                     ??TreatEepromTest_Static_80:
   \   023E   3113..04       BF        S:DATDinInputBuffers+5.1, ??TreatEepromTest_Static_81
   \   0242   A601           MOV       L,#1
   \   0244   FA02           BR        ??TreatEepromTest_Static_82
   \                     ??TreatEepromTest_Static_81:
   \   0246   A600           MOV       L,#0
   \                     ??TreatEepromTest_Static_82:
   \   0248   F0..           MOV       A,S:DATDinInputBuffers+4
   \   024A   5D01           AND       A,#1
   \   024C   A080           MOV       X,#128
   \   024E   3188           MULU      X
   \   0250   60             MOV       A,X
   \   0251   77             MOV       H,A
   \   0252   66             MOV       A,L
   \   0253   A040           MOV       X,#64
   \   0255   3188           MULU      X
   \   0257   60             MOV       A,X
   \   0258   76             MOV       L,A
   \   0259   65             MOV       A,D
   \   025A   A020           MOV       X,#32
   \   025C   3188           MULU      X
   \   025E   60             MOV       A,X
   \   025F   75             MOV       D,A
   \   0260   64             MOV       A,E
   \   0261   A010           MOV       X,#16
   \   0263   3188           MULU      X
   \   0265   60             MOV       A,X
   \   0266   74             MOV       E,A
   \   0267   63             MOV       A,B
   \   0268   A008           MOV       X,#8
   \   026A   3188           MULU      X
   \   026C   60             MOV       A,X
   \   026D   6162           OR        C,A
   \   026F   64             MOV       A,E
   \   0270   6162           OR        C,A
   \   0272   65             MOV       A,D
   \   0273   6162           OR        C,A
   \   0275   66             MOV       A,L
   \   0276   6162           OR        C,A
   \   0278   67             MOV       A,H
   \   0279   6162           OR        C,A
   \   027B   62             MOV       A,C
   \   027C   9E....         MOV       DATKwpTxBuffer+6,A
   \   027F   3113..04       BF        S:DATDinInputBuffers.1, ??TreatEepromTest_Static_83
   \   0283   A201           MOV       C,#1
   \   0285   FA02           BR        ??TreatEepromTest_Static_84
   \                     ??TreatEepromTest_Static_83:
   \   0287   A200           MOV       C,#0
   \                     ??TreatEepromTest_Static_84:
   \   0289   3133..04       BF        S:DATDinInputBuffers+2.3, ??TreatEepromTest_Static_85
   \   028D   A301           MOV       B,#1
   \   028F   FA02           BR        ??TreatEepromTest_Static_86
   \                     ??TreatEepromTest_Static_85:
   \   0291   A300           MOV       B,#0
   \                     ??TreatEepromTest_Static_86:
   \   0293   3123..04       BF        S:DATDinInputBuffers+2.2, ??TreatEepromTest_Static_87
   \   0297   A401           MOV       E,#1
   \   0299   FA02           BR        ??TreatEepromTest_Static_88
   \                     ??TreatEepromTest_Static_87:
   \   029B   A400           MOV       E,#0
   \                     ??TreatEepromTest_Static_88:
   \   029D   3113..04       BF        S:DATDinInputBuffers+2.1, ??TreatEepromTest_Static_89
   \   02A1   A501           MOV       D,#1
   \   02A3   FA02           BR        ??TreatEepromTest_Static_90
   \                     ??TreatEepromTest_Static_89:
   \   02A5   A500           MOV       D,#0
   \                     ??TreatEepromTest_Static_90:
   \   02A7   3143..04       BF        S:DATDinInputBuffers+1.4, ??TreatEepromTest_Static_91
   \   02AB   A601           MOV       L,#1
   \   02AD   FA02           BR        ??TreatEepromTest_Static_92
   \                     ??TreatEepromTest_Static_91:
   \   02AF   A600           MOV       L,#0
   \                     ??TreatEepromTest_Static_92:
   \   02B1   A100           MOV       A,#0
   \   02B3   7124..         MOV1      CY,S:DATDinInputBuffers+3.2
   \   02B6   27             ROLC      A,0x1
   \   02B7   A080           MOV       X,#128
   \   02B9   3188           MULU      X
   \   02BB   60             MOV       A,X
   \   02BC   77             MOV       H,A
   \   02BD   66             MOV       A,L
   \   02BE   A040           MOV       X,#64
   \   02C0   3188           MULU      X
   \   02C2   60             MOV       A,X
   \   02C3   76             MOV       L,A
   \   02C4   65             MOV       A,D
   \   02C5   A008           MOV       X,#8
   \   02C7   3188           MULU      X
   \   02C9   64             MOV       A,E
   \   02CA   26             ROL       A,0x1
   \   02CB   27             ROLC      A,0x1
   \   02CC   5DFC           AND       A,#252
   \   02CE   74             MOV       E,A
   \   02CF   63             MOV       A,B
   \   02D0   21             CLR1      CY
   \   02D1   27             ROLC      A,0x1
   \   02D2   6162           OR        C,A
   \   02D4   64             MOV       A,E
   \   02D5   6162           OR        C,A
   \   02D7   60             MOV       A,X
   \   02D8   6162           OR        C,A
   \   02DA   66             MOV       A,L
   \   02DB   6162           OR        C,A
   \   02DD   67             MOV       A,H
   \   02DE   6162           OR        C,A
   \   02E0   62             MOV       A,C
   \   02E1   9E....         MOV       DATKwpTxBuffer+7,A
   \   02E4   3133..04       BF        S:DATDinInputBuffers+5.3, ??TreatEepromTest_Static_93
   \   02E8   A201           MOV       C,#1
   \   02EA   FA02           BR        ??TreatEepromTest_Static_94
   \                     ??TreatEepromTest_Static_93:
   \   02EC   A200           MOV       C,#0
   \                     ??TreatEepromTest_Static_94:
   \   02EE   3133..04       BF        S:DATDinInputBuffers+4.3, ??TreatEepromTest_Static_95
   \   02F2   A701           MOV       H,#1
   \   02F4   FA02           BR        ??TreatEepromTest_Static_96
   \                     ??TreatEepromTest_Static_95:
   \   02F6   A700           MOV       H,#0
   \                     ??TreatEepromTest_Static_96:
   \   02F8   3113..04       BF        S:DATDinInputBuffers+8.1, ??TreatEepromTest_Static_97
   \   02FC   A501           MOV       D,#1
   \   02FE   FA02           BR        ??TreatEepromTest_Static_98
   \                     ??TreatEepromTest_Static_97:
   \   0300   A500           MOV       D,#0
   \                     ??TreatEepromTest_Static_98:
   \   0302   A100           MOV       A,#0
   \   0304   7114..         MOV1      CY,S:DATDinInputBuffers+4.1
   \   0307   27             ROLC      A,0x1
   \   0308   A080           MOV       X,#128
   \   030A   3188           MULU      X
   \   030C   60             MOV       A,X
   \   030D   73             MOV       B,A
   \   030E   F0..           MOV       A,S:DATDinInputBuffers+3
   \   0310   5D01           AND       A,#1
   \   0312   A040           MOV       X,#64
   \   0314   3188           MULU      X
   \   0316   60             MOV       A,X
   \   0317   74             MOV       E,A
   \   0318   65             MOV       A,D
   \   0319   A020           MOV       X,#32
   \   031B   3188           MULU      X
   \   031D   60             MOV       A,X
   \   031E   75             MOV       D,A
   \   031F   F0..           MOV       A,S:DATDinInputBuffers+8
   \   0321   5D01           AND       A,#1
   \   0323   A010           MOV       X,#16
   \   0325   3188           MULU      X
   \   0327   60             MOV       A,X
   \   0328   76             MOV       L,A
   \   0329   67             MOV       A,H
   \   032A   A008           MOV       X,#8
   \   032C   3188           MULU      X
   \   032E   62             MOV       A,C
   \   032F   27             ROLC      A,0x1
   \   0330   6168           OR        A,X
   \   0332   616E           OR        A,L
   \   0334   616D           OR        A,D
   \   0336   616C           OR        A,E
   \   0338   616B           OR        A,B
   \   033A   9E....         MOV       DATKwpTxBuffer+8,A
   \   033D   A006           MOV       X,#6
   \   033F   9B....         BR        N:??LAPTfcTreatReadDataByLocalIdentifierService_2
   \   0342                  REQUIRE ?CL78K_V4_6_L00
   1490          
   1491          //==============================================================================
   1492          // DESCRIPTION:         LAPTfcTreatWriteDataByLocalIdentifierService
   1493          //
   1494          // PARAMETERS:          none
   1495          //
   1496          // RETURN VALUE:        none
   1497          //
   1498          // DESIGN INFORMATION:  refer to Detailed Design Document
   1499          //==============================================================================
   1500          // akodzhh: Size of this function exceeds 100 lines. It is AW1092 reuse, keep for readability.

   \                                 In  segment BCODE, align 1, keep-with-next
   1501          MEM_TYPE void LAPTfcTreatWriteDataByLocalIdentifierService(void)
   \                     LAPTfcTreatWriteDataByLocalIdentifierService:
   1502          { 
   \   0000                  ; * Stack frame (at entry) *
   \   0000                  ; Param size: 0
   \   0000   B3             PUSH      BC
   \   0001                  ; Total Auto size: 2
   \   0001   B7             PUSH      HL
   1503              U8  u8RequestStatus;
   1504              U8  u8Index;
   1505              U8  u8ByteNb;
   1506          
   1507              u8RequestStatus = cLAPKwpServiceIsCorrect;
   \   0002   A200           MOV       C,#0
   1508          
   1509              if(LAPKwpIsServiceTreated() == cFalse )
   \   0004   8E....         MOV       A,u8LAPKwpRequestStatus
   \   0007   4D02           CMP       A,#2
   \   0009   BD03           BNZ       $+5
   \   000B   9B....         BR        N:??TreatEepromTest_Static_99
   1510              {
   1511                  switch (LAPKwpReadDiagnosticRequest(1))
   \   000E   8E....         MOV       A,DATKwpRxBuffer+4
   \   0011   4D90           CMP       A,#144
   \   0013   AD2D           BZ        ??TreatEepromTest_Static_100
   \   0015   4D91           CMP       A,#145
   \   0017   BD03           BNZ       $+5
   \   0019   9B....         BR        N:??TreatEepromTest_Static_101
   \   001C   4D92           CMP       A,#146
   \   001E   BD03           BNZ       $+5
   \   0020   9B....         BR        N:??TreatEepromTest_Static_102
   \   0023   4D93           CMP       A,#147
   \   0025   BD03           BNZ       $+5
   \   0027   9B....         BR        N:??TreatEepromTest_Static_103
   \   002A   4D94           CMP       A,#148
   \   002C   BD03           BNZ       $+5
   \   002E   9B....         BR        N:??TreatEepromTest_Static_104
   \   0031   4D95           CMP       A,#149
   \   0033   BD03           BNZ       $+5
   \   0035   9B....         BR        N:??TreatEepromTest_Static_105
   \   0038   4D96           CMP       A,#150
   \   003A   BD03           BNZ       $+5
   \   003C   9B....         BR        N:??TreatEepromTest_Static_106
   \   003F   9B....         BR        N:??TreatEepromTest_Static_107
   1512                  {
   1513          
   1514                  case cWDBLID_JCAEDataID :
   1515                      if(   (mDATRead(U8Bit,DATKwpRxFrameLgth,Default) == cWDBLIDReq_JCAEData_Lgth)
   1516                          &&(LAPKwpReadDiagnosticRequest(cECUTypeByte) <= cECUTypeMax)) // ECUType 0..7
   \                     ??TreatEepromTest_Static_100:
   \   0042   8E....         MOV       A,DATKwpRxFrameLgth
   \   0045   4D14           CMP       A,#20
   \   0047   AD03           BZ        $+5
   \   0049   9B....         BR        N:??TreatEepromTest_Static_107
   \   004C   8E....         MOV       A,DATKwpRxBuffer+22
   \   004F   4D08           CMP       A,#8
   \   0051   8D03           BC        $+5
   \   0053   9B....         BR        N:??TreatEepromTest_Static_107
   1517                      {
   1518                          u8ByteNb = cByte2;
   1519          
   1520                          // ECU Reference is written by bootloader in log zone 
   1521                          u8ByteNb += cEEP_ECUReferenceLength;
   1522                          // PIE
   1523                          for (u8Index=0; u8Index<cEEP_PieNumberLength; u8Index++)
   \   0056   12....         MOVW      BC,#DATSbkMirrors
   \   0059   14....         MOVW      DE,#DATKwpRxBuffer+10
   \   005C   891C           MOVW      AX,SP
   \   005E   D6             MOVW      HL,AX
   \   005F   A105           MOV       A,#5
   \   0061   97             MOV       [HL],A
   1524                          {
   1525                              mDATWriteTable(U8Bit, EEP_PieNumber, u8Index, LAPKwpReadDiagnosticRequest(u8ByteNb+u8Index), Default);
   \                     ??LAPTfcTreatWriteDataByLocalIdentifierService_0:
   \   0062   85             MOV       A,[DE]
   \   0063   70             MOV       X,A
   \   0064   B3             PUSH      BC
   \   0065   B6             POP       HL
   \   0066   E6             XCHW      AX,HL
   \   0067   CA0A00         ADDW      AX,#10
   \   006A   E6             XCHW      AX,HL
   \   006B   87             MOV       A,[HL]
   \   006C   6148           CMP       A,X
   \   006E   AD0E           BZ        ??TreatEepromTest_Static_108
   \   0070   85             MOV       A,[DE]
   \   0071   B3             PUSH      BC
   \   0072   B6             POP       HL
   \   0073   E6             XCHW      AX,HL
   \   0074   CA0A00         ADDW      AX,#10
   \   0077   E6             XCHW      AX,HL
   \   0078   97             MOV       [HL],A
   \   0079   A101           MOV       A,#1
   \   007B   9A....         CALL      DATSbkStartUpdate
   1526                          }
   \                     ??TreatEepromTest_Static_108:
   \   007E   84             INCW      DE
   \   007F   B3             PUSH      BC
   \   0080   B6             POP       HL
   \   0081   86             INCW      HL
   \   0082   B7             PUSH      HL
   \   0083   B2             POP       BC
   \   0084   891C           MOVW      AX,SP
   \   0086   D6             MOVW      HL,AX
   \   0087   87             MOV       A,[HL]
   \   0088   51             DEC       A
   \   0089   97             MOV       [HL],A
   \   008A   BDD6           BNZ       ??LAPTfcTreatWriteDataByLocalIdentifierService_0
   1527                          u8ByteNb += cEEP_PieNumberLength;
   1528                          // Indice PIE
   1529                          for (u8Index=0; u8Index<cEEP_PieIndexLength; u8Index++)
   \   008C   A102           MOV       A,#2
   \   008E   12....         MOVW      BC,#DATSbkMirrors
   \   0091   14....         MOVW      DE,#DATKwpRxBuffer+15
   \   0094   97             MOV       [HL],A
   1530                          {
   1531                              mDATWriteTable(U8Bit, EEP_PieIndex, u8Index, LAPKwpReadDiagnosticRequest(u8ByteNb+u8Index), Default);
   \                     ??LAPTfcTreatWriteDataByLocalIdentifierService_1:
   \   0095   85             MOV       A,[DE]
   \   0096   70             MOV       X,A
   \   0097   B3             PUSH      BC
   \   0098   B6             POP       HL
   \   0099   E6             XCHW      AX,HL
   \   009A   CA1700         ADDW      AX,#23
   \   009D   E6             XCHW      AX,HL
   \   009E   87             MOV       A,[HL]
   \   009F   6148           CMP       A,X
   \   00A1   AD0E           BZ        ??TreatEepromTest_Static_109
   \   00A3   85             MOV       A,[DE]
   \   00A4   B3             PUSH      BC
   \   00A5   B6             POP       HL
   \   00A6   E6             XCHW      AX,HL
   \   00A7   CA1700         ADDW      AX,#23
   \   00AA   E6             XCHW      AX,HL
   \   00AB   97             MOV       [HL],A
   \   00AC   A101           MOV       A,#1
   \   00AE   9A....         CALL      DATSbkStartUpdate
   1532                          }
   \                     ??TreatEepromTest_Static_109:
   \   00B1   84             INCW      DE
   \   00B2   B3             PUSH      BC
   \   00B3   B6             POP       HL
   \   00B4   86             INCW      HL
   \   00B5   B7             PUSH      HL
   \   00B6   B2             POP       BC
   \   00B7   891C           MOVW      AX,SP
   \   00B9   D6             MOVW      HL,AX
   \   00BA   87             MOV       A,[HL]
   \   00BB   51             DEC       A
   \   00BC   97             MOV       [HL],A
   \   00BD   BDD6           BNZ       ??LAPTfcTreatWriteDataByLocalIdentifierService_1
   1533                          u8ByteNb += cEEP_PieIndexLength;
   1534                          for (u8Index=0; u8Index<cEEP_SerialNumberLength; u8Index++)
   \   00BF   A103           MOV       A,#3
   \   00C1   12....         MOVW      BC,#DATSbkMirrors
   \   00C4   14....         MOVW      DE,#DATKwpRxBuffer+17
   \   00C7   97             MOV       [HL],A
   1535                          {
   1536                              mDATWriteTable(U8Bit, EEP_SerialNumber, u8Index, LAPKwpReadDiagnosticRequest(u8ByteNb+u8Index), Default);
   \                     ??LAPTfcTreatWriteDataByLocalIdentifierService_2:
   \   00C8   85             MOV       A,[DE]
   \   00C9   70             MOV       X,A
   \   00CA   B3             PUSH      BC
   \   00CB   B6             POP       HL
   \   00CC   E6             XCHW      AX,HL
   \   00CD   CA1400         ADDW      AX,#20
   \   00D0   E6             XCHW      AX,HL
   \   00D1   87             MOV       A,[HL]
   \   00D2   6148           CMP       A,X
   \   00D4   AD0E           BZ        ??TreatEepromTest_Static_110
   \   00D6   85             MOV       A,[DE]
   \   00D7   B3             PUSH      BC
   \   00D8   B6             POP       HL
   \   00D9   E6             XCHW      AX,HL
   \   00DA   CA1400         ADDW      AX,#20
   \   00DD   E6             XCHW      AX,HL
   \   00DE   97             MOV       [HL],A
   \   00DF   A101           MOV       A,#1
   \   00E1   9A....         CALL      DATSbkStartUpdate
   1537                          }
   \                     ??TreatEepromTest_Static_110:
   \   00E4   84             INCW      DE
   \   00E5   B3             PUSH      BC
   \   00E6   B6             POP       HL
   \   00E7   86             INCW      HL
   \   00E8   B7             PUSH      HL
   \   00E9   B2             POP       BC
   \   00EA   891C           MOVW      AX,SP
   \   00EC   D6             MOVW      HL,AX
   \   00ED   87             MOV       A,[HL]
   \   00EE   51             DEC       A
   \   00EF   97             MOV       [HL],A
   \   00F0   BDD6           BNZ       ??LAPTfcTreatWriteDataByLocalIdentifierService_2
   1538                          u8ByteNb += cEEP_SerialNumberLength;
   1539                          // Code date
   1540                          for (u8Index=0; u8Index<cEEP_DateCodeLength; u8Index++)
   \   00F2   A102           MOV       A,#2
   \   00F4   12....         MOVW      BC,#DATSbkMirrors
   \   00F7   14....         MOVW      DE,#DATKwpRxBuffer+20
   \   00FA   97             MOV       [HL],A
   1541                          {
   1542                              mDATWriteTable(U8Bit, EEP_DateCode, u8Index, LAPKwpReadDiagnosticRequest(u8ByteNb+u8Index), Default);
   \                     ??LAPTfcTreatWriteDataByLocalIdentifierService_3:
   \   00FB   85             MOV       A,[DE]
   \   00FC   70             MOV       X,A
   \   00FD   B3             PUSH      BC
   \   00FE   B6             POP       HL
   \   00FF   E6             XCHW      AX,HL
   \   0100   CA1900         ADDW      AX,#25
   \   0103   E6             XCHW      AX,HL
   \   0104   87             MOV       A,[HL]
   \   0105   6148           CMP       A,X
   \   0107   AD0E           BZ        ??TreatEepromTest_Static_111
   \   0109   85             MOV       A,[DE]
   \   010A   B3             PUSH      BC
   \   010B   B6             POP       HL
   \   010C   E6             XCHW      AX,HL
   \   010D   CA1900         ADDW      AX,#25
   \   0110   E6             XCHW      AX,HL
   \   0111   97             MOV       [HL],A
   \   0112   A101           MOV       A,#1
   \   0114   9A....         CALL      DATSbkStartUpdate
   1543                          }
   \                     ??TreatEepromTest_Static_111:
   \   0117   84             INCW      DE
   \   0118   B3             PUSH      BC
   \   0119   B6             POP       HL
   \   011A   86             INCW      HL
   \   011B   B7             PUSH      HL
   \   011C   B2             POP       BC
   \   011D   891C           MOVW      AX,SP
   \   011F   D6             MOVW      HL,AX
   \   0120   87             MOV       A,[HL]
   \   0121   51             DEC       A
   \   0122   97             MOV       [HL],A
   \   0123   BDD6           BNZ       ??LAPTfcTreatWriteDataByLocalIdentifierService_3
   1544                          
   1545                          mDATWrite(U8Bit, EEP_ECUType, LAPKwpReadDiagnosticRequest(cECUTypeByte), Default);
   \   0125   8E....         MOV       A,DATSbkMirrors+32
   \   0128   48....         CMP       A,DATKwpRxBuffer+22
   \   012B   BD03           BNZ       $+5
   \   012D   9B....         BR        N:??TreatEepromTest_Static_112
   \   0130   8E....         MOV       A,DATKwpRxBuffer+22
   \   0133   9E....         MOV       DATSbkMirrors+32,A
   \   0136   A101           MOV       A,#1
   \   0138   9A....         CALL      DATSbkStartUpdate
   \   013B   9B....         BR        N:??TreatEepromTest_Static_112
   1546          
   1547                      }
   1548                      else
   1549                      {
   1550                          u8RequestStatus = cLAPKwpInvalidFormat;
   \                     ??TreatEepromTest_Static_107:
   \   013E   A212           MOV       C,#18
   1551                      }
   1552                      break;
   1553          
   1554                  case cWDBLID_InSituTestCounterID :
   1555                      if(mDATRead(U8Bit,DATKwpRxFrameLgth,Default) == cWDBLIDReq_TestCounter_Lgth)
   1556                      {
   1557                          mDATWrite(U8Bit, EEP_InSituTestCounter,LAPKwpReadDiagnosticRequest(cByte2),Default);
   1558                      }
   1559                      else
   1560                      {
   1561                          u8RequestStatus = cLAPKwpInvalidFormat;
   1562                      }
   1563                      break;
   1564          
   1565                  case cWDBLID_FunctTestCounterID :
   1566                      if(mDATRead(U8Bit,DATKwpRxFrameLgth,Default) == cWDBLIDReq_TestCounter_Lgth)
   1567                      {
   1568                          mDATWrite(U8Bit, EEP_PassingTestCounter,LAPKwpReadDiagnosticRequest(cByte2),Default);
   1569                      }
   1570                      else
   1571                      {
   1572                          u8RequestStatus = cLAPKwpInvalidFormat;
   1573                      }
   1574                      break;
   1575          
   1576                  case cWDBLID_RunningTestCounterID :
   1577                      if(mDATRead(U8Bit,DATKwpRxFrameLgth,Default) == cWDBLIDReq_TestCounter_Lgth)
   1578                      {
   1579                          mDATWrite(U8Bit, EEP_ReliabilityTestCounter,LAPKwpReadDiagnosticRequest(cByte2),Default);
   1580                      }
   1581                      else
   1582                      {
   1583                          u8RequestStatus = cLAPKwpInvalidFormat;
   1584                      }
   1585                      break;
   1586          
   1587                  case cWDBLID_RfTestCounterID :
   1588                      if(mDATRead(U8Bit,DATKwpRxFrameLgth,Default) == cWDBLIDReq_TestCounter_Lgth)
   1589                      {
   1590                          mDATWrite(U8Bit, EEP_RfTestCounter,LAPKwpReadDiagnosticRequest(cByte2),Default);
   1591                      }
   1592                      else
   1593                      {
   1594                          u8RequestStatus = cLAPKwpInvalidFormat;
   1595                      }
   1596                      break;
   1597          
   1598                  case cWDBLID_FinalTestCounterID :
   1599                      if(mDATRead(U8Bit,DATKwpRxFrameLgth,Default) == cWDBLIDReq_TestCounter_Lgth)
   1600                      {
   1601                          mDATWrite(U8Bit, EEP_FinalTestCounter,LAPKwpReadDiagnosticRequest(cByte2),Default);
   1602                      }
   1603                      else
   1604                      {
   1605                          u8RequestStatus = cLAPKwpInvalidFormat;
   1606                      }
   1607                      break;
   1608          
   1609                  case cWDBLID_FlashersCoeffID :
   1610                      if(mDATRead(U8Bit,DATKwpRxFrameLgth,Default) == cWDBLIDReq_FlashersCoeff_Lgth)
   1611                      {
   1612                          mDATWrite(U8Bit, EEP_FlaCoeffLNormal, LAPKwpReadDiagnosticRequest(cByte2),Default);
   1613                          mDATWrite(U8Bit, EEP_FlaCoeffRNormal, LAPKwpReadDiagnosticRequest(cByte3),Default);
   1614                          // Cm006406: removed FlasherCoeffLeft_trailer, FlasherCoeffRight_trailer (Cm006435:SPEC)
   1615                      }
   1616                      else
   1617                      {
   1618                          u8RequestStatus = cLAPKwpInvalidFormat;
   1619                      }
   1620                      break;
   1621          
   1622                  default :
   1623                      u8RequestStatus = cLAPKwpInvalidFormat;
   1624                      break;
   1625                  }   // Switch SubFunction
   1626          
   1627                  if( u8RequestStatus == cLAPKwpServiceIsCorrect)
   1628                  {
   1629                      mDATControl(Eep,UpDateEepGroupSupplierBank);
   1630                      LAPKwpSetServiceIsTreated();
   1631                  }
   1632                  else
   1633                  {
   1634                      LAPKwpSetServiceIsFinished();
   \                     ??LAPTfcTreatWriteDataByLocalIdentifierService_4:
   \   0140   A103           MOV       A,#3
   \   0142   9E....         MOV       u8LAPKwpRequestStatus,A
   1635                  }
   1636          
   1637              }
   1638              else     // service is already started, waiting write to be finished
   1639              {
   1640                  if(mDATRead(U1Bit,IsEepGroupSupplierBankProcessing,Default) == cFalse)
   1641                  {
   1642                      if(mDATRead(U1Bit,IsEepGroupSupplierBankWriteOk,Default) == cFalse)
   1643                      {
   1644                          u8RequestStatus = cLAPKwpFaultUponWriting;
   1645                      }
   1646          
   1647                      LAPKwpSetServiceIsFinished();
   1648                  }
   1649          
   1650              }
   1651          
   1652              if( LAPKwpIsServiceTreated() == cFalse )
   1653              {
   1654                  if(u8RequestStatus != cLAPKwpServiceIsCorrect)
   \   0145   62             MOV       A,C
   \   0146   4D00           CMP       A,#0
   \   0148   AD03           BZ        $+5
   \   014A   9B....         BR        N:??TreatEepromTest_Static_113
   1655                  {
   1656                      LAPKwpPrepareNegativeResponse(u8RequestStatus);
   1657                  }
   1658                  else
   1659                  {
   1660                      LAPKwpWriteDiagnosticResponse(1,LAPKwpReadDiagnosticRequest(1));
   \                     ??LAPTfcTreatWriteDataByLocalIdentifierService_5:
   \   014D   8E....         MOV       A,DATKwpRxBuffer+4
   \   0150   9E....         MOV       DATKwpTxBuffer+4,A
   1661                      LAPKwpPreparePositiveResponse(cByte2);
   \   0153   A102           MOV       A,#2
   \   0155   9A....         CALL      LAPKwpPreparePositiveResponse
   1662                  }
   1663              }
   1664            
   1665          
   1666          }
   \                     ??LAPTfcTreatWriteDataByLocalIdentifierService_6:
   \   0158   B0             POP       AX
   \   0159   B2             POP       BC
   \   015A   AF             RET       
   \                     ??TreatEepromTest_Static_101:
   \   015B   8E....         MOV       A,DATKwpRxFrameLgth
   \   015E   4D03           CMP       A,#3
   \   0160   BDDC           BNZ       ??TreatEepromTest_Static_107
   \   0162   8E....         MOV       A,DATSbkMirrors+27
   \   0165   48....         CMP       A,DATKwpRxBuffer+5
   \   0168   BD03           BNZ       $+5
   \   016A   9B....         BR        N:??TreatEepromTest_Static_112
   \   016D   8E....         MOV       A,DATKwpRxBuffer+5
   \   0170   9E....         MOV       DATSbkMirrors+27,A
   \   0173   A101           MOV       A,#1
   \   0175   9A....         CALL      DATSbkStartUpdate
   \   0178   9B....         BR        N:??TreatEepromTest_Static_112
   \                     ??TreatEepromTest_Static_102:
   \   017B   8E....         MOV       A,DATKwpRxFrameLgth
   \   017E   4D03           CMP       A,#3
   \   0180   BDBC           BNZ       ??TreatEepromTest_Static_107
   \   0182   8E....         MOV       A,DATSbkMirrors+28
   \   0185   48....         CMP       A,DATKwpRxBuffer+5
   \   0188   BD03           BNZ       $+5
   \   018A   9B....         BR        N:??TreatEepromTest_Static_112
   \   018D   8E....         MOV       A,DATKwpRxBuffer+5
   \   0190   9E....         MOV       DATSbkMirrors+28,A
   \   0193   A101           MOV       A,#1
   \   0195   9A....         CALL      DATSbkStartUpdate
   \   0198   9B....         BR        N:??TreatEepromTest_Static_112
   \                     ??TreatEepromTest_Static_103:
   \   019B   8E....         MOV       A,DATKwpRxFrameLgth
   \   019E   4D03           CMP       A,#3
   \   01A0   BD9C           BNZ       ??TreatEepromTest_Static_107
   \   01A2   8E....         MOV       A,DATSbkMirrors+31
   \   01A5   48....         CMP       A,DATKwpRxBuffer+5
   \   01A8   AD78           BZ        ??TreatEepromTest_Static_112
   \   01AA   8E....         MOV       A,DATKwpRxBuffer+5
   \   01AD   9E....         MOV       DATSbkMirrors+31,A
   \   01B0   A101           MOV       A,#1
   \   01B2   9A....         CALL      DATSbkStartUpdate
   \   01B5   FA6B           BR        ??TreatEepromTest_Static_112
   \                     ??TreatEepromTest_Static_104:
   \   01B7   8E....         MOV       A,DATKwpRxFrameLgth
   \   01BA   4D03           CMP       A,#3
   \   01BC   BD80           BNZ       ??TreatEepromTest_Static_107
   \   01BE   8E....         MOV       A,DATSbkMirrors+30
   \   01C1   48....         CMP       A,DATKwpRxBuffer+5
   \   01C4   AD5C           BZ        ??TreatEepromTest_Static_112
   \   01C6   8E....         MOV       A,DATKwpRxBuffer+5
   \   01C9   9E....         MOV       DATSbkMirrors+30,A
   \   01CC   A101           MOV       A,#1
   \   01CE   9A....         CALL      DATSbkStartUpdate
   \   01D1   FA4F           BR        ??TreatEepromTest_Static_112
   \                     ??TreatEepromTest_Static_105:
   \   01D3   8E....         MOV       A,DATKwpRxFrameLgth
   \   01D6   4D03           CMP       A,#3
   \   01D8   AD03           BZ        $+5
   \   01DA   9B....         BR        N:??TreatEepromTest_Static_107
   \   01DD   8E....         MOV       A,DATSbkMirrors+29
   \   01E0   48....         CMP       A,DATKwpRxBuffer+5
   \   01E3   AD3D           BZ        ??TreatEepromTest_Static_112
   \   01E5   8E....         MOV       A,DATKwpRxBuffer+5
   \   01E8   9E....         MOV       DATSbkMirrors+29,A
   \   01EB   A101           MOV       A,#1
   \   01ED   9A....         CALL      DATSbkStartUpdate
   \   01F0   FA30           BR        ??TreatEepromTest_Static_112
   \                     ??TreatEepromTest_Static_106:
   \   01F2   8E....         MOV       A,DATKwpRxFrameLgth
   \   01F5   4D04           CMP       A,#4
   \   01F7   AD03           BZ        $+5
   \   01F9   9B....         BR        N:??TreatEepromTest_Static_107
   \   01FC   8E....         MOV       A,DATSbkMirrors+33
   \   01FF   48....         CMP       A,DATKwpRxBuffer+5
   \   0202   AD0B           BZ        ??TreatEepromTest_Static_114
   \   0204   8E....         MOV       A,DATKwpRxBuffer+5
   \   0207   9E....         MOV       DATSbkMirrors+33,A
   \   020A   A101           MOV       A,#1
   \   020C   9A....         CALL      DATSbkStartUpdate
   \                     ??TreatEepromTest_Static_114:
   \   020F   8E....         MOV       A,DATSbkMirrors+34
   \   0212   48....         CMP       A,DATKwpRxBuffer+6
   \   0215   AD0B           BZ        ??TreatEepromTest_Static_112
   \   0217   8E....         MOV       A,DATKwpRxBuffer+6
   \   021A   9E....         MOV       DATSbkMirrors+34,A
   \   021D   A101           MOV       A,#1
   \   021F   9A....         CALL      DATSbkStartUpdate
   \                     ??TreatEepromTest_Static_112:
   \   0222   A101           MOV       A,#1
   \   0224   9A....         CALL      DATSbkStartUpdate
   \   0227   A102           MOV       A,#2
   \   0229   9E....         MOV       u8LAPKwpRequestStatus,A
   \   022C   9B....         BR        N:??LAPTfcTreatWriteDataByLocalIdentifierService_6
   \                     ??TreatEepromTest_Static_99:
   \   022F   A101           MOV       A,#1
   \   0231   9A....         CALL      DATSbkIsBankProcessing
   \   0234   4D00           CMP       A,#0
   \   0236   BD11           BNZ       ??TreatEepromTest_Static_115
   \   0238   A101           MOV       A,#1
   \   023A   9A....         CALL      DATSbkIsWriteOk
   \   023D   4D00           CMP       A,#0
   \   023F   AD03           BZ        $+5
   \   0241   9B....         BR        N:??LAPTfcTreatWriteDataByLocalIdentifierService_4
   \   0244   A287           MOV       C,#135
   \   0246   9B....         BR        N:??LAPTfcTreatWriteDataByLocalIdentifierService_4
   \                     ??TreatEepromTest_Static_115:
   \   0249   8E....         MOV       A,u8LAPKwpRequestStatus
   \   024C   4D02           CMP       A,#2
   \   024E   AD03           BZ        $+5
   \   0250   9B....         BR        N:??LAPTfcTreatWriteDataByLocalIdentifierService_5
   \   0253   9B....         BR        N:??LAPTfcTreatWriteDataByLocalIdentifierService_6
   \                     ??TreatEepromTest_Static_113:
   \   0256   9A....         CALL      LAPKwpPrepareNegativeResponse
   \   0259   9B....         BR        N:??LAPTfcTreatWriteDataByLocalIdentifierService_6
   \   025C                  REQUIRE ?CL78K_V4_6_L00
   1667          
   1668          //==============================================================================
   1669          // DESCRIPTION:         LAPTfcTreatInputOutputControlByLocalIdentifierService
   1670          //
   1671          // PARAMETERS:          none
   1672          //
   1673          // RETURN VALUE:        none
   1674          //
   1675          // DESIGN INFORMATION:  refer to Detailed Design Document
   1676          //==============================================================================

   \                                 In  segment BCODE, align 1, keep-with-next
   1677          MEM_TYPE void LAPTfcTreatInputOutputControlByLocalIdentifierService(void)
   \                     LAPTfcTreatInputOutputControlByLocalIdentifierService:
   1678          {
   \   0000                  ; * Stack frame (at entry) *
   \   0000                  ; Param size: 0
   \   0000                  ; Total Auto size: 0
   1679              U8  u8RequestStatus;
   1680              U8  u8OutputIndex;
   1681          
   1682              u8RequestStatus = cLAPKwpInvalidFormat;
   1683          
   1684              if (mDATRead(U8Bit,DATKwpRxFrameLgth,Default) == cIOCBLIDReq_Lgth)
   \   0000   8E....         MOV       A,DATKwpRxFrameLgth
   \   0003   4D05           CMP       A,#5
   \   0005   BD52           BNZ       ??TreatEepromTest_Static_116
   1685              {
   1686                  if(   (LAPKwpReadDiagnosticRequest(1) == cIOCBLID_ManualOutputMode)
   1687                      &&(LAPKwpReadDiagnosticRequest(cByte2) == cIOCBLID_StartPermanentCtrl)
   1688                      &&(LAPKwpReadDiagnosticRequest(cByte3) <= cOutputsNumber)
   1689                      &&(LAPKwpReadDiagnosticRequest(cByte3) >= 0x01))
   \   0007   8E....         MOV       A,DATKwpRxBuffer+4
   \   000A   4DFA           CMP       A,#250
   \   000C   BD4B           BNZ       ??TreatEepromTest_Static_116
   \   000E   8E....         MOV       A,DATKwpRxBuffer+5
   \   0011   4D20           CMP       A,#32
   \   0013   BD44           BNZ       ??TreatEepromTest_Static_116
   \   0015   8E....         MOV       A,DATKwpRxBuffer+6
   \   0018   4D11           CMP       A,#17
   \   001A   9D3D           BNC       ??TreatEepromTest_Static_116
   \   001C   4D00           CMP       A,#0
   \   001E   AD39           BZ        ??TreatEepromTest_Static_116
   1690                  {
   1691                      u8OutputIndex = LAPKwpReadDiagnosticRequest(cByte3) - (U8)1;
   \   0020   A1FF           MOV       A,#255
   \   0022   08....         ADD       A,DATKwpRxBuffer+6
   \   0025   70             MOV       X,A
   1692                      // Control requested parameter
   1693                      if (LAPKwpReadDiagnosticRequest(cByte4) == 0x01)   // Output activated
   \   0026   8E....         MOV       A,DATKwpRxBuffer+7
   \   0029   51             DEC       A
   \   002A   BD1E           BNZ       ??TreatEepromTest_Static_117
   1694                      {
   1695                          SetOutput(u8OutputIndex);
   \   002C   60             MOV       A,X
   \   002D   16....         MOVW      HL,#LWRD(SetOutput)
   \   0030   A4..           MOV       E,#BYTE3(SetOutput)
   \                     ??LAPTfcTreatInputOutputControlByLocalIdentifie_0:
   \   0032   ..             CALLT     [__T_?FAR_FAST_CALL_L07]
   1696                          u8RequestStatus = cLAPKwpServiceIsCorrect;
   1697          
   1698                      }
   1699                      else if(LAPKwpReadDiagnosticRequest(cByte4) == 0x00)   // Output deactived
   1700                      {
   1701                          ClearOutput(u8OutputIndex);
   1702                          u8RequestStatus = cLAPKwpServiceIsCorrect;
   1703                      }
   1704                      else
   1705                      {
   1706                          // invalid format
   1707                      }
   1708          
   1709                  }
   1710              }
   1711              // Request treatment is finished or status is not correct
   1712              if(u8RequestStatus != cLAPKwpServiceIsCorrect)
   1713              {
   1714                  LAPKwpPrepareNegativeResponse(u8RequestStatus);
   1715              }
   1716              else
   1717              {
   1718                  LAPKwpPreparePositiveResponse(cIOCBLIDAns_Lgth);
   \   0033   A103           MOV       A,#3
   \   0035   9A....         CALL      LAPKwpPreparePositiveResponse
   1719                  LAPKwpWriteDiagnosticResponse(1,LAPKwpReadDiagnosticRequest(1));
   \   0038   8E....         MOV       A,DATKwpRxBuffer+4
   \   003B   9E....         MOV       DATKwpTxBuffer+4,A
   1720                  LAPKwpWriteDiagnosticResponse(cByte2,cRoutineInProgress); // prsFS-532
   \   003E   A110           MOV       A,#16
   \   0040   16....         MOVW      HL,#DATKwpTxBuffer+5
   \   0043   97             MOV       [HL],A
   1721              }
   1722              LAPKwpSetServiceIsFinished();
   \                     ??LAPTfcTreatInputOutputControlByLocalIdentifie_1:
   \   0044   A103           MOV       A,#3
   \   0046   9E....         MOV       u8LAPKwpRequestStatus,A
   1723          }
   \   0049   AF             RET       
   \                     ??TreatEepromTest_Static_117:
   \   004A   8E....         MOV       A,DATKwpRxBuffer+7
   \   004D   4D00           CMP       A,#0
   \   004F   BD08           BNZ       ??TreatEepromTest_Static_116
   \   0051   60             MOV       A,X
   \   0052   16....         MOVW      HL,#LWRD(ClearOutput)
   \   0055   A4..           MOV       E,#BYTE3(ClearOutput)
   \   0057   FAD9           BR        ??LAPTfcTreatInputOutputControlByLocalIdentifie_0
   \                     ??TreatEepromTest_Static_116:
   \   0059   A112           MOV       A,#18
   \   005B   9A....         CALL      LAPKwpPrepareNegativeResponse
   \   005E   FAE4           BR        ??LAPTfcTreatInputOutputControlByLocalIdentifie_1
   \   0060                  REQUIRE ?CL78K_V4_6_L00
   1724          
   1725          //==============================================================================
   1726          // DESCRIPTION:         LAPTfcTreatStartRoutineByLocalIdentifierService
   1727          //
   1728          // PARAMETERS:          none
   1729          //
   1730          // RETURN VALUE:        none
   1731          //
   1732          // DESIGN INFORMATION:  refer to Detailed Design Document
   1733          //==============================================================================
   1734          // akodzhh: Size of this function exceeds 100 lines. It is AW1092 reuse, keep for readability.

   \                                 In  segment BCODE, align 1, keep-with-next
   1735          MEM_TYPE void LAPTfcTreatStartRoutineByLocalIdentifierService(void)
   \                     LAPTfcTreatStartRoutineByLocalIdentifierService:
   1736          {
   \   0000                  ; * Stack frame (at entry) *
   \   0000                  ; Param size: 0
   \   0000   B3             PUSH      BC
   \   0001                  ; Total Auto size: 2
   \   0001   B7             PUSH      HL
   1737              U8  u8AnswerStatus;
   1738              U8  u8LenghtAnswer;
   1739              U8  u8Index;
   1740              U8  u8SerialLineTestStatus;
   1741              U8  u8ByteNb;
   1742              
   1743              u8AnswerStatus = cLAPKwpServiceIsCorrect;
   \   0002   891C           MOVW      AX,SP
   \   0004   D6             MOVW      HL,AX
   \   0005   A100           MOV       A,#0
   \   0007   97             MOV       [HL],A
   1744              u8LenghtAnswer = cSRBLID_StaticRepLgth;
   \   0008   A103           MOV       A,#3
   \   000A   86             INCW      HL
   \   000B   97             MOV       [HL],A
   1745          
   1746              switch(LAPKwpReadDiagnosticRequest(1))
   \   000C   8E....         MOV       A,DATKwpRxBuffer+4
   \   000F   4DF0           CMP       A,#240
   \   0011   BD03           BNZ       $+5
   \   0013   9B....         BR        N:??TreatEepromTest_Static_118
   \   0016   4DF1           CMP       A,#241
   \   0018   BD03           BNZ       $+5
   \   001A   9B....         BR        N:??TreatEepromTest_Static_119
   \   001D   4DF9           CMP       A,#249
   \   001F   AD22           BZ        ??TreatEepromTest_Static_120
   \   0021   4DFB           CMP       A,#251
   \   0023   AD77           BZ        ??TreatEepromTest_Static_121
   \   0025   4DFC           CMP       A,#252
   \   0027   BD03           BNZ       $+5
   \   0029   9B....         BR        N:??TreatEepromTest_Static_122
   \   002C   4DFD           CMP       A,#253
   \   002E   BD03           BNZ       $+5
   \   0030   9B....         BR        N:??TreatEepromTest_Static_123
   \   0033   4DFE           CMP       A,#254
   \   0035   BD03           BNZ       $+5
   \   0037   9B....         BR        N:??TreatEepromTest_Static_124
   \   003A   4DFF           CMP       A,#255
   \   003C   BD03           BNZ       $+5
   \   003E   9B....         BR        N:??TreatEepromTest_Static_125
   \   0041   FA2F           BR        ??TreatEepromTest_Static_126
   1747              {
   1748              case cSRBID_FlasherTest:
   1749                  if( LAPKwpIsServiceTreated() == cFalse )    // prsFS-534 - no routine option byte (command)
   \                     ??TreatEepromTest_Static_120:
   \   0043   8E....         MOV       A,u8LAPKwpRequestStatus
   \   0046   4D02           CMP       A,#2
   \   0048   AD30           BZ        ??TreatEepromTest_Static_127
   1750                  {
   1751                      if ( mDATRead(U8Bit,DATKwpRxFrameLgth,Default) == (cSRBID_FlasherTestReq_Lgth)) 
   \   004A   8E....         MOV       A,DATKwpRxFrameLgth
   \   004D   4D03           CMP       A,#3
   \   004F   BD21           BNZ       ??TreatEepromTest_Static_126
   1752                      {
   1753                          if (LAPKwpReadDiagnosticRequest(cByte2) == 0x01) // Right flasher
   \   0051   8E....         MOV       A,DATKwpRxBuffer+5
   \   0054   51             DEC       A
   \   0055   BD0A           BNZ       ??TreatEepromTest_Static_128
   1754                          {
   1755          
   1756                              TOSSendControl(cTOSControlRightFlashingForTFC);
   \   0057   A11D           MOV       A,#29
   \   0059   ..             CALLT     [__T_TOSSendControl]
   1757                              // Stop the output control by diag (the soft component flasher shoud set this output)
   1758                              mDATWriteTable(U1Bit,DATPouDiagMaskBuffer,u16OutputTab[1],0,Default);
   \   005A   A102           MOV       A,#2
   \   005C   7B..           CLR1      S:DATPouDiagMaskBuffer+3.7
   1759          
   1760                              LAPKwpSetServiceIsTreated();
   \   005E   9B....         BR        N:??TreatEepromTest_Static_129
   1761                          }
   1762                          else if (LAPKwpReadDiagnosticRequest(cByte2) == 0x00) // Left flasher
   \                     ??TreatEepromTest_Static_128:
   \   0061   8E....         MOV       A,DATKwpRxBuffer+5
   \   0064   4D00           CMP       A,#0
   \   0066   BD0A           BNZ       ??TreatEepromTest_Static_126
   1763                          {
   1764                              TOSSendControl(cTOSControlLeftFlashingForTFC);
   \   0068   A11E           MOV       A,#30
   \   006A   ..             CALLT     [__T_TOSSendControl]
   1765                              // Stop the output control by diag (the soft component flasher shoud set this output)
   1766                              mDATWriteTable(U1Bit,DATPouDiagMaskBuffer,u16OutputTab[0],0,Default);
   \   006B   A102           MOV       A,#2
   \   006D   6B..           CLR1      S:DATPouDiagMaskBuffer+3.6
   1767          
   1768                              LAPKwpSetServiceIsTreated();
   \   006F   9B....         BR        N:??TreatEepromTest_Static_129
   1769                          }
   1770                          else
   1771                          {
   1772                              u8AnswerStatus = cLAPKwpInvalidFormat;
   \                     ??TreatEepromTest_Static_126:
   \   0072   891C           MOVW      AX,SP
   \   0074   D6             MOVW      HL,AX
   \   0075   A112           MOV       A,#18
   \   0077   9B....         BR        N:??TreatEepromTest_Static_130
   1773                          }
   1774                      }
   1775                      else
   1776                      {
   1777                          u8AnswerStatus = cLAPKwpInvalidFormat;
   1778                      }
   1779          
   1780                  }
   1781                  else // service treated - chek results
   1782                  {
   1783                      if (mDATRead(U8Bit, FlasherLampsTestResult, Default) == cDATCmnFlasherLampsAreOK)
   \                     ??TreatEepromTest_Static_127:
   \   007A   8E....         MOV       A,DATCmnData+2
   \   007D   4D02           CMP       A,#2
   \   007F   BD11           BNZ       ??TreatEepromTest_Static_131
   1784                      {
   1785          
   1786                          LAPKwpWriteDiagnosticResponse(cByte2,0x01);    // Lamp OK
   \   0081   A101           MOV       A,#1
   \                     ??LAPTfcTreatStartRoutineByLocalIdentifierServi_0:
   \   0083   16....         MOVW      HL,#DATKwpTxBuffer+5
   \   0086   97             MOV       [HL],A
   1787                          // Restart the output control by diag 
   1788                          mDATWriteTable(U1Bit,DATPouDiagMaskBuffer,u16OutputTab[1],1,Default);
   1789                          mDATWriteTable(U1Bit,DATPouDiagMaskBuffer,u16OutputTab[0],1,Default);
   \   0087   A103           MOV       A,#3
   \   0089   E8..C0         OR        S:DATPouDiagMaskBuffer+3,#192
   1790          
   1791                          LAPKwpSetServiceIsFinished();
   \   008C   9E....         MOV       u8LAPKwpRequestStatus,A
   \   008F   9B....         BR        N:??TreatEepromTest_Static_132
   1792                      }
   1793                      else if (mDATRead(U8Bit, FlasherLampsTestResult, Default) == cDATCmnFlasherLampIsBurnedOut)
   \                     ??TreatEepromTest_Static_131:
   \   0092   51             DEC       A
   \   0093   AD03           BZ        $+5
   \   0095   9B....         BR        N:??TreatEepromTest_Static_133
   1794                      {
   1795          
   1796                          LAPKwpWriteDiagnosticResponse(cByte2,0x00);    // burned out lamp   
   \   0098   A100           MOV       A,#0
   \   009A   FAE7           BR        ??LAPTfcTreatStartRoutineByLocalIdentifierServi_0
   1797                          // Restart the output control by diag 
   1798                          mDATWriteTable(U1Bit,DATPouDiagMaskBuffer,u16OutputTab[1],1,Default);
   1799                          mDATWriteTable(U1Bit,DATPouDiagMaskBuffer,u16OutputTab[0],1,Default);
   1800          
   1801                          LAPKwpSetServiceIsFinished();  
   1802                      }
   1803                      else
   1804                      {
   1805                      // in progress - wait next cycle
   1806                      }
   1807          
   1808                  }
   1809                  break;
   1810          
   1811              case cSRBID_RFTest:
   1812                  if (LAPKwpReadDiagnosticRequest(cByte2) == 0x00) // Launch the routine
   \                     ??TreatEepromTest_Static_121:
   \   009C   8E....         MOV       A,DATKwpRxBuffer+5
   \   009F   4D00           CMP       A,#0
   \   00A1   BD21           BNZ       ??TreatEepromTest_Static_134
   1813                  {
   1814                      if ( mDATRead(U8Bit,DATKwpRxFrameLgth,Default) == cSRBID_RFTestReq_Lgth) 
   \   00A3   8E....         MOV       A,DATKwpRxFrameLgth
   \   00A6   4D03           CMP       A,#3
   \   00A8   BDC8           BNZ       ??TreatEepromTest_Static_126
   1815                      {
   1816                          // Launch the RF test
   1817                          mDATControl(Rf, InitializeRFTest);
   \   00AA   9A....         CALL      DATRfInitializeRFTest
   1818          
   1819                          RoutineRequestInProgress[cRoutineIndexRFTest] = cRoutineInProgress;
   \   00AD   A110           MOV       A,#16
   \   00AF   9E....         MOV       RoutineRequestInProgress+1,A
   1820                          u8LenghtAnswer = cSRBLID_RFTestRepLgth;
   \   00B2   891C           MOVW      AX,SP
   \   00B4   80             INCW      AX
   \   00B5   D6             MOVW      HL,AX
   \   00B6   A104           MOV       A,#4
   \   00B8   97             MOV       [HL],A
   1821                          LAPKwpWriteDiagnosticResponse(cByte3,mDATRead(U8Bit, DATRfNbRCBlocksReceivedCrcOK, Default));
   \   00B9   8E....         MOV       A,DATRfNbRCBlocksReceivedCrcOK
   \   00BC   9E....         MOV       DATKwpTxBuffer+6,A
   1822                          LAPKwpWriteDiagnosticResponse(cByte2,cRoutineInProgress);
   \                     ??LAPTfcTreatStartRoutineByLocalIdentifierServi_1:
   \   00BF   A110           MOV       A,#16
   \   00C1   9B....         BR        N:??TreatEepromTest_Static_135
   1823                          
   1824                      }
   1825                      else
   1826                      {
   1827                          u8AnswerStatus = cLAPKwpInvalidFormat;
   1828                      }
   1829                  }
   1830                  else if ( (LAPKwpReadDiagnosticRequest(cByte2) == 0x01) // Request status
   1831                        &&( mDATRead(U8Bit,DATKwpRxFrameLgth,Default) == cSRBLID_StatusReq_Lgth) )
   \                     ??TreatEepromTest_Static_134:
   \   00C4   51             DEC       A
   \   00C5   BDAB           BNZ       ??TreatEepromTest_Static_126
   \   00C7   8E....         MOV       A,DATKwpRxFrameLgth
   \   00CA   4D03           CMP       A,#3
   \   00CC   BDA4           BNZ       ??TreatEepromTest_Static_126
   1832                  {
   1833                      u8LenghtAnswer = cSRBLID_RFTestRepLgth;
   \   00CE   A104           MOV       A,#4
   \   00D0   97             MOV       [HL],A
   1834                      // Cm006291: update for prsFS-891
   1835                      if(RoutineRequestInProgress[cRoutineIndexRFTest] == cRoutineInProgress)
   \   00D1   8E....         MOV       A,RoutineRequestInProgress+1
   \   00D4   4D10           CMP       A,#16
   \   00D6   BD1F           BNZ       ??TreatEepromTest_Static_136
   1836                      {
   1837                          if( mDATRead(U8Bit, DATRfNbRCBlocksReceivedCrcOK, Default) == (U8)0x00 )
   \   00D8   8E....         MOV       A,DATRfNbRCBlocksReceivedCrcOK
   \   00DB   4D00           CMP       A,#0
   \   00DD   BD0A           BNZ       ??TreatEepromTest_Static_137
   1838                          {
   1839                              LAPKwpWriteDiagnosticResponse(cByte2,cRoutineTerminatedNOK);
   \   00DF   A140           MOV       A,#64
   \   00E1   16....         MOVW      HL,#DATKwpTxBuffer+5
   \   00E4   97             MOV       [HL],A
   1840                              LAPKwpWriteDiagnosticResponse(cByte3,(U8)0x00);
   \   00E5   A100           MOV       A,#0
   \   00E7   FA14           BR        ??TreatEepromTest_Static_138
   1841                          }
   1842                          else
   1843                          {
   1844                              LAPKwpWriteDiagnosticResponse(cByte2,cRoutineTerminatedOK);
   \                     ??TreatEepromTest_Static_137:
   \   00E9   A120           MOV       A,#32
   \   00EB   16....         MOVW      HL,#DATKwpTxBuffer+5
   \   00EE   97             MOV       [HL],A
   1845                              LAPKwpWriteDiagnosticResponse(cByte3,mDATRead(U8Bit, DATRfNbRCBlocksReceivedCrcOK, Default));
   \   00EF   8E....         MOV       A,DATRfNbRCBlocksReceivedCrcOK
   \   00F2   9E....         MOV       DATKwpTxBuffer+6,A
   \   00F5   FA08           BR        ??TreatEepromTest_Static_139
   1846                          }
   1847                      }
   1848                      else
   1849                      {
   1850                          LAPKwpWriteDiagnosticResponse(cByte2,cRoutineNotActivated);
   \                     ??TreatEepromTest_Static_136:
   \   00F7   A100           MOV       A,#0
   \   00F9   16....         MOVW      HL,#DATKwpTxBuffer+5
   \   00FC   97             MOV       [HL],A
   1851                          LAPKwpWriteDiagnosticResponse(cByte3,(U8)0x00);
   \                     ??TreatEepromTest_Static_138:
   \   00FD   86             INCW      HL
   \   00FE   97             MOV       [HL],A
   1852                      }
   1853                      
   1854                      RoutineRequestInProgress[cRoutineIndexRFTest] = cRoutineNotActivated;
   \                     ??TreatEepromTest_Static_139:
   \   00FF   A100           MOV       A,#0
   \   0101   9E....         MOV       RoutineRequestInProgress+1,A
   \   0104   9B....         BR        N:??TreatEepromTest_Static_140
   1855                      
   1856                  }
   1857                  else
   1858                  {
   1859                      u8AnswerStatus = cLAPKwpInvalidFormat;
   1860                  }
   1861                  break;
   1862          
   1863              case cSRBID_AutoTestTOR:
   1864                  if( (mDATRead(U8Bit,DATKwpRxFrameLgth,Default) == cSRBLID_StatusReq_Lgth)   // prsFS-583 - stop AutoTest
   1865                    &&(LAPKwpReadDiagnosticRequest(cSequenceModeBytePos) == cModeContinueOnErrorTx))
   \                     ??TreatEepromTest_Static_122:
   \   0107   8E....         MOV       A,DATKwpRxFrameLgth
   \   010A   4D03           CMP       A,#3
   \   010C   BD72           BNZ       ??TreatEepromTest_Static_141
   \   010E   8E....         MOV       A,DATKwpRxBuffer+5
   \   0111   4D03           CMP       A,#3
   \   0113   BD6B           BNZ       ??TreatEepromTest_Static_141
   1866                  {
   1867                      if(RoutineRequestInProgress[cRoutineIndexAutoTestTOR] == cRoutineInProgress)
   \   0115   8E....         MOV       A,RoutineRequestInProgress+2
   \   0118   4D10           CMP       A,#16
   \   011A   BD1C           BNZ       ??TreatEepromTest_Static_142
   1868                      {
   1869                          // Exit graph
   1870                          StopAutoTestTOR();
   \   011C   A106           MOV       A,#6
   \   011E   ..             CALLT     [__T_TOSSeqGraphState]
   \   011F   51             DEC       A
   \   0120   BD11           BNZ       ??TreatEepromTest_Static_143
   \   0122   A106           MOV       A,#6
   \   0124   ..             CALLT     [__T_TOSSeqDeactivateGraph]
   \   0125   8E....         MOV       A,bOutputsActivated
   \   0128   51             DEC       A
   \   0129   BD08           BNZ       ??TreatEepromTest_Static_143
   \   012B   A100           MOV       A,#0
   \   012D   16....         MOVW      HL,#LWRD(DeactivateOutputs)
   \   0130   A4..           MOV       E,#BYTE3(DeactivateOutputs)
   \   0132   ..             CALLT     [__T_?FAR_FAST_CALL_L07]
   1871                          // not finished but terminated
   1872                          RoutineRequestInProgress[cRoutineIndexAutoTestTOR] = cRoutineTerminatedNOK;
   \                     ??TreatEepromTest_Static_143:
   \   0133   A140           MOV       A,#64
   \   0135   9E....         MOV       RoutineRequestInProgress+2,A
   1873                      }
   1874          
   1875                      // prsFS-579
   1876                      u8LenghtAnswer = cSRBLID_AutoTestTOR_RepLgth;
   \                     ??TreatEepromTest_Static_142:
   \   0138   891C           MOVW      AX,SP
   \   013A   80             INCW      AX
   \   013B   D6             MOVW      HL,AX
   \   013C   A109           MOV       A,#9
   \   013E   97             MOV       [HL],A
   1877          
   1878                      u8ByteNb = cByte2;
   1879                      // Set work status
   1880                      LAPKwpWriteDiagnosticResponse(u8ByteNb,RoutineRequestInProgress[cRoutineIndexAutoTestTOR]);
   \   013F   8E....         MOV       A,RoutineRequestInProgress+2
   \   0142   9E....         MOV       DATKwpTxBuffer+5,A
   1881                      u8ByteNb++;
   1882                      // set response data
   1883                      LAPKwpWriteDiagnosticResponse(u8ByteNb,u8OrderingMatrixCounter);
   \   0145   8E....         MOV       A,u8OrderingMatrixCounter
   \   0148   9E....         MOV       DATKwpTxBuffer+6,A
   1884                      u8ByteNb++;
   1885                      LAPKwpWriteDiagnosticResponse(u8ByteNb,(U8)u16ErrorsOnOutput     );
   \   014B   8E....         MOV       A,u16ErrorsOnOutput
   \   014E   9E....         MOV       DATKwpTxBuffer+7,A
   1886                      u8ByteNb++;
   1887                      LAPKwpWriteDiagnosticResponse(u8ByteNb,(U8)(u16ErrorsOnOutput>>c8Bits));
   \   0151   02....         MOVW      AX,u16ErrorsOnOutput
   \   0154   9E....         MOV       DATKwpTxBuffer+8,A
   1888                      u8ByteNb++;
   1889                      LAPKwpWriteDiagnosticResponse(u8ByteNb,(U8)u32ErrorsOnInput      );
   \   0157   02....         MOVW      AX,u32ErrorsOnInput
   \   015A   60             MOV       A,X
   \   015B   9E....         MOV       DATKwpTxBuffer+9,A
   1890                      u8ByteNb++;
   1891                      LAPKwpWriteDiagnosticResponse(u8ByteNb,(U8)(u32ErrorsOnInput>>c8Bits) );
   \   015E   8E....         MOV       A,u32ErrorsOnInput+1
   \   0161   9E....         MOV       DATKwpTxBuffer+10,A
   1892                      u8ByteNb++;
   1893                      LAPKwpWriteDiagnosticResponse(u8ByteNb,(U8)(u32ErrorsOnInput>>c16Bits));
   \   0164   02....         MOVW      AX,u32ErrorsOnInput+2
   \   0167   60             MOV       A,X
   \   0168   9E....         MOV       DATKwpTxBuffer+11,A
   1894          
   1895                      RoutineRequestInProgress[cRoutineIndexAutoTestTOR]  = cRoutineNotActivated;
   \   016B   A100           MOV       A,#0
   \   016D   9E....         MOV       RoutineRequestInProgress+2,A
   1896                      u8OrderingMatrixCounter = 0;
   \   0170   9E....         MOV       u8OrderingMatrixCounter,A
   1897                      u16ErrorsOnOutput = 0;
   \   0173   70             MOV       X,A
   \   0174   03....         MOVW      u16ErrorsOnOutput,AX
   1898                      u32ErrorsOnInput = 0;
   \   0177   03....         MOVW      u32ErrorsOnInput+2,AX
   \   017A   03....         MOVW      u32ErrorsOnInput,AX
   \   017D   9B....         BR        N:??TreatEepromTest_Static_140
   1899          
   1900                  }
   1901                  else    // start AutoTest
   1902                  {
   1903                      u8AnswerStatus = StartAutoTestTOR();
   \                     ??TreatEepromTest_Static_141:
   \   0180   16....         MOVW      HL,#LWRD(StartAutoTestTOR)
   \   0183   A4..           MOV       E,#BYTE3(StartAutoTestTOR)
   \   0185   ..             CALLT     [__T_?FAR_FAST_CALL_L07]
   \   0186   D6             MOVW      HL,AX
   \   0187   891C           MOVW      AX,SP
   \   0189   E6             XCHW      AX,HL
   \   018A   97             MOV       [HL],A
   1904                      if(u8AnswerStatus == cLAPKwpServiceIsCorrect)
   \   018B   4D00           CMP       A,#0
   \   018D   AD03           BZ        $+5
   \   018F   9B....         BR        N:??TreatEepromTest_Static_140
   1905                      {
   1906                          RoutineRequestInProgress[cRoutineIndexAutoTestTOR] = cRoutineInProgress;
   \   0192   A110           MOV       A,#16
   \   0194   9E....         MOV       RoutineRequestInProgress+2,A
   1907                          LAPKwpWriteDiagnosticResponse(cByte2,cRoutineInProgress);
   \   0197   9B....         BR        N:??TreatEepromTest_Static_135
   1908                      }
   1909          
   1910                  }
   1911                  break;
   1912          
   1913              case cSRBID_SerialLineTest:
   1914                  if (LAPKwpReadDiagnosticRequest(cByte2) == 0x00) // Launch the routine
   \                     ??TreatEepromTest_Static_123:
   \   019A   8E....         MOV       A,DATKwpRxBuffer+5
   \   019D   4D00           CMP       A,#0
   \   019F   BD46           BNZ       ??TreatEepromTest_Static_144
   1915                  {
   1916                      if ( mDATRead(U8Bit,DATKwpRxFrameLgth,Default) == cSRBID_SerialLineTestReq_Lgth) 
   \   01A1   8E....         MOV       A,DATKwpRxFrameLgth
   \   01A4   4D04           CMP       A,#4
   \   01A6   AD03           BZ        $+5
   \   01A8   9B....         BR        N:??TreatEepromTest_Static_126
   1917                      {
   1918                          if(LAPKwpReadDiagnosticRequest(cByte3) == cSerialLineImmobilizer)
   \   01AB   8E....         MOV       A,DATKwpRxBuffer+6
   \   01AE   4D02           CMP       A,#2
   \   01B0   BD20           BNZ       ??TreatEepromTest_Static_145
   1919                          {
   1920                              if(mDATRead(U8Bit,DATTrpAuthenticationState,Default) != cDATTrpServiceInProgress)
   \   01B2   8E....         MOV       A,DatTrpExportData+44
   \   01B5   51             DEC       A
   \   01B6   AD12           BZ        ??TreatEepromTest_Static_146
   1921                              {
   1922                                  // Launch the  test
   1923                                  mDATControl(Trp,  cDATTrpTfcDiag);
   \   01B8   A10E           MOV       A,#14
   \   01BA   ..             CALLT     [__T_DATTrpControl]
   1924                                  if(mDATRead(U8Bit,DATTrpAuthenticationState,Default) == cDATTrpServiceInProgress)
   \   01BB   8E....         MOV       A,DatTrpExportData+44
   \   01BE   51             DEC       A
   \   01BF   BD09           BNZ       ??TreatEepromTest_Static_146
   1925                                  {
   1926                                      RoutineRequestInProgress[cRoutineIndexSerialLineImmoTest] = cRoutineInProgress;
   \   01C1   A110           MOV       A,#16
   \   01C3   16....         MOVW      HL,#RoutineRequestInProgress+3
   \                     ??LAPTfcTreatStartRoutineByLocalIdentifierServi_2:
   \   01C6   97             MOV       [HL],A
   1927                                      LAPKwpWriteDiagnosticResponse(cByte2,cRoutineInProgress);
   \   01C7   9B....         BR        N:??TreatEepromTest_Static_135
   1928                                  }
   1929                                  else
   1930                                  {
   1931                                      u8AnswerStatus = cLAPKwpConditionNotCorrect;
   \                     ??TreatEepromTest_Static_146:
   \   01CA   891C           MOVW      AX,SP
   \   01CC   D6             MOVW      HL,AX
   \   01CD   A122           MOV       A,#34
   \   01CF   9B....         BR        N:??TreatEepromTest_Static_130
   1932                                  }
   1933                              }
   1934                              else
   1935                              {
   1936                                  u8AnswerStatus = cLAPKwpConditionNotCorrect;
   1937                              }
   1938                              
   1939                          }
   1940                          else if (LAPKwpReadDiagnosticRequest(cByte3) == cSerialLineVerlog)
   \                     ??TreatEepromTest_Static_145:
   \   01D2   51             DEC       A
   \   01D3   AD03           BZ        $+5
   \   01D5   9B....         BR        N:??TreatEepromTest_Static_126
   1941                          {   
   1942                              // start ECM test
   1943                              mDATControl(Vlg, cDATVlgSerialTest);
   \   01D8   A102           MOV       A,#2
   \   01DA   16....         MOVW      HL,#LWRD(DATVlgControl)
   \   01DD   A4..           MOV       E,#BYTE3(DATVlgControl)
   \   01DF   ..             CALLT     [__T_?FAR_CALL_L07]
   1944                              RoutineRequestInProgress[cRoutineIndexSerialLineVerlogTest] = cRoutineInProgress;
   \   01E0   A110           MOV       A,#16
   \   01E2   16....         MOVW      HL,#RoutineRequestInProgress+4
   \   01E5   FADF           BR        ??LAPTfcTreatStartRoutineByLocalIdentifierServi_2
   1945                              LAPKwpWriteDiagnosticResponse(cByte2,cRoutineInProgress);
   1946                          }
   1947                          else
   1948                          {   // sub service not suported
   1949                              u8AnswerStatus = cLAPKwpInvalidFormat;
   1950                          }
   1951                      }
   1952                      else
   1953                      {
   1954                          u8AnswerStatus = cLAPKwpInvalidFormat;
   1955                      }
   1956                  }
   1957                  else if ( (LAPKwpReadDiagnosticRequest(cByte2) == 0x01) // Request status; length 4
   1958                        &&( mDATRead(U8Bit,DATKwpRxFrameLgth,Default) == cSRBID_SerialLineTestReq_Lgth) ) // prsFS-601
   \                     ??TreatEepromTest_Static_144:
   \   01E7   51             DEC       A
   \   01E8   AD03           BZ        $+5
   \   01EA   9B....         BR        N:??TreatEepromTest_Static_126
   \   01ED   8E....         MOV       A,DATKwpRxFrameLgth
   \   01F0   4D04           CMP       A,#4
   \   01F2   AD03           BZ        $+5
   \   01F4   9B....         BR        N:??TreatEepromTest_Static_126
   1959                  {
   1960                      if(LAPKwpReadDiagnosticRequest(cByte3) == cSerialLineImmobilizer)
   \   01F7   8E....         MOV       A,DATKwpRxBuffer+6
   \   01FA   4D02           CMP       A,#2
   \   01FC   BD2A           BNZ       ??TreatEepromTest_Static_147
   1961                      {
   1962                          if(RoutineRequestInProgress[cRoutineIndexSerialLineImmoTest] == cRoutineInProgress )
   \   01FE   8E....         MOV       A,RoutineRequestInProgress+3
   \   0201   4D10           CMP       A,#16
   \   0203   AD03           BZ        $+5
   \   0205   9B....         BR        N:??TreatEepromTest_Static_148
   1963                          {
   1964                              u8SerialLineTestStatus = mDATRead(U8Bit,DATTrpAuthenticationState,Default); 
   \   0208   8E....         MOV       A,DatTrpExportData+44
   1965                              if (u8SerialLineTestStatus == cDATTrpServiceSuccessful)
   \   020B   4D02           CMP       A,#2
   \   020D   BD0E           BNZ       ??TreatEepromTest_Static_149
   1966                              {
   1967                                  LAPKwpWriteDiagnosticResponse(cByte2,cRoutineTerminatedOK);
   \   020F   A120           MOV       A,#32
   \                     ??LAPTfcTreatStartRoutineByLocalIdentifierServi_3:
   \   0211   16....         MOVW      HL,#DATKwpTxBuffer+5
   \   0214   97             MOV       [HL],A
   1968                                  // Routine is finished - clear status
   1969                                  RoutineRequestInProgress[cRoutineIndexSerialLineImmoTest] = cRoutineNotActivated;
   \   0215   A100           MOV       A,#0
   \   0217   16....         MOVW      HL,#RoutineRequestInProgress+3
   \   021A   9B....         BR        N:??TreatEepromTest_Static_130
   1970                              }
   1971                              else if(u8SerialLineTestStatus == cDATTrpServiceNotSuccessful)
   \                     ??TreatEepromTest_Static_149:
   \   021D   4D03           CMP       A,#3
   \   021F   AD03           BZ        $+5
   \   0221   9B....         BR        N:??LAPTfcTreatStartRoutineByLocalIdentifierServi_1
   1972                              {
   1973                                  LAPKwpWriteDiagnosticResponse(cByte2,cRoutineTerminatedNOK);
   \   0224   A140           MOV       A,#64
   \   0226   FAE9           BR        ??LAPTfcTreatStartRoutineByLocalIdentifierServi_3
   1974                                  // Routine is finished - clear status
   1975                                  RoutineRequestInProgress[cRoutineIndexSerialLineImmoTest] = cRoutineNotActivated;
   1976                              }
   1977                              else
   1978                              {   // In progress 
   1979                                  LAPKwpWriteDiagnosticResponse(cByte2,cRoutineInProgress);
   1980                              }
   1981                          }
   1982                          else
   1983                          {
   1984                              LAPKwpWriteDiagnosticResponse(cByte2,cRoutineNotActivated);
   1985                          }
   1986          
   1987                      }
   1988                      else if(LAPKwpReadDiagnosticRequest(cByte3) == cSerialLineVerlog)
   \                     ??TreatEepromTest_Static_147:
   \   0228   51             DEC       A
   \   0229   AD03           BZ        $+5
   \   022B   9B....         BR        N:??TreatEepromTest_Static_126
   1989                      {
   1990                          if(RoutineRequestInProgress[cRoutineIndexSerialLineVerlogTest] == cRoutineInProgress )
   \   022E   8E....         MOV       A,RoutineRequestInProgress+4
   \   0231   4D10           CMP       A,#16
   \   0233   AD03           BZ        $+5
   \   0235   9B....         BR        N:??TreatEepromTest_Static_148
   1991                          {
   1992                              // Chek if send is finished 
   1993                              if (mDATRead(U1Bit,DATVlgSerialTestInProgress,Default) == cFalse)
   \   0238   8E....         MOV       A,bDATVlgSerialTestInProgress
   \   023B   4D00           CMP       A,#0
   \   023D   AD03           BZ        $+5
   \   023F   9B....         BR        N:??TreatEepromTest_Static_150
   1994                              {
   1995                                  LAPKwpWriteDiagnosticResponse(cByte2,cRoutineTerminatedOK);
   \   0242   A120           MOV       A,#32
   \   0244   16....         MOVW      HL,#DATKwpTxBuffer+5
   \   0247   97             MOV       [HL],A
   1996                                  // Routine is finished - clear status
   1997                                  RoutineRequestInProgress[cRoutineIndexSerialLineVerlogTest] = cRoutineNotActivated;
   \   0248   A100           MOV       A,#0
   \   024A   16....         MOVW      HL,#RoutineRequestInProgress+4
   \   024D   9B....         BR        N:??TreatEepromTest_Static_130
   1998                              }
   1999                              else
   2000                              {
   2001                                  LAPKwpWriteDiagnosticResponse(cByte2,cRoutineInProgress);
   2002                              }
   2003          
   2004                          }
   2005                          else
   2006                          {
   2007                              LAPKwpWriteDiagnosticResponse(cByte2,cRoutineNotActivated);
   2008                          }
   2009                      }
   2010                      else
   2011                      {
   2012                          u8AnswerStatus = cLAPKwpInvalidFormat;
   2013                      }
   2014                  }
   2015                  else
   2016                  {
   2017                      u8AnswerStatus = cLAPKwpInvalidFormat;
   2018                  }
   2019                  break;
   2020          
   2021              case cSRBID_SleepingMode:
   2022                  if ( (LAPKwpReadDiagnosticRequest(cByte2) == 0x00) // Launch the routine
   2023                      &&(mDATRead(U8Bit,DATKwpRxFrameLgth,Default) == cSRBID_SleepingModeReq_Lgth))
   \                     ??TreatEepromTest_Static_124:
   \   0250   8E....         MOV       A,DATKwpRxBuffer+5
   \   0253   4D00           CMP       A,#0
   \   0255   AD03           BZ        $+5
   \   0257   9B....         BR        N:??TreatEepromTest_Static_126
   \   025A   8E....         MOV       A,DATKwpRxFrameLgth
   \   025D   4D03           CMP       A,#3
   \   025F   AD03           BZ        $+5
   \   0261   9B....         BR        N:??TreatEepromTest_Static_126
   2024                  {
   2025                      TOSStartTimer(&SleepTimer);
   \   0264   10....         MOVW      AX,#SleepTimer
   \   0267   ..             CALLT     [__T_TOSStartTimer]
   2026                      TOSSeqActivateGraph(cTOSSeqLAPTfcGraph);
   \   0268   A107           MOV       A,#7
   \   026A   ..             CALLT     [__T_TOSSeqActivateGraph]
   2027                      mDATWrite(U1Bit, BcmSleepRequested, cTrue, Default); // Cm007575
   \   026B   A101           MOV       A,#1
   \   026D   16....         MOVW      HL,#LWRD(DATCmnSetBcmSleepRequested)
   \   0270   A4..           MOV       E,#BYTE3(DATCmnSetBcmSleepRequested)
   \   0272   ..             CALLT     [__T_?FAR_CALL_L07]
   2028          
   2029                      LAPKwpWriteDiagnosticResponse(cByte2,cRoutineTerminatedOK);
   \   0273   9B....         BR        N:??TreatEepromTest_Static_151
   2030                     
   2031                  }
   2032                  else
   2033                  {
   2034                      u8AnswerStatus = cLAPKwpInvalidFormat;
   2035                  }
   2036                  break;   
   2037          
   2038              case cSRBID_EepromTest:
   2039                  if (LAPKwpReadDiagnosticRequest(cByte2) == 0x00) // Launch the routine
   \                     ??TreatEepromTest_Static_125:
   \   0276   8E....         MOV       A,DATKwpRxBuffer+5
   \   0279   4D00           CMP       A,#0
   \   027B   BD57           BNZ       ??TreatEepromTest_Static_152
   2040                  {
   2041                      if ( mDATRead(U8Bit,DATKwpRxFrameLgth,Default) == cSRBID_EepromTestReq_Lgth) 
   \   027D   8E....         MOV       A,DATKwpRxFrameLgth
   \   0280   4D03           CMP       A,#3
   \   0282   AD03           BZ        $+5
   \   0284   9B....         BR        N:??TreatEepromTest_Static_126
   2042                      {
   2043                          
   2044                          if(RoutineRequestInProgress[cRoutineIndexEepromTest] != cRoutineInProgress)
   \   0287   8E....         MOV       A,RoutineRequestInProgress+6
   \   028A   4D10           CMP       A,#16
   \   028C   AD35           BZ        ??TreatEepromTest_Static_150
   2045                          {   
   2046                              
   2047                              if(mDATRead(U8Bit,DATDeaActionIsFinished,Default) == cTrue)
   \   028E   8E....         MOV       A,DATDeaActionIsFinished
   \   0291   51             DEC       A
   \   0292   BD32           BNZ       ??TreatEepromTest_Static_153
   2048                              {   
   2049                                  RoutineRequestInProgress[cRoutineIndexEepromTest] = cRoutineInProgress;
   \   0294   A110           MOV       A,#16
   \   0296   16....         MOVW      HL,#RoutineRequestInProgress+6
   \   0299   97             MOV       [HL],A
   2050          
   2051                                  u8EepTestCounter = 0;
   \   029A   A100           MOV       A,#0
   \   029C   9E....         MOV       u8EepTestCounter,A
   2052                                  // Convert Diag index /u8EepTestCounter/ to EepBanksList index
   2053                                  u8Index = BanksCksTable[u8EepTestCounter].u8BankIndex;
   \   029F   8E....         MOV       A,BanksCksTable
   \   02A2   70             MOV       X,A
   2054                                  
   2055                                  // Set read request
   2056                                  mDATWrite(U8Bit, DATDeaSizeBufferInByte, cCksLgth, Default);
   \   02A3   A102           MOV       A,#2
   \   02A5   9E....         MOV       DATDeaSizeBufferInByte,A
   2057                                  mDATWrite(U16Bit, DATDeaAddressInByte, (U16)(EepBanksList[u8Index].Offset<<1), Default);
   \   02A8   60             MOV       A,X
   \   02A9   A004           MOV       X,#4
   \   02AB   3188           MULU      X
   \   02AD   CA....         ADDW      AX,#EepBanksList
   \   02B0   D6             MOVW      HL,AX
   \   02B1   87             MOV       A,[HL]
   \   02B2   70             MOV       X,A
   \   02B3   AE01           MOV       A,[HL+0x01]
   \   02B5   21             CLR1      CY
   \   02B6   30             XCH       A,X
   \   02B7   27             ROLC      A,0x1
   \   02B8   30             XCH       A,X
   \   02B9   27             ROLC      A,0x1
   \   02BA   03....         MOVW      DATDeaAddressInByte,AX
   2058                                  mDATControl(DATDea, StartReadEepromByAddress);
   \   02BD   9A....         CALL      DATDeaStartReadEepromByAddress
   2059          
   2060                                  TOSSeqActivateGraph(cTOSSeqLAPTfcEepTest);
   \   02C0   A108           MOV       A,#8
   \   02C2   ..             CALLT     [__T_TOSSeqActivateGraph]
   2061                              }
   \                     ??TreatEepromTest_Static_150:
   \   02C3   9B....         BR        N:??LAPTfcTreatStartRoutineByLocalIdentifierServi_1
   2062                              else
   2063                              {
   2064                                  u8AnswerStatus = cLAPKwpConditionNotCorrect;
   \                     ??TreatEepromTest_Static_153:
   \   02C6   891C           MOVW      AX,SP
   \   02C8   D6             MOVW      HL,AX
   \   02C9   A122           MOV       A,#34
   \   02CB   97             MOV       [HL],A
   2065                                  RoutineRequestInProgress[cRoutineIndexEepromTest] = cRoutineNotActivated;
   \   02CC   A100           MOV       A,#0
   \   02CE   16....         MOVW      HL,#RoutineRequestInProgress+6
   \   02D1   97             MOV       [HL],A
   \   02D2   FAEF           BR        ??TreatEepromTest_Static_150
   2066                              }
   2067                              
   2068                          }
   2069          
   2070                          LAPKwpWriteDiagnosticResponse(cByte2,cRoutineInProgress);
   2071                      }
   2072                      else
   2073                      {
   2074                          u8AnswerStatus = cLAPKwpInvalidFormat;
   2075                      }
   2076                  }
   2077                  else if ( (LAPKwpReadDiagnosticRequest(cByte2) == 0x01) // Request status
   2078                         &&( mDATRead(U8Bit,DATKwpRxFrameLgth,Default) == cSRBLID_StatusReq_Lgth) )
   \                     ??TreatEepromTest_Static_152:
   \   02D4   51             DEC       A
   \   02D5   AD03           BZ        $+5
   \   02D7   9B....         BR        N:??TreatEepromTest_Static_126
   \   02DA   8E....         MOV       A,DATKwpRxFrameLgth
   \   02DD   4D03           CMP       A,#3
   \   02DF   AD03           BZ        $+5
   \   02E1   9B....         BR        N:??TreatEepromTest_Static_126
   2079                  {
   2080          
   2081                      if (RoutineRequestInProgress[cRoutineIndexEepromTest] == cRoutineTerminatedOK)
   \   02E4   8E....         MOV       A,RoutineRequestInProgress+6
   \   02E7   4D20           CMP       A,#32
   \   02E9   BD3C           BNZ       ??TreatEepromTest_Static_154
   2082                      {
   2083                          u8LenghtAnswer = cSRBLID_StaticRepLgth + (U8)(cNbEepBanks<<(U8)1);
   \   02EB   A117           MOV       A,#23
   \   02ED   97             MOV       [HL],A
   2084                          u8Index = 0;
   2085                          for (u8EepTestCounter = 0; u8EepTestCounter < cNbEepBanks; u8EepTestCounter++)
   \   02EE   A100           MOV       A,#0
   \   02F0   9E....         MOV       u8EepTestCounter,A
   \   02F3   12....         MOVW      BC,#DATKwpTxBuffer+6
   \   02F6   16....         MOVW      HL,#BanksCksTable+1
   2086                          {
   2087                              LAPKwpWriteDiagnosticResponse(cByte3+u8Index, BanksCksTable[u8EepTestCounter].u8BankCksLSB);
   \                     ??LAPTfcTreatStartRoutineByLocalIdentifierServi_4:
   \   02F9   B7             PUSH      HL
   \   02FA   B4             POP       DE
   \   02FB   84             INCW      DE
   \   02FC   85             MOV       A,[DE]
   \   02FD   B3             PUSH      BC
   \   02FE   B4             POP       DE
   \   02FF   95             MOV       [DE],A
   2088                              u8Index++;
   2089                              LAPKwpWriteDiagnosticResponse(cByte3+u8Index, BanksCksTable[u8EepTestCounter].u8BankCksMSB);
   \   0300   87             MOV       A,[HL]
   \   0301   B3             PUSH      BC
   \   0302   B4             POP       DE
   \   0303   84             INCW      DE
   \   0304   95             MOV       [DE],A
   2090                              u8Index++;
   2091                              
   2092                          }
   \   0305   8E....         MOV       A,u8EepTestCounter
   \   0308   41             INC       A
   \   0309   9E....         MOV       u8EepTestCounter,A
   \   030C   86             INCW      HL
   \   030D   86             INCW      HL
   \   030E   86             INCW      HL
   \   030F   B3             PUSH      BC
   \   0310   B4             POP       DE
   \   0311   84             INCW      DE
   \   0312   84             INCW      DE
   \   0313   B5             PUSH      DE
   \   0314   B2             POP       BC
   \   0315   4D0A           CMP       A,#10
   \   0317   8DE0           BC        ??LAPTfcTreatStartRoutineByLocalIdentifierServi_4
   2093                        
   2094                          LAPKwpWriteDiagnosticResponse(cByte2,cRoutineTerminatedOK);
   \   0319   A120           MOV       A,#32
   \                     ??LAPTfcTreatStartRoutineByLocalIdentifierServi_5:
   \   031B   16....         MOVW      HL,#DATKwpTxBuffer+5
   \   031E   97             MOV       [HL],A
   2095                          // Clear status
   2096                          RoutineRequestInProgress[cRoutineIndexEepromTest] = cRoutineNotActivated;
   \   031F   A100           MOV       A,#0
   \   0321   16....         MOVW      HL,#RoutineRequestInProgress+6
   \   0324   9B....         BR        N:??TreatEepromTest_Static_130
   2097                          
   2098                      }
   2099                      //CCOV: akodzhh: can't be covered. This routine is always OK terminated.
   2100                      else if(RoutineRequestInProgress[cRoutineIndexEepromTest] == cRoutineTerminatedNOK)
   \                     ??TreatEepromTest_Static_154:
   \   0327   4D40           CMP       A,#64
   \   0329   BD04           BNZ       ??TreatEepromTest_Static_155
   2101                      {
   2102                          LAPKwpWriteDiagnosticResponse(cByte2,cRoutineTerminatedNOK);
   \   032B   A140           MOV       A,#64
   \   032D   FAEC           BR        ??LAPTfcTreatStartRoutineByLocalIdentifierServi_5
   2103                          // Clear status
   2104                          RoutineRequestInProgress[cRoutineIndexEepromTest] = cRoutineNotActivated;
   2105          
   2106                                          
   2107                      }
   2108                      else // routine not run or in progress
   2109                      {
   2110                          LAPKwpWriteDiagnosticResponse(cByte2,RoutineRequestInProgress[cRoutineIndexEepromTest]);
   \                     ??TreatEepromTest_Static_155:
   \   032F   9E....         MOV       DATKwpTxBuffer+5,A
   \   0332   9B....         BR        N:??TreatEepromTest_Static_140
   2111                      }
   2112                  }
   2113                  else
   2114                  {
   2115                      u8AnswerStatus = cLAPKwpInvalidFormat;
   2116                  }
   2117          
   2118                  break;
   2119          
   2120              case cSRBID_EepromReprogramming:
   2121                  // This routine will perform following actions:
   2122                  // 1. disable all pins (configure pins as inputs)
   2123                  // 2. copy continuosly signal from a given pin to EEPROM CS pin
   2124                  // No positive response is returned - exit is by reset
   2125          
   2126                  if (LAPKwpReadDiagnosticRequest(cByte2) == 0x00) // Launch the routine
   \                     ??TreatEepromTest_Static_118:
   \   0335   8E....         MOV       A,DATKwpRxBuffer+5
   \   0338   4D00           CMP       A,#0
   \   033A   BD1D           BNZ       ??TreatEepromTest_Static_156
   2127                  {
   2128                      if ( mDATRead(U8Bit,DATKwpRxFrameLgth,Default) == cSRBID_EepromTestReq_Lgth) 
   \   033C   8E....         MOV       A,DATKwpRxFrameLgth
   \   033F   4D03           CMP       A,#3
   \   0341   AD03           BZ        $+5
   \   0343   9B....         BR        N:??TreatEepromTest_Static_140
   2129                      {
   2130                          // Start routine
   2131                          mDATControl(EepromReprogramming, Prepare); // prepare routine
   \   0346   A10E           MOV       A,#14
   \   0348   16....         MOVW      HL,#LWRD(LDBDouControl)
   \   034B   A4..           MOV       E,#BYTE3(LDBDouControl)
   \   034D   ..             CALLT     [__T_?FAR_CALL_L07]
   2132                          mDATControl(EepromReprogramming, Start); // no return
   \   034E   A10F           MOV       A,#15
   \   0350   16....         MOVW      HL,#LWRD(LDBDouControl)
   \   0353   A4..           MOV       E,#BYTE3(LDBDouControl)
   \   0355   ..             CALLT     [__T_?FAR_CALL_L07]
   \   0356   9B....         BR        N:??TreatEepromTest_Static_140
   2133                      }
   2134                  }
   2135                  else if ( (LAPKwpReadDiagnosticRequest(cByte2) == 0x01) // Request status
   2136                         &&( mDATRead(U8Bit,DATKwpRxFrameLgth,Default) == cSRBLID_StatusReq_Lgth) )
   \                     ??TreatEepromTest_Static_156:
   \   0359   51             DEC       A
   \   035A   AD03           BZ        $+5
   \   035C   9B....         BR        N:??TreatEepromTest_Static_126
   \   035F   8E....         MOV       A,DATKwpRxFrameLgth
   \   0362   4D03           CMP       A,#3
   \   0364   AD03           BZ        $+5
   \   0366   9B....         BR        N:??TreatEepromTest_Static_126
   \                     ??TreatEepromTest_Static_148:
   \   0369   A100           MOV       A,#0
   \   036B   9B....         BR        N:??TreatEepromTest_Static_135
   2137                  {
   2138                      LAPKwpWriteDiagnosticResponse(cByte2,cRoutineNotActivated);
   2139                  }
   2140                  else
   2141                  {
   2142                      u8AnswerStatus = cLAPKwpInvalidFormat;
   2143                  }
   2144                  break;
   2145              
   2146              case cSRBID_ClearFaultsAndCounters:
   2147                  if ( (LAPKwpReadDiagnosticRequest(cByte2) == 0x00) // Launch the routine
   2148                      &&(mDATRead(U8Bit,DATKwpRxFrameLgth,Default) == cSRBID_ClearFaultsAndCountersLgth))
   \                     ??TreatEepromTest_Static_119:
   \   036E   8E....         MOV       A,DATKwpRxBuffer+5
   \   0371   4D00           CMP       A,#0
   \   0373   AD03           BZ        $+5
   \   0375   9B....         BR        N:??TreatEepromTest_Static_126
   \   0378   8E....         MOV       A,DATKwpRxFrameLgth
   \   037B   4D03           CMP       A,#3
   \   037D   AD03           BZ        $+5
   \   037F   9B....         BR        N:??TreatEepromTest_Static_126
   2149                  {
   2150                      // Clear fault flags and counters using CDI service by Diagnostics
   2151                      TOSSendControl(cTOSControlClearFaultFlagsAndCounters);
   \   0382   A120           MOV       A,#32
   \   0384   ..             CALLT     [__T_TOSSendControl]
   2152          
   2153                      // Reset additional counters
   2154                      mDATWrite(U16Bit,   EEP_CDLeftInd,     0, Default); //CDLI
   \   0385   02....         MOVW      AX,DATDbkMirrors+8
   \   0388   6168           OR        A,X
   \   038A   AD09           BZ        ??TreatEepromTest_Static_157
   \   038C   100000         MOVW      AX,#0
   \   038F   03....         MOVW      DATDbkMirrors+8,AX
   \   0392   9A....         CALL      DATDbkStartUpdate
   2155                      mDATWrite(U16Bit,   EEP_CDRightInd,    0, Default); //CDRI
   \                     ??TreatEepromTest_Static_157:
   \   0395   02....         MOVW      AX,DATDbkMirrors+10
   \   0398   6168           OR        A,X
   \   039A   AD09           BZ        ??TreatEepromTest_Static_158
   \   039C   100000         MOVW      AX,#0
   \   039F   03....         MOVW      DATDbkMirrors+10,AX
   \   03A2   9A....         CALL      DATDbkStartUpdate
   2156                      mDATWrite(U16Bit,   EEP_CDRearWiper,   0, Default); //CDRRW
   \                     ??TreatEepromTest_Static_158:
   \   03A5   02....         MOVW      AX,DATDbkMirrors+12
   \   03A8   6168           OR        A,X
   \   03AA   AD09           BZ        ??TreatEepromTest_Static_159
   \   03AC   100000         MOVW      AX,#0
   \   03AF   03....         MOVW      DATDbkMirrors+12,AX
   \   03B2   9A....         CALL      DATDbkStartUpdate
   2157                      mDATWrite(U8Bit,    EEP_CDDoorLockLed, 0, Default); //CDDLED
   \                     ??TreatEepromTest_Static_159:
   \   03B5   8E....         MOV       A,DATDbkMirrors+7
   \   03B8   4D00           CMP       A,#0
   \   03BA   AD09           BZ        ??TreatEepromTest_Static_160
   \   03BC   A100           MOV       A,#0
   \   03BE   16....         MOVW      HL,#DATDbkMirrors+7
   \   03C1   97             MOV       [HL],A
   \   03C2   9A....         CALL      DATDbkStartUpdate
   2158                      mDATWrite(U8Bit,    EEP_CDVerlogLed,   0, Default); //CDVLED
   \                     ??TreatEepromTest_Static_160:
   \   03C5   8E....         MOV       A,DATDbkMirrors+16
   \   03C8   4D00           CMP       A,#0
   \   03CA   AD09           BZ        ??TreatEepromTest_Static_161
   \   03CC   A100           MOV       A,#0
   \   03CE   16....         MOVW      HL,#DATDbkMirrors+16
   \   03D1   97             MOV       [HL],A
   \   03D2   9A....         CALL      DATDbkStartUpdate
   2159                      mDATWrite(U8Bit,    EEP_CDVerlog,      0, Default); //CDVER
   \                     ??TreatEepromTest_Static_161:
   \   03D5   8E....         MOV       A,DATDbkMirrors+17
   \   03D8   4D00           CMP       A,#0
   \   03DA   AD09           BZ        ??TreatEepromTest_Static_162
   \   03DC   A100           MOV       A,#0
   \   03DE   16....         MOVW      HL,#DATDbkMirrors+17
   \   03E1   97             MOV       [HL],A
   \   03E2   9A....         CALL      DATDbkStartUpdate
   2160                      mDATWrite(U8Bit,    EEP_CDImmo,        0, Default); //CDIMMO 
   \                     ??TreatEepromTest_Static_162:
   \   03E5   8E....         MOV       A,DATDbkMirrors+18
   \   03E8   4D00           CMP       A,#0
   \   03EA   AD09           BZ        ??TreatEepromTest_Static_151
   \   03EC   A100           MOV       A,#0
   \   03EE   16....         MOVW      HL,#DATDbkMirrors+18
   \   03F1   97             MOV       [HL],A
   \   03F2   9A....         CALL      DATDbkStartUpdate
   2161          
   2162                      LAPKwpWriteDiagnosticResponse(cByte2,cRoutineTerminatedOK);           
   \                     ??TreatEepromTest_Static_151:
   \   03F5   A120           MOV       A,#32
   \                     ??TreatEepromTest_Static_135:
   \   03F7   16....         MOVW      HL,#DATKwpTxBuffer+5
   \                     ??TreatEepromTest_Static_130:
   \   03FA   97             MOV       [HL],A
   2163                  }
   2164                  else
   2165                  {
   2166                      u8AnswerStatus = cLAPKwpInvalidFormat;
   2167                  }
   2168                  break;
   2169          
   2170              default:
   2171                  u8AnswerStatus = cLAPKwpInvalidFormat;
   2172                  break;
   2173              }
   2174          
   2175          
   2176              if(LAPKwpIsServiceTreated() == cFalse)
   \                     ??TreatEepromTest_Static_140:
   \   03FB   8E....         MOV       A,u8LAPKwpRequestStatus
   \   03FE   4D02           CMP       A,#2
   \   0400   AD20           BZ        ??TreatEepromTest_Static_133
   2177              {
   2178                  if (u8AnswerStatus == cLAPKwpServiceIsCorrect)
   \   0402   891C           MOVW      AX,SP
   \   0404   D6             MOVW      HL,AX
   \   0405   87             MOV       A,[HL]
   \   0406   4D00           CMP       A,#0
   \   0408   BD10           BNZ       ??TreatEepromTest_Static_163
   2179                  {
   2180                      LAPKwpWriteDiagnosticResponse(1,LAPKwpReadDiagnosticRequest(1));
   \                     ??TreatEepromTest_Static_132:
   \   040A   8E....         MOV       A,DATKwpRxBuffer+4
   \   040D   9E....         MOV       DATKwpTxBuffer+4,A
   2181          
   2182                      LAPKwpPreparePositiveResponse(u8LenghtAnswer);
   \   0410   891C           MOVW      AX,SP
   \   0412   D6             MOVW      HL,AX
   \   0413   AE01           MOV       A,[HL+0x01]
   \   0415   9A....         CALL      LAPKwpPreparePositiveResponse
   \   0418   FA03           BR        ??TreatEepromTest_Static_164
   2183                  }
   2184                  else
   2185                  { // negative response
   2186                      LAPKwpPrepareNegativeResponse(u8AnswerStatus);
   \                     ??TreatEepromTest_Static_163:
   \   041A   9A....         CALL      LAPKwpPrepareNegativeResponse
   2187                  }
   2188                  LAPKwpSetServiceIsFinished();
   \                     ??TreatEepromTest_Static_164:
   \   041D   A103           MOV       A,#3
   \                     ??TreatEepromTest_Static_129:
   \   041F   9E....         MOV       u8LAPKwpRequestStatus,A
   2189              }
   2190          
   2191          }
   \                     ??TreatEepromTest_Static_133:
   \   0422   B0             POP       AX
   \   0423   B2             POP       BC
   \   0424   AF             RET       
   \   0425                  REQUIRE ?CL78K_V4_6_L00
   2192          
   2193          //==============================================================================
   2194          // DESCRIPTION:         LAPTfcInitSession
   2195          //
   2196          // PARAMETERS:          none
   2197          //
   2198          // RETURN VALUE:        none
   2199          //
   2200          // DESIGN INFORMATION:  refer to Detailed Design Document
   2201          //==============================================================================

   \                                 In  segment BCODE, align 1, keep-with-next
   2202          MEM_TYPE void LAPTfcInitSession(void)
   \                     LAPTfcInitSession:
   2203          {
   \   0000                  ; * Stack frame (at entry) *
   \   0000                  ; Param size: 0
   \   0000                  ; Total Auto size: 0
   2204              U8 u8Index;
   2205              for (u8Index=0; u8Index < cRoutineControlNumber;u8Index++)
   \   0000   16....         MOVW      HL,#RoutineRequestInProgress
   \   0003   A007           MOV       X,#7
   2206              {
   2207                  RoutineRequestInProgress[u8Index] = cRoutineNotActivated;
   \                     ??LAPTfcInitSession_0:
   \   0005   A100           MOV       A,#0
   \   0007   97             MOV       [HL],A
   2208              }
   \   0008   86             INCW      HL
   \   0009   50             DEC       X
   \   000A   BDF9           BNZ       ??LAPTfcInitSession_0
   2209          
   2210              mDATWrite(U1Bit, PWM_ROOMLAMPDiagMask, (U1)1U,  Default);
   \   000C   A11F           MOV       A,#31
   \   000E   16....         MOVW      HL,#u8DATPwmDiagMask
   \   0011   7182           SET1      [HL].0
   2211          
   2212              TOSSendControl(cTOSControlActivateFinalTest);
   \   0013   ..             CALLT     [__T_TOSSendControl]
   2213          }
   \   0014   AF             RET       
   \   0015                  REQUIRE ?CL78K_V4_6_L00
   2214          //==============================================================================
   2215          // DESCRIPTION:         LAPTfcCloseSession
   2216          //
   2217          // PARAMETERS:          none
   2218          //
   2219          // RETURN VALUE:        none
   2220          //
   2221          // DESIGN INFORMATION:  refer to Detailed Design Document
   2222          //==============================================================================

   \                                 In  segment BCODE, align 1, keep-with-next
   2223          MEM_TYPE void LAPTfcCloseSession(void)
   \                     LAPTfcCloseSession:
   2224          {
   \   0000                  ; * Stack frame (at entry) *
   \   0000                  ; Param size: 0
   \   0000                  ; Total Auto size: 0
   2225              tTOSSeqGraphStateType  GraphStateL;
   2226          
   2227              if( LAPKwpReadDiagnosticRequest(0) == cLAPKwpIdStopCommunication)
   \   0000   8E....         MOV       A,DATKwpRxBuffer+3
   \   0003   4D82           CMP       A,#130
   \   0005   BD0F           BNZ       ??TreatEepromTest_Static_165
   2228              {
   2229                  GraphStateL = TOSSeqGraphState(cTOSSeqLAPTfcGraph);
   2230          
   2231                  // start a delay before the reset, in order to send a response first
   2232                  if(GraphStateL == cTOSSeqInactiveGraph)
   \   0007   A107           MOV       A,#7
   \   0009   ..             CALLT     [__T_TOSSeqGraphState]
   \   000A   4D00           CMP       A,#0
   \   000C   BD0B           BNZ       ??TreatEepromTest_Static_166
   2233                  {
   2234                      TOSStartTimer(&SleepTimer);
   \   000E   10....         MOVW      AX,#SleepTimer
   \   0011   ..             CALLT     [__T_TOSStartTimer]
   2235                      TOSSeqActivateGraph(cTOSSeqLAPTfcGraph);
   \   0012   A107           MOV       A,#7
   \   0014   ..             CALLT     [__T_TOSSeqActivateGraph]
   \   0015   AF             RET       
   2236                  }
   2237                  
   2238              }
   2239              else // expired session
   2240              {
   2241                  // Reset the BCM after a TFC diag session expired
   2242                  mDATControl(Cpu, Reset);
   \                     ??TreatEepromTest_Static_165:
   \   0016   9A....         CALL      LDBReset
   2243              }
   2244              
   2245          }
   \                     ??TreatEepromTest_Static_166:
   \   0019   AF             RET       
   \   001A                  REQUIRE ?CL78K_V4_6_L00
   2246          
   2247          //==============================================================================
   2248          // DESCRIPTION:         IsAutoTestTimeOutElapsed
   2249          //
   2250          // PARAMETERS:          none
   2251          //
   2252          // RETURN VALUE:        BOOL
   2253          //
   2254          // DESIGN INFORMATION:  refer to Detailed Design Document
   2255          //==============================================================================

   \                                 In  segment CODE, align 1, keep-with-next
   2256          BOOL IsAutoTestTimeOutElapsed(void)
   \                     IsAutoTestTimeOutElapsed:
   2257          {
   \   0000                  ; * Stack frame (at entry) *
   \   0000                  ; Param size: 0
   \   0000   B3             PUSH      BC
   \   0001                  ; Total Auto size: 0
   2258              return (BOOL)TOSIsTimerElapsed(&AutoTestTimer, AutoTestTimeOutValueInTick);
   \   0001   02....         MOVW      AX,AutoTestTimeOutValueInTick
   \   0004   D2             MOVW      BC,AX
   \   0005   10....         MOVW      AX,#AutoTestTimer
   \   0008   ..             CALLT     [__T_TOSIsTimerElapsed]
   \   0009   B2             POP       BC
   \   000A   AF             RET       
   \   000B                  REQUIRE ?CL78K_V4_6_L00
   2259          }
   2260          
   2261          //==============================================================================
   2262          // DESCRIPTION:         StartAutoTestTOR
   2263          //
   2264          // PARAMETERS:          none
   2265          //
   2266          // RETURN VALUE:        U8 u8RequestStatus
   2267          //
   2268          // DESIGN INFORMATION:  refer to Detailed Design Document
   2269          //==============================================================================

   \                                 In  segment BCODE, align 1, keep-with-next
   2270          static MEM_TYPE U8 StartAutoTestTOR(void)
   \                     StartAutoTestTOR:
   2271          {
   \   0000                  ; * Stack frame (at entry) *
   \   0000                  ; Param size: 0
   \   0000   B3             PUSH      BC
   \   0001                  ; Total Auto size: 2
   \   0001   B7             PUSH      HL
   2272              U8 u8AnswerStatusL;
   2273              U8 u8ExpectedFrameLgth;
   2274              U8 u8IndexL;
   2275          
   2276              u8AnswerStatusL = cLAPKwpServiceIsCorrect;
   \   0002   891C           MOVW      AX,SP
   \   0004   D6             MOVW      HL,AX
   \   0005   A100           MOV       A,#0
   \   0007   97             MOV       [HL],A
   2277          
   2278              u8ExpectedFrameLgth = cSRBID_AutoTestTORReqStatic_Lgth + LAPKwpReadDiagnosticRequest(cOrderingMatrixSizeBytePos);
   2279           
   2280              // prsFS-561; check frame
   2281              //QACJ 3416: akodzhh: There is no side effect; first check request length correctness,then matrix
   2282              //QACJ 3415: akodzhh: There is no side effect; first check request length correctness,then matrix
   2283              if( (mDATRead(U8Bit,DATKwpRxFrameLgth,Default) == u8ExpectedFrameLgth )
   2284                &&( LAPKwpReadDiagnosticRequest(cOrderingMatrixSizeBytePos) > 0 )
   2285                &&( LAPKwpReadDiagnosticRequest(cOrderingMatrixSizeBytePos) <= cOrderingMatrixMaxSize )
   2286                &&((LAPKwpReadDiagnosticRequest(cOrderingMatrixSizeBytePos)&1 ) == 0 )  // even number  
   2287                &&( LAPKwpReadDiagnosticRequest(cSequenceModeBytePos) <= cModeContinueOnErrorTx)
   2288                &&( IsOrderingMatrixDataValid() == cTrue) )
   \   0008   8E....         MOV       A,DATKwpRxBuffer+11
   \   000B   70             MOV       X,A
   \   000C   0D09           ADD       A,#9
   \   000E   48....         CMP       A,DATKwpRxFrameLgth
   \   0011   AD03           BZ        $+5
   \   0013   9B....         BR        N:??TreatEepromTest_Static_167
   \   0016   60             MOV       A,X
   \   0017   4D00           CMP       A,#0
   \   0019   BD03           BNZ       $+5
   \   001B   9B....         BR        N:??TreatEepromTest_Static_167
   \   001E   4D31           CMP       A,#49
   \   0020   8D03           BC        $+5
   \   0022   9B....         BR        N:??TreatEepromTest_Static_167
   \   0025   16....         MOVW      HL,#DATKwpRxBuffer+11
   \   0028   318703         BF        [HL].0, $+6
   \   002B   9B....         BR        N:??TreatEepromTest_Static_167
   \   002E   8E....         MOV       A,DATKwpRxBuffer+5
   \   0031   4D04           CMP       A,#4
   \   0033   8D03           BC        $+5
   \   0035   9B....         BR        N:??TreatEepromTest_Static_167
   \   0038   A201           MOV       C,#1
   \   003A   A300           MOV       B,#0
   \   003C   FA25           BR        ??TreatEepromTest_Static_168
   \                     ??StartAutoTestTOR_0:
   \   003E   16....         MOVW      HL,#DATKwpRxBuffer+12
   \   0041   AB             MOV       A,[HL+B]
   \   0042   24             ROR       A,0x1
   \   0043   25             RORC      A,0x1
   \   0044   25             RORC      A,0x1
   \   0045   25             RORC      A,0x1
   \   0046   5D0F           AND       A,#15
   \   0048   4D04           CMP       A,#4
   \   004A   9D0C           BNC       ??TreatEepromTest_Static_169
   \   004C   86             INCW      HL
   \   004D   AB             MOV       A,[HL+B]
   \   004E   24             ROR       A,0x1
   \   004F   25             RORC      A,0x1
   \   0050   25             RORC      A,0x1
   \   0051   25             RORC      A,0x1
   \   0052   5D0F           AND       A,#15
   \   0054   4D06           CMP       A,#6
   \   0056   8D02           BC        ??TreatEepromTest_Static_170
   \                     ??TreatEepromTest_Static_169:
   \   0058   A200           MOV       C,#0
   \                     ??TreatEepromTest_Static_170:
   \   005A   63             MOV       A,B
   \   005B   0D02           ADD       A,#2
   \   005D   73             MOV       B,A
   \   005E   62             MOV       A,C
   \   005F   4D00           CMP       A,#0
   \   0061   AD77           BZ        ??TreatEepromTest_Static_167
   \                     ??TreatEepromTest_Static_168:
   \   0063   63             MOV       A,B
   \   0064   6148           CMP       A,X
   \   0066   8DD6           BC        ??StartAutoTestTOR_0
   \   0068   62             MOV       A,C
   \   0069   51             DEC       A
   \   006A   BD6E           BNZ       ??TreatEepromTest_Static_167
   2289              {
   2290                  if( RoutineRequestInProgress[cRoutineIndexAutoTestTOR] != cRoutineInProgress)
   \   006C   8E....         MOV       A,RoutineRequestInProgress+2
   \   006F   4D10           CMP       A,#16
   \   0071   AD60           BZ        ??TreatEepromTest_Static_171
   2291                  {
   2292                      u8SequenceMode           = LAPKwpReadDiagnosticRequest(cSequenceModeBytePos);    
   \   0073   8E....         MOV       A,DATKwpRxBuffer+5
   \   0076   9E....         MOV       u8SequenceMode,A
   2293                      u8AutoTestSetupTimeOut   = LAPKwpReadDiagnosticRequest(cSetupTimeBytePos);
   \   0079   8E....         MOV       A,DATKwpRxBuffer+7
   \   007C   9E....         MOV       u8AutoTestSetupTimeOut,A
   2294                      u8AutoTestActivTimeOut   = LAPKwpReadDiagnosticRequest(cActivationTimeOutBytePos);
   \   007F   8E....         MOV       A,DATKwpRxBuffer+8
   \   0082   9E....         MOV       u8AutoTestActivTimeOut,A
   2295                      u8AutoTestSynchroTimeOutIn10msUnit = LAPKwpReadDiagnosticRequest(cSynchronizationTimeOutBytePos);
   \   0085   8E....         MOV       A,DATKwpRxBuffer+10
   \   0088   9E....         MOV       u8AutoTestSynchroTimeOutIn10msUnit,A
   2296                      u8OrderingMatrixSize     = LAPKwpReadDiagnosticRequest(cOrderingMatrixSizeBytePos);
   \   008B   60             MOV       A,X
   \   008C   9E....         MOV       u8OrderingMatrixSize,A
   2297          
   2298                      for( u8IndexL = 0; u8IndexL < LAPKwpReadDiagnosticRequest(cOrderingMatrixSizeBytePos); u8IndexL++)
   \   008F   16....         MOVW      HL,#u8OrderingMatrix
   \   0092   14....         MOVW      DE,#DATKwpRxBuffer+12
   2299                      {
   2300                          u8OrderingMatrix[u8IndexL]   = LAPKwpReadDiagnosticRequest(cOrderingMatrixBytePos+u8IndexL);
   \                     ??StartAutoTestTOR_1:
   \   0095   85             MOV       A,[DE]
   \   0096   97             MOV       [HL],A
   2301                      }
   \   0097   84             INCW      DE
   \   0098   86             INCW      HL
   \   0099   50             DEC       X
   \   009A   BDF9           BNZ       ??StartAutoTestTOR_1
   2302           
   2303                      // Init and start AutoTestTor procedure
   2304                      u8OrderingMatrixCounter = 0;
   \   009C   A100           MOV       A,#0
   \   009E   9E....         MOV       u8OrderingMatrixCounter,A
   2305                      u16ErrorsOnOutput = 0;
   \   00A1   70             MOV       X,A
   \   00A2   03....         MOVW      u16ErrorsOnOutput,AX
   2306                      u32ErrorsOnInput  = 0;
   \   00A5   03....         MOVW      u32ErrorsOnInput+2,AX
   \   00A8   03....         MOVW      u32ErrorsOnInput,AX
   2307          
   2308                      AutoTestTimeOutValueInTick = 
   2309                          mTOSConvMsInTimerTick((U32)( LAPKwpReadDiagnosticRequest(cStartDelayIn10msBytePos) * c10MsPerUnit ));
   \   00AB   B1             PUSH      AX
   \   00AC   A00A           MOV       X,#10
   \   00AE   B1             PUSH      AX
   \   00AF   8E....         MOV       A,DATKwpRxBuffer+6
   \   00B2   3188           MULU      X
   \   00B4   120000         MOVW      BC,#0
   \   00B7   317F01         BF        A.7, ??TreatEepromTest_Static_172
   \   00BA   92             DECW      BC
   \                     ??TreatEepromTest_Static_172:
   \   00BB   ..             CALLT     [__T_?UL_DIV_L03]
   \   00BC   03....         MOVW      AutoTestTimeOutValueInTick,AX
   2310                      if(AutoTestTimeOutValueInTick > 0)
   \   00BF   6168           OR        A,X
   \   00C1   AD07           BZ        ??TreatEepromTest_Static_173
   2311                      {   
   2312                          // -1 tick because of Cm005756:TOS Timers introduce an additional delay of 1 graph/task cycle
   2313                          AutoTestTimeOutValueInTick--;
   \   00C3   8E....         MOV       A,AutoTestTimeOutValueInTick+1
   \   00C6   90             DECW      AX
   \   00C7   03....         MOVW      AutoTestTimeOutValueInTick,AX
   2314                      }
   2315                                   
   2316                      TOSStartTimer(&AutoTestTimer);
   \                     ??TreatEepromTest_Static_173:
   \   00CA   10....         MOVW      AX,#AutoTestTimer
   \   00CD   ..             CALLT     [__T_TOSStartTimer]
   2317                      TOSSeqActivateGraph(cTOSSeqLAPTfcAutoTestIO);
   \   00CE   A106           MOV       A,#6
   \   00D0   ..             CALLT     [__T_TOSSeqActivateGraph]
   \   00D1   FA0D           BR        ??TreatEepromTest_Static_174
   2318          
   2319                  }
   2320                  else  // Routine In Progress
   2321                  {   
   2322                      u8AnswerStatusL = cLAPKwpConditionNotCorrect;   
   \                     ??TreatEepromTest_Static_171:
   \   00D3   891C           MOVW      AX,SP
   \   00D5   D6             MOVW      HL,AX
   \   00D6   A122           MOV       A,#34
   \   00D8   FA05           BR        ??TreatEepromTest_Static_175
   2323                  }
   2324              }
   2325              else
   2326              {
   2327                  u8AnswerStatusL = cLAPKwpInvalidFormat;
   \                     ??TreatEepromTest_Static_167:
   \   00DA   891C           MOVW      AX,SP
   \   00DC   D6             MOVW      HL,AX
   \   00DD   A112           MOV       A,#18
   \                     ??TreatEepromTest_Static_175:
   \   00DF   97             MOV       [HL],A
   2328              }
   2329          
   2330              return(u8AnswerStatusL);
   \                     ??TreatEepromTest_Static_174:
   \   00E0   891C           MOVW      AX,SP
   \   00E2   D6             MOVW      HL,AX
   \   00E3   87             MOV       A,[HL]
   \   00E4   B2             POP       BC
   \   00E5   B2             POP       BC
   \   00E6   AF             RET       
   \   00E7                  REQUIRE ?CL78K_V4_6_L00
   2331          
   2332          }
   2333          
   2334          //==============================================================================
   2335          // DESCRIPTION:         StopAutoTestTOR
   2336          //
   2337          // PARAMETERS:          none
   2338          //
   2339          // RETURN VALUE:        none
   2340          //
   2341          // DESIGN INFORMATION:  refer to Detailed Design Document
   2342          //==============================================================================
   2343          static MEM_TYPE void StopAutoTestTOR(void)
   2344          {
   2345              tTOSSeqGraphStateType  GraphStateL;
   2346          
   2347              GraphStateL = TOSSeqGraphState(cTOSSeqLAPTfcAutoTestIO);
   2348              //CCOV: akodzhh: can't be covered, StopAutoTestTOR is called when routine is in progress.
   2349              if( GraphStateL == cTOSSeqActiveGraph)
   2350              {
   2351                  TOSSeqDeactivateGraph(cTOSSeqLAPTfcAutoTestIO);
   2352                  if(bOutputsActivated == cTrue)
   2353                  {
   2354                      DeactivateOutputs(cFalse);
   2355                  }
   2356              }
   2357          }
   2358          
   2359          //==============================================================================
   2360          // DESCRIPTION:         StartSetupTimeOut
   2361          //
   2362          // PARAMETERS:          none
   2363          //
   2364          // RETURN VALUE:        none
   2365          //
   2366          // DESIGN INFORMATION:  refer to Detailed Design Document
   2367          //==============================================================================

   \                                 In  segment CODE, align 1, keep-with-next
   2368          void StartSetupTimeOut(void)
   \                     StartSetupTimeOut:
   2369          {
   \   0000                  ; * Stack frame (at entry) *
   \   0000                  ; Param size: 0
   \   0000   B3             PUSH      BC
   \   0001                  ; Total Auto size: 0
   2370              AutoTestTimeOutValueInTick = mTOSConvMsInTimerTick((U32)u8AutoTestSetupTimeOut);
   \   0001   8E....         MOV       A,u8AutoTestSetupTimeOut
   \   0004   A20A           MOV       C,#10
   \   0006   70             MOV       X,A
   \   0007   A100           MOV       A,#0
   \   0009   3182           DIVUW     C
   \   000B   A100           MOV       A,#0
   \   000D   03....         MOVW      AutoTestTimeOutValueInTick,AX
   2371              if(AutoTestTimeOutValueInTick > 0)
   \   0010   6168           OR        A,X
   \   0012   AD07           BZ        ??TreatEepromTest_Static_185
   2372              {
   2373                  // -1 tick because of Cm005756:TOS Timers introduce an additional delay of 1 graph/task cycle
   2374                  AutoTestTimeOutValueInTick--;
   \   0014   8E....         MOV       A,AutoTestTimeOutValueInTick+1
   \   0017   90             DECW      AX
   \   0018   03....         MOVW      AutoTestTimeOutValueInTick,AX
   2375              }
   2376          
   2377              TOSStartTimer(&AutoTestTimer);
   \                     ??TreatEepromTest_Static_185:
   \   001B   10....         MOVW      AX,#AutoTestTimer
   \   001E   ..             CALLT     [__T_TOSStartTimer]
   2378          }
   \   001F   B2             POP       BC
   \   0020   AF             RET       
   \   0021                  REQUIRE ?CL78K_V4_6_L00
   2379          
   2380              
   2381          //==============================================================================
   2382          // DESCRIPTION:         StartSynchronizationTimeout
   2383          //
   2384          // PARAMETERS:          none
   2385          //
   2386          // RETURN VALUE:        none
   2387          //
   2388          // DESIGN INFORMATION:  refer to Detailed Design Document
   2389          //==============================================================================

   \                                 In  segment CODE, align 1, keep-with-next
   2390          void StartSynchronizationTimeout(void)
   \                     StartSynchronizationTimeout:
   2391          {
   \   0000                  ; * Stack frame (at entry) *
   \   0000                  ; Param size: 0
   \   0000   100000         MOVW      AX,#0
   \   0003   B3             PUSH      BC
   \   0004                  ; Total Auto size: 0
   2392              AutoTestTimeOutValueInTick = 
   2393                  mTOSConvMsInTimerTick((U32)(u8AutoTestSynchroTimeOutIn10msUnit * c10MsPerUnit));
   \   0004   B1             PUSH      AX
   \   0005   A00A           MOV       X,#10
   \   0007   B1             PUSH      AX
   \   0008   8E....         MOV       A,u8AutoTestSynchroTimeOutIn10msUnit
   \   000B   3188           MULU      X
   \   000D   120000         MOVW      BC,#0
   \   0010   317F01         BF        A.7, ??TreatEepromTest_Static_186
   \   0013   92             DECW      BC
   \                     ??TreatEepromTest_Static_186:
   \   0014   ..             CALLT     [__T_?UL_DIV_L03]
   \   0015   03....         MOVW      AutoTestTimeOutValueInTick,AX
   2394          
   2395              if(AutoTestTimeOutValueInTick > 0)
   \   0018   6168           OR        A,X
   \   001A   AD07           BZ        ??TreatEepromTest_Static_187
   2396              {
   2397                  // -1 tick because of Cm005756:TOS Timers introduce an additional delay of 1 graph/task cycle
   2398                  AutoTestTimeOutValueInTick--;
   \   001C   8E....         MOV       A,AutoTestTimeOutValueInTick+1
   \   001F   90             DECW      AX
   \   0020   03....         MOVW      AutoTestTimeOutValueInTick,AX
   2399              }                                
   2400              
   2401              TOSStartTimer(&AutoTestTimer);
   \                     ??TreatEepromTest_Static_187:
   \   0023   10....         MOVW      AX,#AutoTestTimer
   \   0026   ..             CALLT     [__T_TOSStartTimer]
   2402          
   2403          
   2404          }
   \   0027   B2             POP       BC
   \   0028   AF             RET       
   \   0029                  REQUIRE ?CL78K_V4_6_L00
   2405          
   2406          //==============================================================================
   2407          // DESCRIPTION:         IsTimeoutElapsedOrInputsSet
   2408          //
   2409          // PARAMETERS:          none
   2410          //
   2411          // RETURN VALUE:        BOOL
   2412          //
   2413          // DESIGN INFORMATION:  refer to Detailed Design Document
   2414          //==============================================================================

   \                                 In  segment CODE, align 1, keep-with-next
   2415          BOOL IsTimeoutElapsedOrInputsAreSet(void)
   \                     IsTimeoutElapsedOrInputsAreSet:
   2416          {
   \   0000                  ; * Stack frame (at entry) *
   \   0000                  ; Param size: 0
   \   0000   B3             PUSH      BC
   \   0001   B5             PUSH      DE
   \   0002                  ; Total Auto size: 0
   2417              BOOL bIsSynchroTimeoutElapsed;
   2418              BOOL bAllExpectedInputsAreSet;
   2419          
   2420              // read inputs and input errors
   2421              bAllExpectedInputsAreSet = ReadInputsAndSetResult();
   \   0002   16....         MOVW      HL,#LWRD(ReadInputsAndSetResult)
   \   0005   A4..           MOV       E,#BYTE3(ReadInputsAndSetResult)
   \   0007   ..             CALLT     [__T_?FAR_CALL_L07]
   \   0008   74             MOV       E,A
   2422              bIsSynchroTimeoutElapsed = TOSIsTimerElapsed(&AutoTestTimer, AutoTestTimeOutValueInTick);
   \   0009   02....         MOVW      AX,AutoTestTimeOutValueInTick
   \   000C   D2             MOVW      BC,AX
   \   000D   10....         MOVW      AX,#AutoTestTimer
   \   0010   ..             CALLT     [__T_TOSIsTimerElapsed]
   \   0011   70             MOV       X,A
   2423          
   2424              return ( bAllExpectedInputsAreSet || bIsSynchroTimeoutElapsed );
   \   0012   64             MOV       A,E
   \   0013   4D00           CMP       A,#0
   \   0015   BD05           BNZ       ??TreatEepromTest_Static_188
   \   0017   60             MOV       A,X
   \   0018   4D00           CMP       A,#0
   \   001A   AD04           BZ        ??TreatEepromTest_Static_189
   \                     ??TreatEepromTest_Static_188:
   \   001C   A101           MOV       A,#1
   \   001E   FA02           BR        ??TreatEepromTest_Static_190
   \                     ??TreatEepromTest_Static_189:
   \   0020   A100           MOV       A,#0
   \                     ??TreatEepromTest_Static_190:
   \   0022   B4             POP       DE
   \   0023   B2             POP       BC
   \   0024   AF             RET       
   \   0025                  REQUIRE ?CL78K_V4_6_L00
   2425          }
   2426          
   2427          //==============================================================================
   2428          // DESCRIPTION:         FinishSequence
   2429          //
   2430          // PARAMETERS:          none
   2431          //
   2432          // RETURN VALUE:        none
   2433          //
   2434          // DESIGN INFORMATION:  refer to Detailed Design Document
   2435          //==============================================================================

   \                                 In  segment CODE, align 1, keep-with-next
   2436          void FinishSequence(void)
   \                     FinishSequence:
   2437          {
   \   0000                  ; * Stack frame (at entry) *
   \   0000                  ; Param size: 0
   \   0000   A101           MOV       A,#1
   \   0002   B5             PUSH      DE
   \   0003                  ; Total Auto size: 0
   2438              DeactivateOutputs(cTrue);    
   \   0003   16....         MOVW      HL,#LWRD(DeactivateOutputs)
   \   0006   A4..           MOV       E,#BYTE3(DeactivateOutputs)
   \   0008   ..             CALLT     [__T_?FAR_CALL_L07]
   2439              
   2440              u8OrderingMatrixCounter += cMatrixPairLng;
   \   0009   8E....         MOV       A,u8OrderingMatrixCounter
   \   000C   0D02           ADD       A,#2
   \   000E   9E....         MOV       u8OrderingMatrixCounter,A
   2441          }
   \   0011   B4             POP       DE
   \   0012   AF             RET       
   \   0013                  REQUIRE ?CL78K_V4_6_L00
   2442          
   2443          
   2444          //==============================================================================
   2445          // DESCRIPTION:         IsAutoTestFinished
   2446          //
   2447          // PARAMETERS:          none
   2448          //
   2449          // RETURN VALUE:        none
   2450          //
   2451          // DESIGN INFORMATION:  refer to Detailed Design Document
   2452          //==============================================================================

   \                                 In  segment CODE, align 1, keep-with-next
   2453          BOOL IsAutoTestFinished(void)
   \                     IsAutoTestFinished:
   2454          {
   \   0000                  ; * Stack frame (at entry) *
   \   0000                  ; Param size: 0
   \   0000   B5             PUSH      DE
   \   0001                  ; Total Auto size: 0
   2455          #ifdef X90_PROJECT
   2456              return IsAutoTestFinished_Static();
   \   0001   16....         MOVW      HL,#LWRD(IsAutoTestFinished_Static)
   \   0004   A4..           MOV       E,#BYTE3(IsAutoTestFinished_Static)
   \   0006   ..             CALLT     [__T_?FAR_CALL_L07]
   \   0007   B4             POP       DE
   \   0008   AF             RET       
   \   0009                  REQUIRE ?CL78K_V4_6_L00
   2457          }
   2458          #pragma optimize=no_inline

   \                                 In  segment BCODE, align 1, keep-with-next
   2459          static MEM_TYPE BOOL IsAutoTestFinished_Static(void)
   \                     IsAutoTestFinished_Static:
   2460          {
   \   0000                  ; * Stack frame (at entry) *
   \   0000                  ; Param size: 0
   \   0000   B3             PUSH      BC
   \   0001                  ; Total Auto size: 0
   2461          #endif
   2462              BOOL bStopTestConditions;
   2463              
   2464              if(u8OrderingMatrixCounter >= u8OrderingMatrixSize )
   \   0001   8E....         MOV       A,u8OrderingMatrixCounter
   \   0004   48....         CMP       A,u8OrderingMatrixSize
   \   0007   8D27           BC        ??TreatEepromTest_Static_176
   2465              {
   2466                  mLIBassert(u8OrderingMatrixCounter == u8OrderingMatrixSize);
   2467                  bStopTestConditions = cTrue;
   \   0009   A401           MOV       E,#1
   2468                  if(( u32ErrorsOnInput > (U32)0 ) || ( u16ErrorsOnOutput > (U16)0 ))
   \   000B   02....         MOVW      AX,u32ErrorsOnInput+2
   \   000E   D2             MOVW      BC,AX
   \   000F   02....         MOVW      AX,u32ErrorsOnInput
   \   0012   B5             PUSH      DE
   \   0013   6160           OR        X,A
   \   0015   62             MOV       A,C
   \   0016   6160           OR        X,A
   \   0018   63             MOV       A,B
   \   0019   6160           OR        X,A
   \   001B   B4             POP       DE
   \   001C   BD07           BNZ       ??TreatEepromTest_Static_177
   \   001E   02....         MOVW      AX,u16ErrorsOnOutput
   \   0021   6168           OR        A,X
   \   0023   AD07           BZ        ??TreatEepromTest_Static_178
   2469                  {
   2470                      RoutineRequestInProgress[cRoutineIndexAutoTestTOR] = cRoutineTerminatedNOK;
   \                     ??TreatEepromTest_Static_177:
   \   0025   A140           MOV       A,#64
   \                     ??IsAutoTestFinished_Static_0:
   \   0027   9E....         MOV       RoutineRequestInProgress+2,A
   \   002A   FA2F           BR        ??TreatEepromTest_Static_179
   2471                  }
   2472                  else
   2473                  {
   2474                      RoutineRequestInProgress[cRoutineIndexAutoTestTOR] = cRoutineTerminatedOK;
   \                     ??TreatEepromTest_Static_178:
   \   002C   A120           MOV       A,#32
   \   002E   FAF7           BR        ??IsAutoTestFinished_Static_0
   2475                  }
   2476                  
   2477              }
   2478              else if( (u8SequenceMode == cModeStopOnError  )
   2479                     ||(u8SequenceMode == cModeStopOnErrorTx) )
   \                     ??TreatEepromTest_Static_176:
   \   0030   8E....         MOV       A,u8SequenceMode
   \   0033   4D00           CMP       A,#0
   \   0035   AD04           BZ        ??TreatEepromTest_Static_180
   \   0037   4D02           CMP       A,#2
   \   0039   BD1E           BNZ       ??TreatEepromTest_Static_181
   2480              {
   2481                  bStopTestConditions =  (BOOL)(( u32ErrorsOnInput > (U32)0 ) || ( u16ErrorsOnOutput > (U16)0 ));
   \                     ??TreatEepromTest_Static_180:
   \   003B   02....         MOVW      AX,u32ErrorsOnInput+2
   \   003E   D2             MOVW      BC,AX
   \   003F   02....         MOVW      AX,u32ErrorsOnInput
   \   0042   B5             PUSH      DE
   \   0043   6160           OR        X,A
   \   0045   62             MOV       A,C
   \   0046   6160           OR        X,A
   \   0048   63             MOV       A,B
   \   0049   6160           OR        X,A
   \   004B   B4             POP       DE
   \   004C   BD07           BNZ       ??TreatEepromTest_Static_182
   \   004E   02....         MOVW      AX,u16ErrorsOnOutput
   \   0051   6168           OR        A,X
   \   0053   AD04           BZ        ??TreatEepromTest_Static_181
   \                     ??TreatEepromTest_Static_182:
   \   0055   A401           MOV       E,#1
   \   0057   FACC           BR        ??TreatEepromTest_Static_177
   \                     ??TreatEepromTest_Static_181:
   \   0059   A400           MOV       E,#0
   2482                  if( bStopTestConditions == cTrue)
   2483                  {
   2484                      // finished, errors detected
   2485                      RoutineRequestInProgress[cRoutineIndexAutoTestTOR] = cRoutineTerminatedNOK;
   2486                  }
   2487              }
   2488              else
   2489              {
   2490                  bStopTestConditions = cFalse;
   2491              }
   2492          
   2493              return(bStopTestConditions);
   \                     ??TreatEepromTest_Static_179:
   \   005B   64             MOV       A,E
   \   005C   B2             POP       BC
   \   005D   AF             RET       
   \   005E                  REQUIRE ?CL78K_V4_6_L00
   2494          
   2495          }
   2496          
   2497          
   2498          //==============================================================================
   2499          // DESCRIPTION:         IsSleepTimeoutElapsed
   2500          //
   2501          // PARAMETERS:          none
   2502          //
   2503          // RETURN VALUE:        none
   2504          //
   2505          // DESIGN INFORMATION:  refer to Detailed Design Document
   2506          //==============================================================================

   \                                 In  segment CODE, align 1, keep-with-next
   2507          BOOL IsSleepTimeoutElapsed(void)
   \                     IsSleepTimeoutElapsed:
   2508          {
   \   0000                  ; * Stack frame (at entry) *
   \   0000                  ; Param size: 0
   \   0000   10....         MOVW      AX,#SleepTimer
   \   0003   B3             PUSH      BC
   \   0004                  ; Total Auto size: 0
   2509              return (BOOL)TOSIsTimerElapsed(&SleepTimer, mTOSConvMsInTimerTick(cTimeoutBeforeEnterSleepInMs));
   \   0004   120A00         MOVW      BC,#10
   \   0007   ..             CALLT     [__T_TOSIsTimerElapsed]
   \   0008   B2             POP       BC
   \   0009   AF             RET       
   \   000A                  REQUIRE ?CL78K_V4_6_L00
   2510          }
   2511          //==============================================================================
   2512          // DESCRIPTION:         SleepTimeoutElapsed
   2513          //
   2514          // PARAMETERS:          none
   2515          //
   2516          // RETURN VALUE:        none
   2517          //
   2518          // DESIGN INFORMATION:  refer to Detailed Design Document
   2519          //==============================================================================

   \                                 In  segment CODE, align 1, keep-with-next
   2520          void SleepTimeoutElapsed(void)
   \                     SleepTimeoutElapsed:
   2521          {
   \   0000                  ; * Stack frame (at entry) *
   \   0000                  ; Param size: 0
   \   0000                  ; Total Auto size: 0
   2522              mDATControl(Cpu, Reset);
   \   0000   9B....         BR        N:LDBReset
   \   0003                  REQUIRE ?CL78K_V4_6_L00
   2523          }
   2524          
   2525          
   2526          //==============================================================================
   2527          // DESCRIPTION:         TreatEepromTest
   2528          //
   2529          // PARAMETERS:          none
   2530          //
   2531          // RETURN VALUE:        none 
   2532          //
   2533          // DESIGN INFORMATION:  refer to Detailed Design Document
   2534          //==============================================================================

   \                                 In  segment CODE, align 1, keep-with-next
   2535          void TreatEepromTest(void)
   \                     TreatEepromTest:
   2536          {
   \   0000                  ; * Stack frame (at entry) *
   \   0000                  ; Param size: 0
   \   0000   B5             PUSH      DE
   \   0001                  ; Total Auto size: 0
   2537          #ifdef X90_PROJECT
   2538              TreatEepromTest_Static();
   \   0001   16....         MOVW      HL,#LWRD(TreatEepromTest_Static)
   \   0004   A4..           MOV       E,#BYTE3(TreatEepromTest_Static)
   \   0006   ..             CALLT     [__T_?FAR_CALL_L07]
   2539          }
   \   0007   B4             POP       DE
   \   0008   AF             RET       
   \   0009                  REQUIRE ?CL78K_V4_6_L00
   2540          #pragma optimize=no_inline

   \                                 In  segment BCODE, align 1, keep-with-next
   2541          static MEM_TYPE void TreatEepromTest_Static(void)
   \                     TreatEepromTest_Static:
   2542          {
   \   0000                  ; * Stack frame (at entry) *
   \   0000                  ; Param size: 0
   \   0000   B3             PUSH      BC
   \   0001                  ; Total Auto size: 0
   2543          #endif
   2544              BOOL bReadIsFinished;
   2545              U16  u16CksAddress;
   2546              U8   u8EepBanksListIndex;
   2547          
   2548          
   2549              bReadIsFinished = (BOOL)mDATRead(U8Bit,DATDeaActionIsFinished,Default);
   2550          
   2551              if( bReadIsFinished == cTrue )
   \   0001   8E....         MOV       A,DATDeaActionIsFinished
   \   0004   51             DEC       A
   \   0005   BD60           BNZ       ??TreatEepromTest_Static_183
   2552              {
   2553                  BanksCksTable[u8EepTestCounter].u8BankCksLSB = mDATReadBuffer(DATDeaBufferU8Bit,0, Default);
   \   0007   8E....         MOV       A,DATDeaBufferU8Bit
   \   000A   72             MOV       C,A
   \   000B   8E....         MOV       A,u8EepTestCounter
   \   000E   A003           MOV       X,#3
   \   0010   3188           MULU      X
   \   0012   CA....         ADDW      AX,#BanksCksTable+2
   \   0015   D6             MOVW      HL,AX
   \   0016   62             MOV       A,C
   \   0017   97             MOV       [HL],A
   2554                  BanksCksTable[u8EepTestCounter].u8BankCksMSB = mDATReadBuffer(DATDeaBufferU8Bit,1, Default);
   \   0018   8E....         MOV       A,DATDeaBufferU8Bit+1
   \   001B   72             MOV       C,A
   \   001C   8E....         MOV       A,u8EepTestCounter
   \   001F   A003           MOV       X,#3
   \   0021   3188           MULU      X
   \   0023   CA....         ADDW      AX,#BanksCksTable+1
   \   0026   D6             MOVW      HL,AX
   \   0027   62             MOV       A,C
   \   0028   97             MOV       [HL],A
   2555                  
   2556                  u8EepTestCounter++;
   \   0029   8E....         MOV       A,u8EepTestCounter
   \   002C   41             INC       A
   \   002D   9E....         MOV       u8EepTestCounter,A
   2557                  
   2558                  if( u8EepTestCounter < cNbEepBanks )
   \   0030   4D0A           CMP       A,#10
   \   0032   9D2A           BNC       ??TreatEepromTest_Static_184
   2559                  {
   2560                      // Convert Diag index /u8EepTestCounter/ to Eep bank list index
   2561                      u8EepBanksListIndex = BanksCksTable[u8EepTestCounter].u8BankIndex;
   2562          
   2563                      u16CksAddress = EepBanksList[u8EepBanksListIndex].Offset<<1;
   2564                      // Set read request
   2565                      mDATWrite(U8Bit,  DATDeaSizeBufferInByte, cCksLgth, Default);
   \   0034   A102           MOV       A,#2
   \   0036   9E....         MOV       DATDeaSizeBufferInByte,A
   2566                      mDATWrite(U16Bit, DATDeaAddressInByte, u16CksAddress, Default);
   \   0039   8E....         MOV       A,u8EepTestCounter
   \   003C   A003           MOV       X,#3
   \   003E   3188           MULU      X
   \   0040   CA....         ADDW      AX,#BanksCksTable
   \   0043   D6             MOVW      HL,AX
   \   0044   87             MOV       A,[HL]
   \   0045   A004           MOV       X,#4
   \   0047   3188           MULU      X
   \   0049   CA....         ADDW      AX,#EepBanksList
   \   004C   D6             MOVW      HL,AX
   \   004D   87             MOV       A,[HL]
   \   004E   70             MOV       X,A
   \   004F   AE01           MOV       A,[HL+0x01]
   \   0051   21             CLR1      CY
   \   0052   30             XCH       A,X
   \   0053   27             ROLC      A,0x1
   \   0054   30             XCH       A,X
   \   0055   27             ROLC      A,0x1
   \   0056   03....         MOVW      DATDeaAddressInByte,AX
   2567                      mDATControl(DATDea, StartReadEepromByAddress);
   \   0059   9A....         CALL      DATDeaStartReadEepromByAddress
   \   005C   FA09           BR        ??TreatEepromTest_Static_183
   2568          
   2569          
   2570                  }
   2571                  else    // Test finished
   2572                  {
   2573                      RoutineRequestInProgress[cRoutineIndexEepromTest] = cRoutineTerminatedOK;
   \                     ??TreatEepromTest_Static_184:
   \   005E   A120           MOV       A,#32
   \   0060   16....         MOVW      HL,#RoutineRequestInProgress+6
   \   0063   97             MOV       [HL],A
   2574                      TOSSeqDeactivateGraph(cTOSSeqLAPTfcEepTest);
   \   0064   A108           MOV       A,#8
   \   0066   ..             CALLT     [__T_TOSSeqDeactivateGraph]
   2575          
   2576                  }
   2577                              
   2578              }
   2579                            
   2580          }
   \                     ??TreatEepromTest_Static_183:
   \   0067   B2             POP       BC
   \   0068   AF             RET       
   \   0069                  REQUIRE ?CL78K_V4_6_L00

   \                                 In  segment NEAR_ID, align 1, align-sorted
   \                     `?<Initializer for BanksCksTable>`:
   \   0000   00000001       DB 0, 0, 0, 1, 0, 0, 2, 0, 0, 3, 0, 0, 4, 0, 0, 5, 0, 0, 6, 0, 0, 7, 0
   \          00000200
   \          00030000
   \          04000005
   \          00000600
   \          000700  
   \   0017   00080000       DB 0, 8, 0, 0, 9, 0, 0
   \          090000  

   \                                 In  segment CLTVEC, align 2
   \                     __T_?FAR_CALL_L07:
   \   0000   ....           DW       ?FAR_CALL_L07

   \                                 In  segment CLTVEC, align 2
   \                     __T_DATTrpControl:
   \   0000   ....           DW       DATTrpControl

   \                                 In  segment CLTVEC, align 2
   \                     __T_TOSSendControl:
   \   0000   ....           DW       TOSSendControl

   \                                 In  segment CLTVEC, align 2
   \                     __T_?I_LSH_L02:
   \   0000   ....           DW       ?I_LSH_L02

   \                                 In  segment CLTVEC, align 2
   \                     __T_?FAR_FAST_CALL_L07:
   \   0000   ....           DW       ?FAR_FAST_CALL_L07

   \                                 In  segment CLTVEC, align 2
   \                     __T_TOSStartTimer:
   \   0000   ....           DW       TOSStartTimer

   \                                 In  segment CLTVEC, align 2
   \                     __T_TOSSeqGraphState:
   \   0000   ....           DW       TOSSeqGraphState

   \                                 In  segment CLTVEC, align 2
   \                     __T_TOSSeqDeactivateGraph:
   \   0000   ....           DW       TOSSeqDeactivateGraph

   \                                 In  segment CLTVEC, align 2
   \                     __T_TOSSeqActivateGraph:
   \   0000   ....           DW       TOSSeqActivateGraph

   \                                 In  segment CLTVEC, align 2
   \                     __T_TOSIsTimerElapsed:
   \   0000   ....           DW       TOSIsTimerElapsed

   \                                 In  segment CLTVEC, align 2
   \                     __T_?UL_DIV_L03:
   \   0000   ....           DW       ?UL_DIV_L03

   \                                 In  segment CLTVEC, align 2
   \                     __T_?FUNC_ENTER_L06:
   \   0000   ....           DW       ?FUNC_ENTER_L06

   \                                 In  segment CLTVEC, align 2
   \                     __T_?FUNC_DEALL_L06:
   \   0000   ....           DW       ?FUNC_DEALL_L06

   Segment part sizes:

     Function/Label                   Bytes
     --------------                   -----
     LAPTfcAutoTestIO                   36
     LAPTfcGraph                         6
     LAPTfcEepTest                       6
     BanksCksTable                      30
     RoutineRequestInProgress            7
     u16ErrorsOnOutput                   2
     u32ErrorsOnInput                    4
     u8SequenceMode                      1
     AutoTestTimer                       2
     AutoTestTimeOutValueInTick          2
     SleepTimer                          2
     u8EepTestCounter                    1
     u8AutoTestSetupTimeOut              1
     u8AutoTestActivTimeOut              1
     u8AutoTestSynchroTimeOutIn10msUnit
                                         1
     u8OrderingMatrixSize                1
     u8OrderingMatrix                   48
     u8OrderingMatrixCounter             1
     bOutputsActivated                   1
     u16OutputTab                       32
     EepBanksList                       44
     TabIdentifierServiceSupportedInTfcSession
                                         4
     TabServiceSupportedInTfcSession
                                        16
     SetOutput                         153
     ClearOutput                       146
     ClearOutputAndSetResult           218
     ActivateOutputs                     9
     ActivateOutputs_Static             78
     DeactivateOutputs                  74
     ReadInputsAndSetResult            980
     ReadECU_LOG                       157
     LAPTfcTreatReadDataByLocalIdentifierService
                                       834
     LAPTfcTreatWriteDataByLocalIdentifierService
                                       604
     LAPTfcTreatInputOutputControlByLocalIdentifierService
                                        96
     LAPTfcTreatStartRoutineByLocalIdentifierService
                                      1061
     LAPTfcInitSession                  21
     LAPTfcCloseSession                 26
     IsAutoTestTimeOutElapsed           11
     StartAutoTestTOR                  231
     StartSetupTimeOut                  33
     StartSynchronizationTimeout        41
     IsTimeoutElapsedOrInputsAreSet     37
     FinishSequence                     19
     IsAutoTestFinished                  9
     IsAutoTestFinished_Static          94
     IsSleepTimeoutElapsed              10
     SleepTimeoutElapsed                 3
     TreatEepromTest                     9
     TreatEepromTest_Static            105
     ?<Initializer for BanksCksTable>   30
     __T_?FAR_CALL_L07                   2
     __T_DATTrpControl                   2
     __T_TOSSendControl                  2
     __T_?I_LSH_L02                      2
     __T_?FAR_FAST_CALL_L07              2
     __T_TOSStartTimer                   2
     __T_TOSSeqGraphState                2
     __T_TOSSeqDeactivateGraph           2
     __T_TOSSeqActivateGraph             2
     __T_TOSIsTimerElapsed               2
     __T_?UL_DIV_L03                     2
     __T_?FUNC_ENTER_L06                 2
     __T_?FUNC_DEALL_L06                 2

 
 4 878 bytes in segment BCODE
    26 bytes in segment CLTVEC
   181 bytes in segment CODE
   144 bytes in segment CONST
    30 bytes in segment NEAR_I
    30 bytes in segment NEAR_ID
    75 bytes in segment NEAR_Z
 
 5 059 bytes of CODE  memory (+ 26 bytes shared)
   174 bytes of CONST memory
   105 bytes of DATA  memory

Errors: none
Warnings: none
