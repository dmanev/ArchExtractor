###############################################################################
#                                                                             #
# IAR C/C++ Compiler V4.61A/W32 for 78K0 and 78K0S      15/Feb/2011  13:26:54 #
# Copyright 1992-2008 IAR Systems AB.                                         #
#                                                                             #
#    Core         =  78k0                                                     #
#    Code model   =  Standard                                                 #
#                 =                                                           #
#    Source file  =  D:\X90_BCM\DEVELOPMENT\X90_BCM\K0\L7\BUILD\SOURCES\DAT\D #
#                    AT_TRP.C                                                 #
#    Command line =  --code_model standard --core 78k0 -e                     #
#                    -DMEM_TYPE=__banked -DMEM_FAST=__saddr                   #
#                    -DCALLT_TYPE=__callt -DX90_PROJECT                       #
#                    --generate_callt_runtime_library_calls -Ohs              #
#                    "-IC:\Program Files\IAR Systems\Embedded Workbench       #
#                    5.0\78k\inc" "-IC:\Program Files\IAR Systems\Embedded    #
#                    Workbench 5.0\78k\inc\clib" -I. -I..\EXE\GEN\            #
#                    -I..\SOURCES\DAT -I..\SOURCES\LAP -I..\SOURCES\LDB_API   #
#                    -I..\SOURCES\LIB -I..\SOURCES\TOS -I.\LDB -DROM          #
#                    -DUSE_LIBSTK -DDONT_KEEP_OLD_TYPE_COMPATIBILITY -l       #
#                    ..\EXE\TARGET_R\DAT_TRP.LST -o                           #
#                    ..\EXE\TARGET_R\DAT_TRP.R26                              #
#                    D:\X90_BCM\DEVELOPMENT\X90_BCM\K0\L7\BUILD\SOURCES\DAT\D #
#                    AT_TRP.C                                                 #
#    List file    =  ..\EXE\TARGET_R\DAT_TRP.LST                              #
#    Object file  =  ..\EXE\TARGET_R\DAT_TRP.R26                              #
#                                                                             #
#                                                                             #
###############################################################################

D:\X90_BCM\DEVELOPMENT\X90_BCM\K0\L7\BUILD\SOURCES\DAT\DAT_TRP.C
      1          //******************************************************************************
      2          // Company:      Johnson Controls Inc.
      3          // -----------------------------------------------------------------------------
      4          // Copyright:    This software is JCI property.
      5          //               Duplication or disclosure without JCI written authorization
      6          //               is prohibited.
      7          // -----------------------------------------------------------------------------
      8          // Project:      X90_BCM
      9          // Language:     ANSI-C
     10          // -----------------------------------------------------------------------------
     11          // Component:    DAT_TRP
     12          // -----------------------------------------------------------------------------
     13          // $Date:   Mar 22 2010 16:14:28  $
     14          // $Archive:   J:/_PVCSRoot/Renault/X90_BCM/SOFTWARE/PVCS/archives/DEVELOPMENT/X90_BCM/K0/L7/CMP/DAT/DAT_TRP/DAT_TRP.C-arc  $
     15          // $Revision:   1.27  $
     16          // -----------------------------------------------------------------------------  
     17          //  $Log::   J:/_PVCSRoot/Renault/X90_BCM/SOFTWARE/PVCS/archives/DEVELOPMENT/X90_BCM/K0/L7/CMP/DAT/DAT_TRP/DAT_TRP.C-arc  $
     18          // 
     19          //    Rev 1.27   Mar 22 2010 16:14:28   amanevd
     20          // Cm007334: (0==DO_DATA_IMMOBILIZERProtection) check before EEP_CDImmo increase
     21          // 
     22          //    Rev 1.26   Mar 01 2010 15:05:38   adzhelp
     23          // Cm007334: Code review corrections
     24          // 
     25          //    Rev 1.25   Feb 25 2010 15:53:14   amanevd
     26          // Cm007334: If Immo line is protected, DAT_TRP controls managing the line are not processed
     27          // 
     28          //    Rev 1.24   Feb 11 2010 17:11:36   amanevd
     29          // Cm007463: LDBRefreshWatchDog() called before and after each LIBPcf function
     30          // 
     31          //    Rev 1.23   Feb 11 2010 16:25:58   amanevd
     32          // Cm007463: LDBRefreshWatchDog() called before each LIBPcf function
     33          // 
     34          //    Rev 1.22   Feb 11 2010 16:19:04   amanevd
     35          // Cm006992: "compt_nb_int" is incremented on sending START_AUTH
     36          // 
     37          //    Rev 1.21   Feb 08 2010 09:24:18   amanevd
     38          // Cm006744: Perform 32-bit math operations only when values are changed
     39          // 
     40          //    Rev 1.20   Feb 03 2010 11:51:24   adzhelp
     41          // Cm005245: Reordered header files inclusion
     42          // 
     43          //    Rev 1.19   Jan 22 2010 11:53:58   amanevd
     44          // Cm006992: On ActivateDiag control check included prior send Stop control to LDB
     45          // 
     46          //    Rev 1.18   Jan 19 2010 14:42:56   amanevd
     47          // Cm006992: "compt_nb_int" made as a full 8 bits counter incremented in case of faild or successful reception of the key RESPONSE
     48          // 
     49          //    Rev 1.17   Dec 15 2009 10:40:50   amanevd
     50          // Cm005566: Defect is set only if PWR_IGN==1
     51          // 
     52          //    Rev 1.16   Dec 14 2009 10:52:16   amanevd
     53          // Cm005566: Full Hardware Protection
     54          // 
     55          //    Rev 1.15   Nov 04 2009 16:32:10   amanevd
     56          // Cm005566: Simplified Protection
     57          // 
     58          //    Rev 1.14   Oct 05 2009 13:52:08   amanevd
     59          // Cm006307: DatTrpExportData.VirginKeyAuthentOk is set 1 when learning in Plant mode
     60          // 
     61          //    Rev 1.13   Oct 02 2009 14:03:04   amanevd
     62          // Cm005807: Missing initial value of "compt_nb_int" set to 1
     63          // 
     64          //    Rev 1.12   Sep 17 2009 09:58:38   adzhelp
     65          // Cm003277: DATTrpControl() defined as CALLT_TYPE
     66          // 
     67          //    Rev 1.11   Aug 07 2009 18:09:42   amanevd
     68          // Cm005142: Implementation of Confidential Diagnostic
     69          // 
     70          //    Rev 1.10   Jul 14 2009 17:14:42   amanevd
     71          // Cm005586: DiagKeyFrequency signal included
     72          // 
     73          //    Rev 1.9   May 21 2009 11:20:16   amanevd
     74          // Cm003272: CCover and QAC justification - NO IMPACT ON REAL CODE
     75          // 
     76          //    Rev 1.8   May 18 2009 10:54:06   amanevd
     77          // Cm003272L: Correction reagirding ILCR_DAT_TRP.xls, rev.: 1.0 - NO IMPACT ON REAL CODE
     78          // 
     79          //    Rev 1.7   May 11 2009 15:12:02   amanevd
     80          // Cm003272 - Indent Change - NO IMPACT ON REAL CODE
     81          // 
     82          //    Rev 1.6   May 07 2009 11:30:00   amanevd
     83          // Cm003272 - Finishing part 2 - pre-integration
     84          // 
     85          //    Rev 1.5   Apr 29 2009 13:12:30   amanevd
     86          // Cm003272 - Intermediate part 3 
     87          // - PRS compliance
     88          // 
     89          //    Rev 1.4   Apr 22 2009 19:23:40   amanevd
     90          // Cm003272 - Finishing part 1 - pre-integration
     91          // 
     92          //    Rev 1.3   Feb 13 2009 14:52:10   amanevd
     93          // Cm003272 - Intermediate part 1 - PRS compliance
     94          // 
     95          //    Rev 1.2   Feb 04 2009 15:12:34   amanevd
     96          // Cm003272 - QAC fix
     97          // 
     98          //    Rev 1.1   Feb 04 2009 13:29:42   amanevd
     99          // Cm003272 - Intermediate part 1
    100          // - PRS compliance
    101          // 
    102          //    Rev 1.0   Jan 09 2009 14:03:58   amanevd
    103          // Initial revision.
    104          //=============================================================================
    105          
    106          //-----------------------------------------------------------------------------
    107          //  Body Identification
    108          //-----------------------------------------------------------------------------
    109          #define DAT_TRP  "DAT_TRP"
    110          
    111          //-----------------------------------------------------------------------------
    112          //  Included files
    113          //
    114          //  #include <system_file_name.h>
    115          //  #include "project_file_name.h"
    116          //-----------------------------------------------------------------------------
    117          #include "tos.h"
    118          #include "dat.h"
    119          #include "ldb.h"
    120          #include "lib_pcf.h"
    121          #include "lib_rnd.h"
    122          #include "dat_trp.h"
    123          #include "dat_trp.hgr"

   \                                 In  segment CONST, align 2
   \   tTOSSeqRuleType const __near DATTrpAuthentication[17]
   \                     DATTrpAuthentication:
   \   0000   ........       DW TOSSeqTrueEval, DATTrpSendSleepControl
   \   0004   FF01           DB 255, 1
   \   0006   ........       DW DATTrpSleepFinished, DATTrpSendWakeUpControl
   \   000A   1002           DB 16, 2
   \   000C   ........       DW DATTrpWakeUpFinished, DATTrpSendStartAuth
   \   0010   0E03           DB 14, 3
   \   0012   ........       DW DATTrpIdentifierReceivedOK, DATTrpCalculateChallenge
   \   0016   0D04           DB 13, 4
   \   0018   ........       DW DATTrpAnswerChallengeReceivedOK, TOSSeqNoAction
   \   001C   0C05           DB 12, 5
   \   001E   ........       DW DATTrpAuthentInNormalMode, DATTrpAuthenticationSuccess
   \   0022   06FF           DB 6, 255
   \   0024   ........       DW TOSSeqTrueEval, DATTrpSendInvertedReadCommand
   \   0028   FF07           DB 255, 7
   \   002A   ........       DW DATTrpPage3InvertedDataReceivedOK, DATTrpAuthenticationSuccess
   \   002E   08FF           DB 8, 255
   \   0030   ........       DW DATTrpAnswerReceivedNOKOrTimeOut, TOSSeqNoAction
   \   0034   FF09           DB 255, 9
   \   0036   ........       DW DATTrpNewAuthenticationAuthorized, DATTrpIncreaseRetryCounters
   \   003A   0B0A           DB 11, 10
   \   003C   ........       DW TOSSeqTrueEval, DATTrpSendSleepControl
   \   0040   FF01           DB 255, 1
   \   0042   ........       DW TOSSeqTrueEval, DATTrpAuthenticationNotSuccess
   \   0046   FFFF           DB 255, 255
   \   0048   ........       DW DATTrpAnswerReceivedNOKOrTimeOut, TOSSeqNoAction
   \   004C   FF09           DB 255, 9
   \   004E   ........       DW DATTrpAnswerReceivedNOKOrTimeOut, TOSSeqNoAction
   \   0052   FF09           DB 255, 9
   \   0054   ........       DW DATTrpAnswerReceivedNOKOrTimeOut, DATTrpOnWakeUpControlNotSuccessful
   \   0058   FF0F           DB 255, 15
   \   005A   ........       DW TOSSeqTrueEval, TOSSeqNoAction
   \   005E   FF09           DB 255, 9
   \   0060   ........       DW DATTrpAnswerReceivedNOKOrTimeOut, TOSSeqNoAction
   \   0064   FF09           DB 255, 9

   \                                 In  segment CONST, align 2
   \   tTOSSeqRuleType const __near DATTrpWriteAccess[12]
   \                     DATTrpWriteAccess:
   \   0000   ........       DW TOSSeqTrueEval, DATTrpSendWriteCommand
   \   0004   FF01           DB 255, 1
   \   0006   ........       DW DATTrpWriteCommandReceivedOK, DATTrpSendDataToWrite
   \   000A   0B02           DB 11, 2
   \   000C   ........       DW DATTrpPageWrittenOK, DATTrpSendReadCommand
   \   0010   0A03           DB 10, 3
   \   0012   ........       DW DATTrpReadAndCompareOK, DATTrpWriteSuccess
   \   0016   04FF           DB 4, 255
   \   0018   ........       DW DATTrpAnswerReceivedNOKOrTimeOut, DATTrpReadNOKAction
   \   001C   FF05           DB 255, 5
   \   001E   ........       DW DATTrpInLearningModeAndLessThanMaxTrials, DATTrpSendWriteCommand
   \   0022   0601           DB 6, 1
   \   0024   ........       DW DATTrpNewTryAuthorized, DATTrpStartAuthenticationService
   \   0028   0907           DB 9, 7
   \   002A   ........       DW DATTrpAuhenticationServiceFinishedOK, DATTrpSendWriteCommand
   \   002E   0801           DB 8, 1
   \   0030   ........       DW DATTrpAuhenticationServiceFinishedNOK, DATTrpWriteNotSuccess
   \   0034   FFFF           DB 255, 255
   \   0036   ........       DW TOSSeqTrueEval, DATTrpWriteNotSuccess
   \   003A   FFFF           DB 255, 255
   \   003C   ........       DW DATTrpAnswerReceivedNOKOrTimeOut, DATTrpWriteNOKAction
   \   0040   FF05           DB 255, 5
   \   0042   ........       DW DATTrpAnswerReceivedNOKOrTimeOut, TOSSeqNoAction
   \   0046   FF05           DB 255, 5

   \                                 In  segment CONST, align 2
   \   tTOSSeqRuleType const __near DATTrpResynchronization[3]
   \                     DATTrpResynchronization:
   \   0000   ........       DW TOSSeqTrueEval, DATTrpStartWriteServiceForResync
   \   0004   FF01           DB 255, 1
   \   0006   ........       DW DATTrpWriteServiceFinishedOK, DATTrpResynchronizationSuccess
   \   000A   02FF           DB 2, 255
   \   000C   ........       DW DATTrpWriteServiceFinishedNOK, DATTrpResynchronizationNotSuccess
   \   0010   FFFF           DB 255, 255

   \                                 In  segment CONST, align 2
   \   tTOSSeqRuleType const __near DATTrpTfcDiag[3]
   \                     DATTrpTfcDiag:
   \   0000   ........       DW TOSSeqTrueEval, DATTrpSendStartAuth
   \   0004   FF01           DB 255, 1
   \   0006   ........       DW DATTrpTfcResponceOK, DATTrpTfcDiagSuccess
   \   000A   02FF           DB 2, 255
   \   000C   ........       DW DATTrpAnswerReceivedNOKOrTimeOut, DATTrpTfcDiagNotSuccess
   \   0010   FFFF           DB 255, 255
    124          
    125          //-----------------------------------------------------------------------------
    126          //  Local constants
    127          //
    128          //  #define cConstantName   ((tType) ConstantValue)
    129          //-----------------------------------------------------------------------------
    130          
    131          // Time out definition
    132          #define cSendWriteCmdTimeOut    ((tTOSTimer) mTOSConvMsInTimerTick(60UL))
    133          #define cSendDataToWriteTimeOut ((tTOSTimer) mTOSConvMsInTimerTick(60UL))
    134          #define cIDEReadingTimeOut      ((tTOSTimer) mTOSConvMsInTimerTick(60UL))
    135          #define cReadCmdTimeOut         ((tTOSTimer) mTOSConvMsInTimerTick(80UL))
    136          #define cChallengeTimeOut       ((tTOSTimer) mTOSConvMsInTimerTick(80UL))
    137          #define cControlTimeOut         ((tTOSTimer) mTOSConvMsInTimerTick(60UL))
    138          #define cBlkPtrTimeOut          ((tTOSTimer) mTOSConvMsInTimerTick(60UL))
    139          #define cWritingInTrpTimeOut    ((tTOSTimer) mTOSConvMsInTimerTick(40UL))
    140          
    141          // Duration of the authentication time out
    142          //QACJ 3443:amanevd: Last instance of mDATRead is a concatenation of mDATRead ## DataType## DataName ## TreatmentType()
    143          #define mCalcTimeOutAuthent()   (mTOSConvMsInTimerTick((U32)(DatTrpLocalData.u16TimeOutTW2 = mDATRead( U16Bit, EEP_TimeOutTW2, Default))))
    144          
    145          #define mTimeOutAuthent() (DatTrpLocalData.CalculatedTimeOutTW2 = \
    146                                      (DatTrpLocalData.u16TimeOutTW2 == mDATRead( U16Bit, EEP_TimeOutTW2, Default)) \
    147                                      ? DatTrpLocalData.CalculatedTimeOutTW2 \
    148              /*//QACJ 3443:amanevd: Last instance of mDATRead is a concatenation of mDATRead ## DataType## DataName ## TreatmentType()*/ \
    149                                      : mCalcTimeOutAuthent())
    150          
    151          // Used to generate encrypted signature for authentication challenge
    152          #define cSignatureInitialValue  ((U32) 0xFFFFFFFFU)
    153          
    154          #define cMaxAuthentTrialsCustomerMode       ((U8) 3)
    155          #define cMaxAuthentTrialsLearningMode       ((U8) 2)
    156          
    157          // Mask
    158          #define cComputedCommandMask    ((tTrpCommand) 0x001FU)
    159          
    160          #define cPageNumberMask         ((U8) 0x07U)
    161          #define cFrequencyMask          ((U8) 0x30U)
    162          
    163          #define cKeyLocked              ((U32)0x40000000U)
    164          #define cKeyWithRF              ((U32)0x00000020U)
    165          #define cKeyStandard            ((U32)0x00000010U)
    166          #define cKeyStandardMsk         ((U32)0x000000F0U)
    167          #define cKeyWithExtendedMemory  ((U32)0x00800000U)
    168          
    169          #define cMaskBit0               ((U8) 0x01U)
    170          #define cMaskBit1               ((U8) 0x02U)
    171          #define cMaskBit2               ((U8) 0x04U)
    172          #define cMaskBit3               ((U8) 0x08U)
    173          #define cMaskBit4               ((U8) 0x10U)
    174          #define cMaskBit5               ((U8) 0x20U)
    175          #define cMaskBit6               ((U8) 0x40U)
    176          #define cMaskBit7               ((U8) 0x80U)
    177          // amanevd: 'Neg' constants make QAC to shut up. Must update them
    178          // every time you update the original constant !!!
    179          #define cNegMaskBit0            ((U8) 0xFEU)
    180          #define cNegMaskBit1            ((U8) 0xFDU)
    181          #define cNegMaskBit2            ((U8) 0xFBU)
    182          #define cNegMaskBit3            ((U8) 0xF7U)
    183          #define cNegMaskBit4            ((U8) 0xEFU)
    184          #define cNegMaskBit5            ((U8) 0xDFU)
    185          #define cNegMaskBit6            ((U8) 0xBFU)
    186          #define cNegMaskBit7            ((U8) 0x7FU)
    187          
    188          #define cMaskByte1              ((U32) 0x000000FFU)
    189          #define cMaskByte2              ((U32) 0x0000FF00U)
    190          #define cMaskByte3              ((U32) 0x00FF0000U)
    191          #define cMaskByte4              ((U32) 0xFF000000U)
    192          #define c24bitMask              ((U32) 0x00FFFFFFU)
    193          
    194          #define cU8LowPart                ((U8) 0U)
    195          #define cU8HighPart               ((U8) 1U)
    196          
    197          #define cMaskU8LSB              ((U8) 0x0FU)
    198          #define cMaskU8MSB              ((U8) 0xF0U)
    199          
    200          // Maximum value of the default counters
    201          #define cMaxWritingDefault                                  ((U8)   0xFFU)
    202          #define cMaxAuthentDelayedCounter                           ((U8)   0xFFU)
    203          #define cMaxAuthentFailureCounter                           ((U8)   0xFFU)
    204          #define cMaxResynchroSuccessfulCounter                      ((U8)   0xFFU)
    205          #define cMaxCDImmoCounter                                   ((U8)   0xFFU)
    206          
    207          #define cTrpBufferSize          ((U8) 4)
    208          
    209          // Transport ISK definition
    210          #define cTranspIsk0             ((U8)0x4DU)
    211          #define cTranspIsk1             ((U8)0x49U)
    212          #define cTranspIsk2             ((U8)0x4BU)
    213          #define cTranspIsk3             ((U8)0x52U)
    214          #define cTranspIsk4             ((U8)0x4FU)
    215          #define cTranspIsk5             ((U8)0x4EU)
    216          
    217          // constant for shifting purposes
    218          // amanevd: QAC expects 32 bit word, we are using 8 bit word
    219          #ifndef _QAC_
    220          #define cShift1                 ((U8) 1)
    221          #define cShift2                 ((U8) 2)
    222          #define cShift4                 ((U8) 4)
    223          #define cShift8                 ((U8) 8)
    224          #define cShift16                ((U8)16)
    225          #define cShift24                ((U8)24)
    226          
    227          #define cPage0                  ((U8) 0)
    228          #define cPage1                  ((U8) 1)
    229          #define cPage2                  ((U8) 2)
    230          #define cPage3                  ((U8) 3)
    231          #define cPage4                  ((U8) 4)
    232          #define cPage5                  ((U8) 5)
    233          #define cPage6                  ((U8) 6)
    234          
    235          #else
    236          #define cShift1                 ((U32) 1)
    237          #define cShift2                 ((U32) 2)
    238          #define cShift4                 ((U32) 4)
    239          #define cShift8                 ((U32) 8)
    240          #define cShift16                ((U32)16)
    241          #define cShift24                ((U32)24)
    242          
    243          #define cPage0                  ((U32) 0)
    244          #define cPage1                  ((U32) 1)
    245          #define cPage2                  ((U32) 2)
    246          #define cPage3                  ((U32) 3)
    247          #define cPage4                  ((U32) 4)
    248          #define cPage5                  ((U32) 5)
    249          #define cPage6                  ((U32) 6)
    250          #endif
    251          
    252          // Lenght in bit of data transmited to the transponder
    253          #define cTrpOutState            ((U16) 1)
    254          #define cAuthLength				((U16) 5)
    255          #define cStartEXMLength			((U16) 5)
    256          #define cCommandLength          ((U16) 10)
    257          #define cPageLength             ((U16) 32)
    258          #define cIdentifierLength       ((U16) 32)
    259          #define cSignatureLength        ((U16) 32)
    260          #define cChallengeLength        ((U16) 64)
    261          
    262          #define cTrpAuth			    ((U8) 0xC0U)   // 11000 000
    263          #define cStartEXMMode           ((U8) 0x38U)   // 00111 000
    264          #define cDecrementBlockPointer  ((U16)0x00BAU) // 00101 11010
    265          #define cIncrementBlockPointer  ((U16)0x009BU) // 00100 11011
    266          #define cInitializeBlockPointer ((U16)0x00D9U) // 00110 11001
    267          
    268          //-----------------------------------------------------------------------------
    269          //  Local macros
    270          //
    271          //  #define mMacroName   (MacroDefinition)
    272          //-----------------------------------------------------------------------------
    273          
    274          // Flag's access macros
    275          #define mSetFlagImmoAntAnswerReceived()   (DatTrpLocalData.u8TrpFlag |= cMaskBit0)
    276          #define mClearFlagImmoAntAnswerReceived() (DatTrpLocalData.u8TrpFlag &= cNegMaskBit0)
    277          #define mGetFlagImmoAntAnswerReceived()   ((DatTrpLocalData.u8TrpFlag & cMaskBit0) != 0)
    278          
    279          #define mSetFlagAnswerReceivedOK()   (DatTrpLocalData.u8TrpFlag |= cMaskBit1)
    280          #define mClearFlagAnswerReceivedOK() (DatTrpLocalData.u8TrpFlag &= cNegMaskBit1)
    281          #define mGetFlagAnswerReceivedOK()   ((DatTrpLocalData.u8TrpFlag & cMaskBit1) != 0)
    282          
    283          #define mMarkTrpOutActive()         (u8DATTrpOutState = 1)
    284          #define mMarkTrpOutInactive()       (u8DATTrpOutState = 0)
    285          
    286          
    287          //-----------------------------------------------------------------------------
    288          //  Local types
    289          //
    290          //  struct  sStructureName { ... };
    291          //  union   uUnionName { ... };
    292          //  enum    eEnumerationName { ... };
    293          //  typedef Expression tTypeName;
    294          //-----------------------------------------------------------------------------
    295          
    296          typedef tAddress tTrpCommand;
    297          
    298          typedef struct tDatTrpLocalDataType
    299          {
    300              // Buffer used to received data from LDB_TRP
    301              U32         u32DataBuffer;
    302              // Exchange identifier buffer
    303              U8          ExchIdentifier[cTrpBufferSize];
    304              // Message DAT_TRP <=> LDB_TRP
    305              tMsg        TransponderMessage;
    306          
    307              // Timer used to manage communication time Out between the BCM and the Immobilizer Antenna
    308              tTOSTimer   TimeOutWaitingForImmoANTReply;
    309              // Timer used to manage the delay of writing in the EEP of the transponder
    310              tTOSTimer   TimeOutWaitingForWriting;
    311              // Timer used to manage the authentication time out
    312              tTOSTimer   AuthenticationTimeOut;
    313              // Data used to define the current command time out
    314              tTOSTimer   CommandTimeOut;
    315              tTOSTimer   CalculatedTimeOutTW2;
    316          
    317              tTrpCommand WritingCommand;
    318              tTrpCommand ReadingCommand;
    319              tTrpCommand InvertedReadingCommand;
    320          
    321              U16         u16TimeOutTW2;
    322          
    323              // Flags
    324              U8          u8TrpFlag;
    325              
    326              U8          u8ReadOrWriteNumberOfTry;
    327              U8          u8AuthentLocalCounter;
    328              U8          Buffer[cTrpBufferSize];
    329          
    330              // flag indication stop authentication service is requested;
    331              BOOL        bStopAuthentService;
    332              BOOL        bDiagnosticRunning;
    333          }tDatTrpLocalData;
    334          
    335          //-----------------------------------------------------------------------------
    336          //  Local data
    337          //
    338          //  static  tType   VariableName;
    339          //  static  tType*  pVariableName; 
    340          //-----------------------------------------------------------------------------
    341          
    342          // Dat Trp private Data

   \                                 In  segment NEAR_Z, align 2, align-sorted
    343          static tDatTrpLocalData DatTrpLocalData;
   \                     DatTrpLocalData:
   \   0000                  DS 40
   \   0028                  REQUIRE __INIT_NEAR_Z
    344          
    345          //-----------------------------------------------------------------------------
    346          //  Constant local data
    347          //
    348          //  static const tType  VariableName;
    349          //-----------------------------------------------------------------------------
    350          
    351          
    352          //-----------------------------------------------------------------------------
    353          //  Exported data
    354          //
    355          //  tType   LAYCmpVariableName;   (LAY: 3 characters to identify the layer)
    356          //  tType*  pLAYCmpVariableName;  (Cmp: 3 characters to identify this component)
    357          //-----------------------------------------------------------------------------
    358          

   \                                 In  segment NEAR_Z, align 2, align-sorted
    359          tDatTrpExportData DatTrpExportData;
   \                     DatTrpExportData:
   \   0000                  DS 52
   \   0034                  REQUIRE __INIT_NEAR_Z
    360          

   \                                 In  segment NEAR_Z, align 1, align-sorted
    361          U8 u8DATTrpOutState;
   \                     u8DATTrpOutState:
   \   0000                  DS 1
   \   0001                  REQUIRE __INIT_NEAR_Z
    362          //-----------------------------------------------------------------------------
    363          //  Constant exported data
    364          //
    365          //              (LAY: 3 characters to identify the layer)
    366          //              (Cmp: 3 characters to identify this component)
    367          // 
    368          //  const tType   LAYCmpVariableName;
    369          //-----------------------------------------------------------------------------
    370          //QACJ 3211:amanevd: The constant is used in 'mLIBmemcmp' macro execution as well as it is exported

   \                                 In  segment CONST, align 1
    371          const U8 DATTrpTransportISK[cDATTrpISKLengthInBytes] = 
   \                     DATTrpTransportISK:
   \   0000   4D494B52       DB 77, 73, 75, 82, 79, 78
   \          4F4E    
    372              {cTranspIsk0,cTranspIsk1,cTranspIsk2,cTranspIsk3,cTranspIsk4,cTranspIsk5};
    373          
    374          //-----------------------------------------------------------------------------
    375          //  Local function prototypes
    376          //  
    377          //  static tTypeRetour FunctionName(tTypeArgument1 ArgumentName1, ... );
    378          //-----------------------------------------------------------------------------
    379          static tTrpCommand ComputeCommandWithPageNumber(const U8 u8PageNumberP, 
    380                                                          const tTrpCommand tStandardCommandP);
    381          static tTrpCommand EncodeCommand(tTrpCommand tOriginalCommandP);
    382          
    383          static U32 U32ReverseByteOrder(const U32 u32TargetP);
    384          static MEM_TYPE void SignalCurrentKeyFrequency(void);
    385          
    386          #ifdef X90_PROJECT
    387          static MEM_TYPE void DATTrpControl_Static(const tCtrl Ctrl);
    388          static MEM_TYPE void DATTrpInit_Static(void);
    389          static MEM_TYPE BOOL DATTrpAnswerChallengeReceivedOK_Static(void);
    390          static MEM_TYPE void DATTrpCalculateChallenge_Static(void);
    391          static MEM_TYPE BOOL DATTrpIdentifierReceivedOK_Static(void);
    392          static MEM_TYPE void DATTrpSendReadCommand_Static(void);
    393          static MEM_TYPE BOOL DATTrpNewAuthenticationAuthorized_Static(void);
    394          static MEM_TYPE void DATTrpResynchronizationNotSuccess_Static(void);
    395          static MEM_TYPE void DATTrpResynchronizationSuccess_Static(void);
    396          static MEM_TYPE void DATTrpSendInvertedReadCommand_Static(void);
    397          static MEM_TYPE BOOL DATTrpReadAndCompareOK_Static(void);
    398          static MEM_TYPE void DATTrpSendWriteCommand_Static(void);
    399          static MEM_TYPE void DATTrpSendDataToWrite_Static(void);
    400          static MEM_TYPE BOOL DATTrpWriteCommandReceivedOK_Static(void);
    401          static MEM_TYPE BOOL DATTrpPage3InvertedDataReceivedOK_Static(void);
    402          static MEM_TYPE void DATTrpStartAuthenticationService_Static(void);
    403          static MEM_TYPE void DATTrpAuthenticationNotSuccess_Static(void);
    404          static MEM_TYPE void DATTrpAuthenticationSuccess_Static(void);
    405          static MEM_TYPE void DATTrpSendStartAuth_Static(void);
    406          static MEM_TYPE void DATTrpSendWakeUpControl_Static(void);
    407          static MEM_TYPE BOOL DATTrpNewTryAuthorized_Static(void);
    408          static MEM_TYPE BOOL DATTrpInLearningModeAndLessThanMaxTrials_Static(void);
    409          #endif
    410          
    411          //=============================================================================
    412          //=========================== LOCAL FUNCTIONS =================================
    413          //=============================================================================
    414          
    415          //=============================================================================
    416          //  DESCRIPTION :
    417          //  
    418          //  PARAMETERS (Type,Name,Min,Max) :   none
    419          //
    420          //  RETURN VALUE :   none
    421          // 
    422          //  DESIGN INFORMATION :   refer to Detailed Design Document
    423          //=============================================================================
    424          //static type FunctionName(...)
    425          
    426          //=============================================================================
    427          //  DESCRIPTION : Compute a transponder command with a page number. It used for
    428          //                reading and writing command.
    429          //  
    430          //  PARAMETERS (Type,Name,Min,Max) : U8 ucPageNumberP : page number
    431          //                                   tTrpCommand StandardCommandP : base command
    432          //
    433          //  RETURN VALUE :  Computed command.
    434          // 
    435          //  DESIGN INFORMATION :   refer to Detailed Design Document
    436          //=============================================================================

   \                                 In  segment CODE, align 1, keep-with-next
    437          static tTrpCommand ComputeCommandWithPageNumber(const U8 u8PageNumberP, 
   \                     ComputeCommandWithPageNumber:
    438                                                          const tTrpCommand tStandardCommandP)
    439          {
   \   0000                  ; * Stack frame (at entry) *
   \   0000                  ; Param size: 0
   \   0000   B5             PUSH      DE
   \   0001                  ; Total Auto size: 0
    440              tTrpCommand tComputedCommandL;
    441          
    442              tComputedCommandL = tStandardCommandP | (u8PageNumberP & cPageNumberMask);
   \   0001   A000           MOV       X,#0
   \   0003   5D07           AND       A,#7
   \   0005   616A           OR        A,C
   \   0007   30             XCH       A,X
   \   0008   616B           OR        A,B
   \   000A   D6             MOVW      HL,AX
    443              tComputedCommandL =   (tComputedCommandL << (cShift4 + cShift1)) 
    444              | ((tTrpCommand)(~tComputedCommandL) & cComputedCommandMask);
    445          
    446              return tComputedCommandL;
   \   000B   60             MOV       A,X
   \   000C   7DFF           XOR       A,#255
   \   000E   5D1F           AND       A,#31
   \   0010   70             MOV       X,A
   \   0011   A100           MOV       A,#0
   \   0013   D4             MOVW      DE,AX
   \   0014   C6             MOVW      AX,HL
   \   0015   21             CLR1      CY
   \   0016   30             XCH       A,X
   \   0017   27             ROLC      A,0x1
   \   0018   30             XCH       A,X
   \   0019   27             ROLC      A,0x1
   \   001A   21             CLR1      CY
   \   001B   30             XCH       A,X
   \   001C   27             ROLC      A,0x1
   \   001D   30             XCH       A,X
   \   001E   27             ROLC      A,0x1
   \   001F   21             CLR1      CY
   \   0020   30             XCH       A,X
   \   0021   27             ROLC      A,0x1
   \   0022   30             XCH       A,X
   \   0023   27             ROLC      A,0x1
   \   0024   21             CLR1      CY
   \   0025   30             XCH       A,X
   \   0026   27             ROLC      A,0x1
   \   0027   30             XCH       A,X
   \   0028   27             ROLC      A,0x1
   \   0029   21             CLR1      CY
   \   002A   30             XCH       A,X
   \   002B   27             ROLC      A,0x1
   \   002C   30             XCH       A,X
   \   002D   27             ROLC      A,0x1
   \   002E   30             XCH       A,X
   \   002F   616C           OR        A,E
   \   0031   30             XCH       A,X
   \   0032   B4             POP       DE
   \   0033   AF             RET       
   \   0034                  REQUIRE ?CL78K_V4_6_L00
    447          }
    448          //=============================================================================
    449          //  DESCRIPTION : Encode a transponder command.
    450          //  
    451          //  PARAMETERS (Type,Name,Min,Max) : tTrpCommand OriginalCommand : unencoded command
    452          //
    453          //  RETURN VALUE :   none
    454          // 
    455          //  DESIGN INFORMATION :   refer to Detailed Design Document
    456          //=============================================================================

   \                                 In  segment CODE, align 1, keep-with-next
    457          static tTrpCommand EncodeCommand(tTrpCommand tOriginalCommandP)
   \                     EncodeCommand:
    458          {
   \   0000                  ; * Stack frame (at entry) *
   \   0000                  ; Param size: 0
   \   0000   B3             PUSH      BC
   \   0001   B5             PUSH      DE
   \   0002                  ; Total Auto size: 0
    459              tOriginalCommandP <<= cShift4 + cShift2;
   \   0002   21             CLR1      CY
   \   0003   30             XCH       A,X
   \   0004   27             ROLC      A,0x1
   \   0005   30             XCH       A,X
   \   0006   27             ROLC      A,0x1
   \   0007   21             CLR1      CY
   \   0008   30             XCH       A,X
   \   0009   27             ROLC      A,0x1
   \   000A   30             XCH       A,X
   \   000B   27             ROLC      A,0x1
   \   000C   21             CLR1      CY
   \   000D   30             XCH       A,X
   \   000E   27             ROLC      A,0x1
   \   000F   30             XCH       A,X
   \   0010   27             ROLC      A,0x1
   \   0011   21             CLR1      CY
   \   0012   30             XCH       A,X
   \   0013   27             ROLC      A,0x1
   \   0014   30             XCH       A,X
   \   0015   27             ROLC      A,0x1
   \   0016   21             CLR1      CY
   \   0017   30             XCH       A,X
   \   0018   27             ROLC      A,0x1
   \   0019   30             XCH       A,X
   \   001A   27             ROLC      A,0x1
   \   001B   21             CLR1      CY
   \   001C   30             XCH       A,X
   \   001D   27             ROLC      A,0x1
   \   001E   30             XCH       A,X
   \   001F   27             ROLC      A,0x1
   \   0020   D6             MOVW      HL,AX
    460              LIBPcfCipheredData =  (U32)((tOriginalCommandP << cShift8) & cMaskByte2)
    461              | (U32)((tOriginalCommandP >> cShift8) & cMaskByte1);
   \   0021   70             MOV       X,A
   \   0022   A100           MOV       A,#0
   \   0024   120000         MOVW      BC,#0
   \   0027   B3             PUSH      BC
   \   0028   B1             PUSH      AX
   \   0029   C6             MOVW      AX,HL
   \   002A   60             MOV       A,X
   \   002B   A000           MOV       X,#0
   \   002D   9A....         CALL      ?L_IOR_L03
   \   0030   99..           MOVW      S:LIBPcfCipheredData,AX
   \   0032   C2             MOVW      AX,BC
   \   0033   99..           MOVW      S:LIBPcfCipheredData+2,AX
    462          
    463              LDBRefreshWatchDog();
   \   0035   9A....         CALL      LDBRefreshWatchDog
    464              LIBPcfCipherFunction(cCommandLength);
   \   0038   A10A           MOV       A,#10
   \   003A   16....         MOVW      HL,#LWRD(LIBPcfCipherFunction)
   \   003D   A4..           MOV       E,#BYTE3(LIBPcfCipherFunction)
   \   003F   ..             CALLT     [__T_?FAR_CALL_L07]
    465              LDBRefreshWatchDog();
   \   0040   9A....         CALL      LDBRefreshWatchDog
    466          
    467              LIBPcfCipheredData =  ((LIBPcfCipheredData << cShift8) & cMaskByte2)
    468              | ((LIBPcfCipheredData >> cShift8) & cMaskByte1);
   \   0043   89..           MOVW      AX,S:LIBPcfCipheredData
   \   0045   74             MOV       E,A
   \   0046   C2             MOVW      AX,BC
   \   0047   75             MOV       D,A
   \   0048   D6             MOVW      HL,AX
   \   0049   B7             PUSH      HL
   \   004A   B5             PUSH      DE
   \   004B   B1             PUSH      AX
   \   004C   A1FF           MOV       A,#255
   \   004E   B1             PUSH      AX
   \   004F   89..           MOVW      AX,S:LIBPcfCipheredData+2
   \   0051   D2             MOVW      BC,AX
   \   0052   89..           MOVW      AX,S:LIBPcfCipheredData
   \   0054   E2             XCHW      AX,BC
   \   0055   60             MOV       A,X
   \   0056   E2             XCHW      AX,BC
   \   0057   72             MOV       C,A
   \   0058   60             MOV       A,X
   \   0059   A000           MOV       X,#0
   \   005B   9A....         CALL      ?L_AND_L03
   \   005E   9A....         CALL      ?L_IOR_L03
   \   0061   99..           MOVW      S:LIBPcfCipheredData,AX
   \   0063   E2             XCHW      AX,BC
   \   0064   99..           MOVW      S:LIBPcfCipheredData+2,AX
    469          
    470              return ((tTrpCommand) LIBPcfCipheredData);
   \   0066   C2             MOVW      AX,BC
   \   0067   B4             POP       DE
   \   0068   B2             POP       BC
   \   0069   AF             RET       
   \   006A                  REQUIRE ?CL78K_V4_6_L00
    471          }
    472          
    473          //=============================================================================
    474          //  DESCRIPTION : Reverse Byte Order in U32
    475          //  
    476          //  PARAMETERS (Type,Name,Min,Max) : 
    477          //
    478          //  RETURN VALUE :   none
    479          // 
    480          //  DESIGN INFORMATION :   refer to Detailed Design Document
    481          //=============================================================================

   \                                 In  segment CODE, align 1, keep-with-next
    482          static U32 U32ReverseByteOrder(const U32 u32TargetP)
   \                     U32ReverseByteOrder:
    483          {
   \   0000                  ; * Stack frame (at entry) *
   \   0000                  ; Param size: 0
   \   0000   B3             PUSH      BC
   \   0001   B1             PUSH      AX
   \   0002                  ; Total Auto size: 4
    484              return    (((U32)(u32TargetP) >> cShift24) & cMaskByte1)
    485                      | (((U32)(u32TargetP) >> cShift8)  & cMaskByte2)
    486                      | (((U32)(u32TargetP) << cShift8)  & cMaskByte3)
    487                      | (((U32)(u32TargetP) << cShift24) & cMaskByte4);
   \   0002   891C           MOVW      AX,SP
   \   0004   D6             MOVW      HL,AX
   \   0005   87             MOV       A,[HL]
   \   0006   73             MOV       B,A
   \   0007   100000         MOVW      AX,#0
   \   000A   72             MOV       C,A
   \   000B   B3             PUSH      BC
   \   000C   B1             PUSH      AX
   \   000D   A0FF           MOV       X,#255
   \   000F   B1             PUSH      AX
   \   0010   70             MOV       X,A
   \   0011   B1             PUSH      AX
   \   0012   AE02           MOV       A,[HL+0x02]
   \   0014   72             MOV       C,A
   \   0015   AE03           MOV       A,[HL+0x03]
   \   0017   73             MOV       B,A
   \   0018   87             MOV       A,[HL]
   \   0019   70             MOV       X,A
   \   001A   AE01           MOV       A,[HL+0x01]
   \   001C   E2             XCHW      AX,BC
   \   001D   60             MOV       A,X
   \   001E   E2             XCHW      AX,BC
   \   001F   72             MOV       C,A
   \   0020   60             MOV       A,X
   \   0021   A000           MOV       X,#0
   \   0023   9A....         CALL      ?L_AND_L03
   \   0026   B3             PUSH      BC
   \   0027   B1             PUSH      AX
   \   0028   B1             PUSH      AX
   \   0029   A1FF           MOV       A,#255
   \   002B   B1             PUSH      AX
   \   002C   AE02           MOV       A,[HL+0x02]
   \   002E   72             MOV       C,A
   \   002F   AE03           MOV       A,[HL+0x03]
   \   0031   73             MOV       B,A
   \   0032   AE01           MOV       A,[HL+0x01]
   \   0034   70             MOV       X,A
   \   0035   62             MOV       A,C
   \   0036   E2             XCHW      AX,BC
   \   0037   70             MOV       X,A
   \   0038   A100           MOV       A,#0
   \   003A   E2             XCHW      AX,BC
   \   003B   9A....         CALL      ?L_AND_L03
   \   003E   B3             PUSH      BC
   \   003F   B1             PUSH      AX
   \   0040   AE03           MOV       A,[HL+0x03]
   \   0042   70             MOV       X,A
   \   0043   A100           MOV       A,#0
   \   0045   9A....         CALL      ?L_IOR_L03
   \   0048   9A....         CALL      ?L_IOR_L03
   \   004B   9A....         CALL      ?L_IOR_L03
   \   004E   B6             POP       HL
   \   004F   B6             POP       HL
   \   0050   AF             RET       
   \   0051                  REQUIRE ?CL78K_V4_6_L00
    488          }
    489          
    490          //=============================================================================
    491          //  DESCRIPTION : Indicate the key frequency for diagnostic services
    492          //  
    493          //  PARAMETERS (Type,Name,Min,Max) :  none
    494          //
    495          //  RETURN VALUE :   none
    496          // 
    497          //  DESIGN INFORMATION :   refer to Detailed Design Document
    498          //=============================================================================

   \                                 In  segment BCODE, align 1, keep-with-next
    499          static MEM_TYPE void SignalCurrentKeyFrequency(void)
   \                     SignalCurrentKeyFrequency:
    500          {
   \   0000                  ; * Stack frame (at entry) *
   \   0000                  ; Param size: 0
   \   0000                  ; Total Auto size: 0
    501              switch (DatTrpExportData.FrequencyOfPresentKey)
   \   0000   8E....         MOV       A,DatTrpExportData+39
   \   0003   4D00           CMP       A,#0
   \   0005   AD11           BZ        ??DATTrpPage3InvertedDataReceivedOK_Static_14
   \   0007   4D10           CMP       A,#16
   \   0009   AD05           BZ        ??DATTrpPage3InvertedDataReceivedOK_Static_15
   \   000B   4D30           CMP       A,#48
   \   000D   AD05           BZ        ??DATTrpPage3InvertedDataReceivedOK_Static_16
   \   000F   AF             RET       
    502              {
    503                  case cDATTrpKey315Mhz:
    504                  DatTrpExportData.DiagKeyFrequency = cDATKeyFrequency315Mhz;
   \                     ??DATTrpPage3InvertedDataReceivedOK_Static_15:
   \   0010   A107           MOV       A,#7
   \   0012   FA06           BR        ??DATTrpPage3InvertedDataReceivedOK_Static_17
    505                  break;
    506          
    507                  case cDATTrpKey315MhzSmall:
    508                  DatTrpExportData.DiagKeyFrequency = cDATKeyFrequency315MhzSmall;
   \                     ??DATTrpPage3InvertedDataReceivedOK_Static_16:
   \   0014   A105           MOV       A,#5
   \   0016   FA02           BR        ??DATTrpPage3InvertedDataReceivedOK_Static_17
    509                  break;
    510          
    511                  case cDATTrpKey433Mhz:
    512                  DatTrpExportData.DiagKeyFrequency = cDATKeyFrequency433Mhz;
   \                     ??DATTrpPage3InvertedDataReceivedOK_Static_14:
   \   0018   A106           MOV       A,#6
   \                     ??DATTrpPage3InvertedDataReceivedOK_Static_17:
   \   001A   16....         MOVW      HL,#DatTrpExportData+40
   \   001D   97             MOV       [HL],A
    513                  break;
    514          
    515                  //CCOV: amanevd: Cannot be covered because this default case rises explicit assert
    516                  default:
    517                  mLIBassert(cFalse);
    518                  break;
    519              }
    520          }
   \   001E   AF             RET       
   \   001F                  REQUIRE ?CL78K_V4_6_L00
    521          
    522          //=============================================================================
    523          //============================ EXPORTED FUNCTIONS =============================
    524          //=============================================================================
    525          
    526          //*****************************************************************************
    527          //  DESCRIPTION         : Component initialization.
    528          //
    529          //  PARAMETERS          : None
    530          //  (Type,Name,Min,Max) 
    531          //
    532          //  RETURN VALUE        : None
    533          //
    534          //  DESIGN INFORMATION  : Refer to Detailed Design Document
    535          //
    536          //*****************************************************************************

   \                                 In  segment CODE, align 1, keep-with-next
    537          void DATTrpInit(void)
   \                     DATTrpInit:
    538          {
   \   0000                  ; * Stack frame (at entry) *
   \   0000                  ; Param size: 0
   \   0000   B5             PUSH      DE
   \   0001                  ; Total Auto size: 0
    539          #ifdef X90_PROJECT
    540              DATTrpInit_Static();
   \   0001   16....         MOVW      HL,#LWRD(DATTrpInit_Static)
   \   0004   A4..           MOV       E,#BYTE3(DATTrpInit_Static)
   \   0006   ..             CALLT     [__T_?FAR_CALL_L07]
    541          }
   \   0007   B4             POP       DE
   \   0008   AF             RET       
   \   0009                  REQUIRE ?CL78K_V4_6_L00
    542          #pragma optimize=no_inline

   \                                 In  segment BCODE, align 1, keep-with-next
    543          static MEM_TYPE void DATTrpInit_Static(void)
   \                     DATTrpInit_Static:
    544          {
   \   0000                  ; * Stack frame (at entry) *
   \   0000                  ; Param size: 0
   \   0000                  ; Total Auto size: 0
    545          #endif
    546          
    547          #ifndef X90_PROJECT
    548              // DatTrpExportData and  DatTrpLocalData are placed in zero initialized RAM
    549          
    550              DatTrpExportData.ActiveTestMode                     = 0;
    551              DatTrpExportData.AuthentInLearningMode              = 0;
    552              DatTrpExportData.WriteSecretKeyHigh                 = 0;
    553          
    554              DatTrpExportData.IdentifierOfPresentKeyIsReceived   = 0;
    555              DatTrpExportData.IdentifierOfPresentKeyIsValid      = 0;
    556              DatTrpExportData.ResponseToChallengeIsPresent       = 0;
    557              DatTrpExportData.ResponseToChallengeIsValid         = 0;
    558              DatTrpExportData.PresentKeyLocked                   = 0;
    559              DatTrpExportData.KeyWithRF						    = 0;
    560              DatTrpExportData.KeyStandard					    = 0;
    561              DatTrpExportData.FrequencyOfPresentKey              = 0;
    562              DatTrpExportData.DiagKeyFrequency                   = 0;
    563              DatTrpExportData.IdentifierOfPresentKey             = 0;
    564              DatTrpExportData.DataRead                           = 0;
    565              DatTrpExportData.ResynchronizationValue             = 0;
    566              DatTrpExportData.VirginKeyAuthentOk                 = 0;
    567              DatTrpExportData.KeyLearningElapsed                 = 0;
    568              DatTrpExportData.WriteAccessWritingError            = 0;
    569              DatTrpExportData.WriteAccessReadingError            = 0;
    570              DatTrpExportData.AuthentTryCounter                  = 0;
    571          
    572              DatTrpLocalData.u8AuthentLocalCounter   = 0;
    573              DatTrpLocalData.bStopAuthentService = 0;
    574              DatTrpLocalData.bDiagnosticRunning  = 0;
    575          
    576          #endif
    577          
    578              DatTrpExportData.IndexOfKeyRecognized               = cDATTrpInvalidKeyIndex;
   \   0000   A104           MOV       A,#4
   \   0002   16....         MOVW      HL,#DatTrpExportData+41
   \   0005   97             MOV       [HL],A
    579          
    580              DatTrpExportData.AuthenticationState    = cDATTrpServiceNotStarted;
   \   0006   A100           MOV       A,#0
   \   0008   16....         MOVW      HL,#DatTrpExportData+44
   \   000B   97             MOV       [HL],A
    581              DatTrpExportData.WakeUpControlState     = cDATTrpServiceNotStarted;
   \   000C   86             INCW      HL
   \   000D   97             MOV       [HL],A
    582              DatTrpExportData.SleepControlState      = cDATTrpServiceNotStarted;
   \   000E   86             INCW      HL
   \   000F   97             MOV       [HL],A
    583              DatTrpExportData.StopControlState       = cDATTrpServiceNotStarted;
   \   0010   86             INCW      HL
   \   0011   97             MOV       [HL],A
    584              DatTrpExportData.WriteAccessState       = cDATTrpServiceNotStarted;
   \   0012   86             INCW      HL
   \   0013   97             MOV       [HL],A
    585              DatTrpExportData.ResynchronizationState = cDATTrpServiceNotStarted;
   \   0014   86             INCW      HL
   \   0015   97             MOV       [HL],A
    586              DatTrpExportData.LastVerlogStatus       = cDATTrpVerlogOff;
   \   0016   16....         MOVW      HL,#DatTrpExportData+42
   \   0019   97             MOV       [HL],A
    587          
    588              mClearFlagImmoAntAnswerReceived();
    589              mClearFlagAnswerReceivedOK();
   \   001A   8E....         MOV       A,DatTrpLocalData+30
   \   001D   5DFC           AND       A,#252
   \   001F   9E....         MOV       DatTrpLocalData+30,A
    590          
    591              //  Explicitly put the antena in sleep mode on system startup
    592              LDBControl(cLDBChannelTrp, cLDBTrpSleep);
   \   0022   A101           MOV       A,#1
   \   0024                  REQUIRE ?CL78K_V4_6_L00
   \   0024                  REQUIRE ?Subroutine4
   \   0024                  ; // Fall through to label ?Subroutine4
    593          }

   \                                 In  segment BCODE, align 1, keep-with-next
   \                     ?Subroutine4:
   \   0000   16....         MOVW      HL,#LWRD(LDBTrpControl)
   \   0003   A4..           MOV       E,#BYTE3(LDBTrpControl)
   \   0005   ..             CALLT     [__T_?FAR_CALL_L07]
   \   0006   AF             RET       
   \   0007                  REQUIRE ?CL78K_V4_6_L00
    594          //*****************************************************************************
    595          //  DESCRIPTION         : Start an authentication service.
    596          //
    597          //  PARAMETERS          : None
    598          //  (Type,Name,Min,Max) 
    599          //
    600          //  RETURN VALUE        : None
    601          //
    602          //  DESIGN INFORMATION  : Refer to Detailed Design Document
    603          //
    604          //*****************************************************************************

   \                                 In  segment CODE, align 1, keep-with-next
    605          void DATTrpStartAuthenticationService(void)
   \                     DATTrpStartAuthenticationService:
    606          {
   \   0000                  ; * Stack frame (at entry) *
   \   0000                  ; Param size: 0
   \   0000   B5             PUSH      DE
   \   0001                  ; Total Auto size: 0
    607          #ifdef X90_PROJECT
    608              DATTrpStartAuthenticationService_Static();
   \   0001   16....         MOVW      HL,#LWRD(DATTrpStartAuthenticationService_Static)
   \   0004   A4..           MOV       E,#BYTE3(DATTrpStartAuthenticationService_Static)
   \   0006   ..             CALLT     [__T_?FAR_CALL_L07]
    609          }
   \   0007   B4             POP       DE
   \   0008   AF             RET       
   \   0009                  REQUIRE ?CL78K_V4_6_L00
    610          #pragma optimize=no_inline

   \                                 In  segment BCODE, align 1, keep-with-next
    611          static MEM_TYPE void DATTrpStartAuthenticationService_Static(void)
   \                     DATTrpStartAuthenticationService_Static:
    612          {
   \   0000                  ; * Stack frame (at entry) *
   \   0000                  ; Param size: 0
   \   0000                  ; Total Auto size: 0
    613          #endif
    614          
    615              //-----------------------------------//
    616              // Clear authentication output datas
    617              //-----------------------------------//
    618              DatTrpExportData.IdentifierOfPresentKeyIsReceived = 0;
    619              DatTrpExportData.IdentifierOfPresentKeyIsValid    = 0;
    620              DatTrpExportData.ResponseToChallengeIsPresent     = 0;
   \   0000   8E....         MOV       A,DatTrpExportData+50
   \   0003   5D1F           AND       A,#31
   \   0005   9E....         MOV       DatTrpExportData+50,A
    621              DatTrpExportData.ResponseToChallengeIsValid       = 0;
    622              DatTrpExportData.PresentKeyLocked                 = 0;
    623              DatTrpExportData.KeyWithRF                        = 0;
   \   0008   8E....         MOV       A,DatTrpExportData+51
   \   000B   5DF8           AND       A,#248
   \   000D   9E....         MOV       DatTrpExportData+51,A
    624              DatTrpExportData.FrequencyOfPresentKey            = 0;
   \   0010   A100           MOV       A,#0
   \   0012   16....         MOVW      HL,#DatTrpExportData+39
   \   0015   97             MOV       [HL],A
    625              DatTrpExportData.IdentifierOfPresentKey           = 0;
   \   0016   70             MOV       X,A
   \   0017   03....         MOVW      DatTrpExportData+14,AX
   \   001A   03....         MOVW      DatTrpExportData+12,AX
    626              DatTrpExportData.IndexOfKeyRecognized             = cDATTrpInvalidKeyIndex;
   \   001D   A104           MOV       A,#4
   \   001F   16....         MOVW      HL,#DatTrpExportData+41
   \   0022   97             MOV       [HL],A
    627              DatTrpExportData.VirginKeyAuthentOk               = 0;
   \   0023   A101           MOV       A,#1
   \   0025   16....         MOVW      HL,#DatTrpExportData+50
   \   0028   71B3           CLR1      [HL].3
    628          
    629              DatTrpExportData.AuthenticationState    = cDATTrpServiceInProgress;
   \   002A   16....         MOVW      HL,#DatTrpExportData+44
   \   002D   97             MOV       [HL],A
    630              DatTrpExportData.AuthentTryCounter      = 0;
   \   002E   A100           MOV       A,#0
   \   0030   16....         MOVW      HL,#DatTrpExportData+43
   \   0033   97             MOV       [HL],A
    631              DatTrpLocalData.u8AuthentLocalCounter   = 0;
   \   0034   16....         MOVW      HL,#DatTrpLocalData+32
   \   0037   97             MOV       [HL],A
    632          
    633              TOSStartTimer(&DatTrpLocalData.AuthenticationTimeOut);
   \   0038   10....         MOVW      AX,#DatTrpLocalData+16
   \   003B   ..             CALLT     [__T_TOSStartTimer]
    634          
    635              TOSSeqActivateGraph(cTOSSeqGraphIdDATTrpAuthentication);
   \   003C   A101           MOV       A,#1
   \   003E   ..             CALLT     [__T_TOSSeqActivateGraph]
    636          }
   \   003F   AF             RET       
   \   0040                  REQUIRE ?CL78K_V4_6_L00
    637          //*****************************************************************************
    638          //  DESCRIPTION         : Start a DAT_TRP control.
    639          //
    640          //  PARAMETERS          : tCtrl Ctrl = cDATTrpWakeUp, cDATTrpSleep, cDATTrpStop,
    641          //  (Type,Name,Min,Max)                cDATTrpAuthenticate, cDATTrpWritePage,
    642          //                                     cDATTrpReadPage, cDATTrpResynchronize
    643          //
    644          //  RETURN VALUE        : None
    645          //
    646          //  DESIGN INFORMATION  : Refer to Detailed Design Document
    647          //
    648          //*****************************************************************************

   \                                 In  segment CODE, align 1, keep-with-next
    649          CALLT_TYPE void DATTrpControl(const tCtrl Ctrl)
   \                     DATTrpControl:
    650          {
   \   0000                  ; * Stack frame (at entry) *
   \   0000                  ; Param size: 0
   \   0000   B5             PUSH      DE
   \   0001                  ; Total Auto size: 0
    651          #ifdef X90_PROJECT
    652              DATTrpControl_Static(Ctrl);
   \   0001   16....         MOVW      HL,#LWRD(DATTrpControl_Static)
   \   0004   A4..           MOV       E,#BYTE3(DATTrpControl_Static)
   \   0006   ..             CALLT     [__T_?FAR_CALL_L07]
    653          }
   \   0007   B4             POP       DE
   \   0008   AF             RET       
   \   0009                  REQUIRE ?CL78K_V4_6_L00
    654          #pragma optimize=no_inline

   \                                 In  segment BCODE, align 1, keep-with-next
    655          static MEM_TYPE void DATTrpControl_Static(const tCtrl Ctrl)
   \                     DATTrpControl_Static:
    656          {
   \   0000                  ; * Stack frame (at entry) *
   \   0000                  ; Param size: 0
   \   0000   B3             PUSH      BC
   \   0001                  ; Total Auto size: 0
    657          #endif
    658              switch (Ctrl)
   \   0001   4D00           CMP       A,#0
   \   0003   AD46           BZ        ??DATTrpPage3InvertedDataReceivedOK_Static_18
   \   0005   4D01           CMP       A,#1
   \   0007   AD6D           BZ        ??DATTrpPage3InvertedDataReceivedOK_Static_19
   \   0009   4D02           CMP       A,#2
   \   000B   BD03           BNZ       $+5
   \   000D   9B....         BR        N:??DATTrpPage3InvertedDataReceivedOK_Static_20
   \   0010   4D03           CMP       A,#3
   \   0012   BD03           BNZ       $+5
   \   0014   9B....         BR        N:??DATTrpPage3InvertedDataReceivedOK_Static_21
   \   0017   4D05           CMP       A,#5
   \   0019   BD03           BNZ       $+5
   \   001B   9B....         BR        N:??DATTrpPage3InvertedDataReceivedOK_Static_22
   \   001E   4D06           CMP       A,#6
   \   0020   BD03           BNZ       $+5
   \   0022   9B....         BR        N:??DATTrpPage3InvertedDataReceivedOK_Static_23
   \   0025   4D07           CMP       A,#7
   \   0027   BD03           BNZ       $+5
   \   0029   9B....         BR        N:??DATTrpPage3InvertedDataReceivedOK_Static_24
   \   002C   4D0B           CMP       A,#11
   \   002E   BD03           BNZ       $+5
   \   0030   9B....         BR        N:??DATTrpPage3InvertedDataReceivedOK_Static_25
   \   0033   4D0C           CMP       A,#12
   \   0035   BD03           BNZ       $+5
   \   0037   9B....         BR        N:??DATTrpPage3InvertedDataReceivedOK_Static_26
   \   003A   4D0D           CMP       A,#13
   \   003C   BD03           BNZ       $+5
   \   003E   9B....         BR        N:??DATTrpPage3InvertedDataReceivedOK_Static_27
   \   0041   4D0E           CMP       A,#14
   \   0043   BD03           BNZ       $+5
   \   0045   9B....         BR        N:??DATTrpPage3InvertedDataReceivedOK_Static_28
   \   0048   9B....         BR        N:??DATTrpPage3InvertedDataReceivedOK_Static_29
    659              {
    660                  case cDATTrpWakeUp:
    661          
    662                  if(     (cFalse == mDATRead(U1Bit, DO_DATA_IMMOBILIZERProtection, Default))
    663                      &&  (cFalse == DatTrpLocalData.bDiagnosticRunning)
    664                    )
   \                     ??DATTrpPage3InvertedDataReceivedOK_Static_18:
   \   004B   8E....         MOV       A,bDO_DATA_IMMOBILIZERProtected
   \   004E   4D00           CMP       A,#0
   \   0050   BD1B           BNZ       ??DATTrpPage3InvertedDataReceivedOK_Static_30
   \   0052   8E....         MOV       A,DatTrpLocalData+38
   \   0055   4D00           CMP       A,#0
   \   0057   BD14           BNZ       ??DATTrpPage3InvertedDataReceivedOK_Static_30
    665                  {
    666                      DatTrpExportData.WakeUpControlState = cDATTrpServiceInProgress;
   \   0059   A101           MOV       A,#1
   \   005B   16....         MOVW      HL,#DatTrpExportData+45
   \   005E   97             MOV       [HL],A
    667                      mMarkTrpOutActive();
   \   005F   9E....         MOV       u8DATTrpOutState,A
    668                      LDBControl(cLDBChannelTrp, cLDBTrpWakeUp);
   \   0062   A100           MOV       A,#0
   \                     ??DATTrpControl_Static_0:
   \   0064   16....         MOVW      HL,#LWRD(LDBTrpControl)
   \   0067   A4..           MOV       E,#BYTE3(LDBTrpControl)
   \   0069   ..             CALLT     [__T_?FAR_CALL_L07]
   \   006A   9B....         BR        N:??DATTrpPage3InvertedDataReceivedOK_Static_29
    669                  }
    670                  else
    671                  {
    672                      DatTrpExportData.WakeUpControlState = cDATTrpServiceNotSuccessful;
   \                     ??DATTrpPage3InvertedDataReceivedOK_Static_30:
   \   006D   A103           MOV       A,#3
   \   006F   16....         MOVW      HL,#DatTrpExportData+45
   \                     ??DATTrpControl_Static_1:
   \   0072   97             MOV       [HL],A
   \   0073   9B....         BR        N:??DATTrpPage3InvertedDataReceivedOK_Static_29
    673                  }
    674                  break;
    675          
    676                  case cDATTrpSleep:
    677          
    678                  if(     (cFalse == mDATRead(U1Bit, DO_DATA_IMMOBILIZERProtection, Default))
    679                      &&  (cFalse == DatTrpLocalData.bDiagnosticRunning)
    680                    )
   \                     ??DATTrpPage3InvertedDataReceivedOK_Static_19:
   \   0076   8E....         MOV       A,bDO_DATA_IMMOBILIZERProtected
   \   0079   4D00           CMP       A,#0
   \   007B   BD14           BNZ       ??DATTrpPage3InvertedDataReceivedOK_Static_31
   \   007D   8E....         MOV       A,DatTrpLocalData+38
   \   0080   4D00           CMP       A,#0
   \   0082   BD0D           BNZ       ??DATTrpPage3InvertedDataReceivedOK_Static_31
    681                  {
    682                      // Prevention of simultaneous access of antena by immo or exm components
    683                      // like:    if (DatTrpLocalData.CipheredCommunication == cTrue)                
    684                      DatTrpExportData.SleepControlState = cDATTrpServiceSuccessful;
   \   0084   A102           MOV       A,#2
   \   0086   16....         MOVW      HL,#DatTrpExportData+46
   \   0089   97             MOV       [HL],A
    685                      mMarkTrpOutActive();
   \   008A   A101           MOV       A,#1
   \   008C   9E....         MOV       u8DATTrpOutState,A
    686                      LDBControl(cLDBChannelTrp, cLDBTrpSleep);
   \   008F   FAD3           BR        ??DATTrpControl_Static_0
    687                  }
    688                  else
    689                  {
    690                      DatTrpExportData.SleepControlState = cDATTrpServiceNotSuccessful;
   \                     ??DATTrpPage3InvertedDataReceivedOK_Static_31:
   \   0091   A103           MOV       A,#3
   \   0093   16....         MOVW      HL,#DatTrpExportData+46
   \   0096   FADA           BR        ??DATTrpControl_Static_1
    691                  }
    692          
    693                  break;
    694          
    695                  case cDATTrpStop:
    696                  {
    697                      DatTrpExportData.StopControlState = cDATTrpServiceInProgress;
   \                     ??DATTrpPage3InvertedDataReceivedOK_Static_20:
   \   0098   A101           MOV       A,#1
   \   009A   16....         MOVW      HL,#DatTrpExportData+47
   \   009D   97             MOV       [HL],A
    698                      LDBControl(cLDBChannelTrp, cLDBTrpStop);
   \   009E   A102           MOV       A,#2
   \   00A0   16....         MOVW      HL,#LWRD(LDBTrpControl)
   \   00A3   A4..           MOV       E,#BYTE3(LDBTrpControl)
   \   00A5   ..             CALLT     [__T_?FAR_CALL_L07]
    699                      mMarkTrpOutInactive();
   \   00A6   A100           MOV       A,#0
   \   00A8   9E....         MOV       u8DATTrpOutState,A
   \   00AB   9B....         BR        N:??DATTrpPage3InvertedDataReceivedOK_Static_29
    700                  }
    701                  break;
    702          
    703                  case cDATTrpAuthenticate:
    704          
    705                  if(     (cFalse == mDATRead(U1Bit, DO_DATA_IMMOBILIZERProtection, Default))
    706                      &&  (cDATTrpServiceInProgress != DatTrpExportData.WriteAccessState)
    707                      &&  (cFalse == DatTrpLocalData.bDiagnosticRunning)
    708                    )
   \                     ??DATTrpPage3InvertedDataReceivedOK_Static_21:
   \   00AE   8E....         MOV       A,bDO_DATA_IMMOBILIZERProtected
   \   00B1   4D00           CMP       A,#0
   \   00B3   BD24           BNZ       ??DATTrpPage3InvertedDataReceivedOK_Static_32
   \   00B5   8E....         MOV       A,DatTrpExportData+48
   \   00B8   51             DEC       A
   \   00B9   AD1E           BZ        ??DATTrpPage3InvertedDataReceivedOK_Static_32
   \   00BB   8E....         MOV       A,DatTrpLocalData+38
   \   00BE   4D00           CMP       A,#0
   \   00C0   BD17           BNZ       ??DATTrpPage3InvertedDataReceivedOK_Static_32
    709                  {
    710                      DatTrpExportData.AuthenticationState = cDATTrpServiceInProgress;
   \   00C2   A101           MOV       A,#1
   \   00C4   16....         MOVW      HL,#DatTrpExportData+44
   \   00C7   97             MOV       [HL],A
    711                      DatTrpLocalData.bStopAuthentService = 0;
   \   00C8   A100           MOV       A,#0
   \   00CA   16....         MOVW      HL,#DatTrpLocalData+37
   \   00CD   97             MOV       [HL],A
    712                      mMarkTrpOutActive();
   \   00CE   A101           MOV       A,#1
   \   00D0   9E....         MOV       u8DATTrpOutState,A
    713                      DATTrpStartAuthenticationService();
   \   00D3   9A....         CALL      DATTrpStartAuthenticationService
   \   00D6   9B....         BR        N:??DATTrpPage3InvertedDataReceivedOK_Static_29
    714                  }
    715                  else
    716                  {
    717                      DatTrpExportData.AuthenticationState = cDATTrpServiceNotSuccessful;
   \                     ??DATTrpPage3InvertedDataReceivedOK_Static_32:
   \   00D9   A103           MOV       A,#3
   \   00DB   16....         MOVW      HL,#DatTrpExportData+44
   \   00DE   FA92           BR        ??DATTrpControl_Static_1
    718                  }
    719          
    720                  break;
    721          
    722                  case cDATTrpWritePage:
    723          
    724                  if(     (cFalse == mDATRead(U1Bit, DO_DATA_IMMOBILIZERProtection, Default))
    725                      &&  (cFalse == DatTrpLocalData.bDiagnosticRunning)
    726                    )
   \                     ??DATTrpPage3InvertedDataReceivedOK_Static_22:
   \   00E0   8E....         MOV       A,bDO_DATA_IMMOBILIZERProtected
   \   00E3   4D00           CMP       A,#0
   \   00E5   BD3C           BNZ       ??DATTrpPage3InvertedDataReceivedOK_Static_33
   \   00E7   8E....         MOV       A,DatTrpLocalData+38
   \   00EA   4D00           CMP       A,#0
   \   00EC   BD35           BNZ       ??DATTrpPage3InvertedDataReceivedOK_Static_33
    727                  {
    728                      DatTrpLocalData.u8ReadOrWriteNumberOfTry = 0;
   \   00EE   A100           MOV       A,#0
   \   00F0   16....         MOVW      HL,#DatTrpLocalData+31
   \   00F3   97             MOV       [HL],A
    729                      DatTrpExportData.WriteAccessWritingError = 0;
    730                      DatTrpExportData.WriteAccessReadingError = 0;
   \   00F4   8E....         MOV       A,DatTrpExportData+51
   \   00F7   5D9F           AND       A,#159
   \   00F9   9E....         MOV       DatTrpExportData+51,A
    731                      DatTrpLocalData.WritingCommand           = ComputeCommandWithPageNumber(DatTrpExportData.PageNumber, cLDBTrpWrPage);
   \   00FC   121000         MOVW      BC,#16
   \   00FF   8E....         MOV       A,DatTrpExportData+38
   \   0102   9A....         CALL      ComputeCommandWithPageNumber
   \   0105   03....         MOVW      DatTrpLocalData+22,AX
    732                      DatTrpLocalData.ReadingCommand           = ComputeCommandWithPageNumber(DatTrpExportData.PageNumber, cLDBTrpRdPage);
   \   0108   121800         MOVW      BC,#24
   \   010B   8E....         MOV       A,DatTrpExportData+38
   \   010E   9A....         CALL      ComputeCommandWithPageNumber
   \   0111   03....         MOVW      DatTrpLocalData+24,AX
    733                      DatTrpExportData.WriteAccessState   = cDATTrpServiceInProgress;
   \   0114   A101           MOV       A,#1
   \   0116   16....         MOVW      HL,#DatTrpExportData+48
   \   0119   97             MOV       [HL],A
    734                      mMarkTrpOutActive();
   \   011A   9E....         MOV       u8DATTrpOutState,A
    735                      TOSSeqActivateGraph(cTOSSeqGraphIdDATTrpWriteAccess);
   \   011D   A11E           MOV       A,#30
   \   011F   ..             CALLT     [__T_TOSSeqActivateGraph]
   \   0120   9B....         BR        N:??DATTrpPage3InvertedDataReceivedOK_Static_29
    736                  }
    737                  else
    738                  {
    739                      DatTrpExportData.WriteAccessState   = cDATTrpServiceNotSuccessful;
   \                     ??DATTrpPage3InvertedDataReceivedOK_Static_33:
   \   0123   A103           MOV       A,#3
   \   0125   16....         MOVW      HL,#DatTrpExportData+48
   \   0128   9B....         BR        N:??DATTrpControl_Static_1
    740                  }
    741          
    742                  break;
    743          
    744                  case cDATTrpResynchronize:
    745          
    746                  if(     (cFalse == mDATRead(U1Bit, DO_DATA_IMMOBILIZERProtection, Default))
    747                      &&  (cFalse == DatTrpLocalData.bDiagnosticRunning)
    748                    )
   \                     ??DATTrpPage3InvertedDataReceivedOK_Static_23:
   \   012B   8E....         MOV       A,bDO_DATA_IMMOBILIZERProtected
   \   012E   4D00           CMP       A,#0
   \   0130   BD3F           BNZ       ??DATTrpPage3InvertedDataReceivedOK_Static_34
   \   0132   8E....         MOV       A,DatTrpLocalData+38
   \   0135   4D00           CMP       A,#0
   \   0137   BD38           BNZ       ??DATTrpPage3InvertedDataReceivedOK_Static_34
    749                  {
    750                      DatTrpLocalData.u8ReadOrWriteNumberOfTry     = 0;
   \   0139   A100           MOV       A,#0
   \   013B   16....         MOVW      HL,#DatTrpLocalData+31
   \   013E   97             MOV       [HL],A
    751                      DatTrpExportData.ResynchronizationValue = LIBCalculateRandomNb(TOSClock);
   \   013F   02....         MOVW      AX,TOSClock
   \   0142   120000         MOVW      BC,#0
   \   0145   9A....         CALL      LIBCalculateRandomNb
   \   0148   03....         MOVW      DatTrpExportData+20,AX
   \   014B   C2             MOVW      AX,BC
   \   014C   03....         MOVW      DatTrpExportData+22,AX
    752                      DatTrpExportData.DataToWrite            = DatTrpExportData.ResynchronizationValue;
   \   014F   03....         MOVW      DatTrpExportData+10,AX
   \   0152   02....         MOVW      AX,DatTrpExportData+20
   \   0155   03....         MOVW      DatTrpExportData+8,AX
    753                      DatTrpLocalData.WritingCommand               = cLDBTrpResync;
   \   0158   100F02         MOVW      AX,#527
   \   015B   03....         MOVW      DatTrpLocalData+22,AX
    754                      DatTrpLocalData.ReadingCommand               = cLDBTrpRdSync;
   \   015E   101701         MOVW      AX,#279
   \   0161   03....         MOVW      DatTrpLocalData+24,AX
    755          
    756                      DatTrpExportData.ResynchronizationState = cDATTrpServiceInProgress;
   \   0164   16....         MOVW      HL,#DatTrpExportData+49
   \   0167   97             MOV       [HL],A
    757                      mMarkTrpOutActive();
   \   0168   9E....         MOV       u8DATTrpOutState,A
    758                      TOSSeqActivateGraph(cTOSSeqGraphIdDATTrpResynchronization);
   \   016B   A11F           MOV       A,#31
   \   016D   ..             CALLT     [__T_TOSSeqActivateGraph]
   \   016E   9B....         BR        N:??DATTrpPage3InvertedDataReceivedOK_Static_29
    759                  }
    760                  else
    761                  {
    762                      DatTrpExportData.ResynchronizationState = cDATTrpServiceNotSuccessful;
   \                     ??DATTrpPage3InvertedDataReceivedOK_Static_34:
   \   0171   A103           MOV       A,#3
   \   0173   16....         MOVW      HL,#DatTrpExportData+49
   \   0176   9B....         BR        N:??DATTrpControl_Static_1
    763                  }
    764                  break;
    765          
    766                  case cDATTrpInitDiagInfo:
    767                  {
    768                      DatTrpExportData.IdentifierOfPresentKeyIsReceived  = 0;
    769                      DatTrpExportData.IdentifierOfPresentKeyIsValid     = 0;
    770                      DatTrpExportData.ResponseToChallengeIsPresent      = 0;
   \                     ??DATTrpPage3InvertedDataReceivedOK_Static_24:
   \   0179   8E....         MOV       A,DatTrpExportData+50
   \   017C   5D1F           AND       A,#31
   \   017E   9E....         MOV       DatTrpExportData+50,A
    771                      DatTrpExportData.ResponseToChallengeIsValid        = 0;
    772                      DatTrpExportData.PresentKeyLocked                  = 0;
    773                      DatTrpExportData.KeyWithRF                         = 0;
    774                      DatTrpExportData.KeyStandard     	               = 0;
   \   0181   8E....         MOV       A,DatTrpExportData+51
   \   0184   5DF0           AND       A,#240
   \   0186   9E....         MOV       DatTrpExportData+51,A
    775                      DatTrpExportData.FrequencyOfPresentKey             = 0;
   \   0189   A100           MOV       A,#0
   \   018B   16....         MOVW      HL,#DatTrpExportData+39
   \   018E   97             MOV       [HL],A
    776                      DatTrpExportData.DiagKeyFrequency                  = cDATKeyInvalidFrequency;
   \   018F   86             INCW      HL
   \   0190   97             MOV       [HL],A
    777                      DatTrpExportData.IdentifierOfPresentKey            = 0;
   \   0191   70             MOV       X,A
   \   0192   03....         MOVW      DatTrpExportData+14,AX
   \   0195   03....         MOVW      DatTrpExportData+12,AX
    778                      DatTrpExportData.IndexOfKeyRecognized              = cDATTrpInvalidKeyIndex;
   \   0198   A104           MOV       A,#4
   \   019A   86             INCW      HL
   \   019B   97             MOV       [HL],A
    779                      DatTrpExportData.DataRead                          = 0;
   \   019C   A100           MOV       A,#0
   \   019E   03....         MOVW      DatTrpExportData+18,AX
   \   01A1   03....         MOVW      DatTrpExportData+16,AX
    780                      DatTrpExportData.AuthenticationState               = cDATTrpServiceNotStarted;   
   \   01A4   16....         MOVW      HL,#DatTrpExportData+44
   \   01A7   97             MOV       [HL],A
    781                      DatTrpExportData.ResynchronizationValue            = 0;
   \   01A8   03....         MOVW      DatTrpExportData+22,AX
   \   01AB   03....         MOVW      DatTrpExportData+20,AX
    782                      DatTrpExportData.VirginKeyAuthentOk                = 0;
   \   01AE   16....         MOVW      HL,#DatTrpExportData+50
   \   01B1   71B3           CLR1      [HL].3
   \   01B3   FA56           BR        ??DATTrpPage3InvertedDataReceivedOK_Static_29
    783                  }
    784                  break;
    785          
    786                  case cDATTrpStopAuthentService:
    787                  {
    788                      DatTrpLocalData.bStopAuthentService = cTrue;
   \                     ??DATTrpPage3InvertedDataReceivedOK_Static_25:
   \   01B5   A101           MOV       A,#1
   \   01B7   16....         MOVW      HL,#DatTrpLocalData+37
   \   01BA   9B....         BR        N:??DATTrpControl_Static_1
    789                  }
    790                  break;
    791          
    792                  case cDATTrpActivateDiag:
    793                  { 
    794                      if (    (cDATTrpServiceInProgress == DatTrpExportData.WriteAccessState)
    795                           || (cDATTrpServiceInProgress == DatTrpExportData.AuthenticationState)
    796                         )
   \                     ??DATTrpPage3InvertedDataReceivedOK_Static_26:
   \   01BD   8E....         MOV       A,DatTrpExportData+48
   \   01C0   51             DEC       A
   \   01C1   AD06           BZ        ??DATTrpPage3InvertedDataReceivedOK_Static_35
   \   01C3   8E....         MOV       A,DatTrpExportData+44
   \   01C6   51             DEC       A
   \   01C7   BD08           BNZ       ??DATTrpPage3InvertedDataReceivedOK_Static_36
    797                      {
    798                          LDBControl(cLDBChannelTrp, cLDBTrpStop);
   \                     ??DATTrpPage3InvertedDataReceivedOK_Static_35:
   \   01C9   A102           MOV       A,#2
   \   01CB   16....         MOVW      HL,#LWRD(LDBTrpControl)
   \   01CE   A4..           MOV       E,#BYTE3(LDBTrpControl)
   \   01D0   ..             CALLT     [__T_?FAR_CALL_L07]
    799                      }
    800          
    801                      mMarkTrpOutInactive();
   \                     ??DATTrpPage3InvertedDataReceivedOK_Static_36:
   \   01D1   A100           MOV       A,#0
   \   01D3   9E....         MOV       u8DATTrpOutState,A
    802                      DatTrpLocalData.bDiagnosticRunning = cTrue;
   \   01D6   A101           MOV       A,#1
   \                     ??DATTrpControl_Static_2:
   \   01D8   16....         MOVW      HL,#DatTrpLocalData+38
   \   01DB   9B....         BR        N:??DATTrpControl_Static_1
    803                  }
    804                  break;
    805          
    806                  case cDATTrpDeactivateDiag:
    807                  {
    808                      DatTrpLocalData.bDiagnosticRunning = cFalse;
   \                     ??DATTrpPage3InvertedDataReceivedOK_Static_27:
   \   01DE   A100           MOV       A,#0
   \   01E0   FAF6           BR        ??DATTrpControl_Static_2
    809                  }
    810                  break;
    811          
    812                  case cDATTrpTfcDiag:
    813          
    814                  if(     (cFalse == mDATRead(U1Bit, DO_DATA_IMMOBILIZERProtection, Default))
    815                       && (cDATTrpServiceInProgress != DatTrpExportData.WriteAccessState)
    816                       && (cFalse == DatTrpLocalData.bDiagnosticRunning)
    817                    )
   \                     ??DATTrpPage3InvertedDataReceivedOK_Static_28:
   \   01E2   8E....         MOV       A,bDO_DATA_IMMOBILIZERProtected
   \   01E5   4D00           CMP       A,#0
   \   01E7   AD03           BZ        $+5
   \   01E9   9B....         BR        N:??DATTrpPage3InvertedDataReceivedOK_Static_32
   \   01EC   8E....         MOV       A,DatTrpExportData+48
   \   01EF   51             DEC       A
   \   01F0   BD03           BNZ       $+5
   \   01F2   9B....         BR        N:??DATTrpPage3InvertedDataReceivedOK_Static_32
   \   01F5   8E....         MOV       A,DatTrpLocalData+38
   \   01F8   4D00           CMP       A,#0
   \   01FA   AD03           BZ        $+5
   \   01FC   9B....         BR        N:??DATTrpPage3InvertedDataReceivedOK_Static_32
    818                  {
    819                      DatTrpExportData.AuthenticationState = cDATTrpServiceInProgress;
   \   01FF   A101           MOV       A,#1
   \   0201   16....         MOVW      HL,#DatTrpExportData+44
   \   0204   97             MOV       [HL],A
    820                      mMarkTrpOutActive();
   \   0205   9E....         MOV       u8DATTrpOutState,A
    821                      TOSSeqActivateGraph(cTOSSeqGraphIdDATTrpTfcDiag);
   \   0208   A120           MOV       A,#32
   \   020A   ..             CALLT     [__T_TOSSeqActivateGraph]
    822                  }
    823                  else
    824                  {
    825                      DatTrpExportData.AuthenticationState = cDATTrpServiceNotSuccessful;
    826                  }
    827                  break;
    828          
    829                  //CCOV: amanevd: Cannot be covered because this default case rises explicit assert
    830                  default:
    831                  {
    832                      mLIBassert(cFalse);
    833                  }
    834                  break;
    835              }
    836          }
   \                     ??DATTrpPage3InvertedDataReceivedOK_Static_29:
   \   020B   B2             POP       BC
   \   020C   AF             RET       
   \   020D                  REQUIRE ?CL78K_V4_6_L00
    837          
    838          //*****************************************************************************
    839          //  DESCRIPTION         : Update of the flags of detection of hardware defaults.
    840          //
    841          //  PARAMETERS          : tCtrl Ctrl = cLDBTrpWakeUp, cLDBTrpSleep, cLDBTrpStop
    842          //  (Type,Name,Min,Max)   tStatus Status = cLDBCorrect, cLDBError
    843          //
    844          //  RETURN VALUE        : None
    845          //
    846          //  DESIGN INFORMATION  : Refer to Detailed Design Document
    847          //
    848          //*****************************************************************************
    849          //QACJ 3227:amanevd: The function is declared without use of 'const' in standard components

   \                                 In  segment BCODE, align 1, keep-with-next
    850          MEM_TYPE void DATTrpCallBackCtrl(tCtrl Ctrl)
   \                     DATTrpCallBackCtrl:
    851          {
   \   0000                  ; * Stack frame (at entry) *
   \   0000                  ; Param size: 0
   \   0000                  ; Total Auto size: 0
   \   0000   70             MOV       X,A
    852              U8 u8TempL;
    853          
    854              mMarkTrpOutInactive();
   \   0001   A100           MOV       A,#0
   \   0003   9E....         MOV       u8DATTrpOutState,A
    855              if(cFalse != mDATRead(U1Bit, PWR_IGN, Immediate))
   \   0006   3103..5F       BF        S:DATDinInputBuffers+15.0, ??DATTrpPage3InvertedDataReceivedOK_Static_37
    856              {
    857                  switch (Ctrl)
   \   000A   60             MOV       A,X
   \   000B   4D08           CMP       A,#8
   \   000D   AD09           BZ        ??DATTrpPage3InvertedDataReceivedOK_Static_38
   \   000F   4D09           CMP       A,#9
   \   0011   AD37           BZ        ??DATTrpPage3InvertedDataReceivedOK_Static_39
   \   0013   4D0A           CMP       A,#10
   \   0015   AD48           BZ        ??DATTrpPage3InvertedDataReceivedOK_Static_40
   \   0017   AF             RET       
    858                  {
    859                      case cLDBTrpShortCircuitToBat :
    860                      mDATWrite(U1Bit, DefTrpShortCircuitToGnd, 0, Default);
   \                     ??DATTrpPage3InvertedDataReceivedOK_Static_38:
   \   0018   A100           MOV       A,#0
   \   001A   16....         MOVW      HL,#DATCmnData+12
   \   001D   97             MOV       [HL],A
    861                      mDATWrite(U1Bit, DefTrpShortCircuitToBat, 1, Default);
   \   001E   A101           MOV       A,#1
   \   0020   86             INCW      HL
   \   0021   97             MOV       [HL],A
    862                      mDATWrite(U1Bit, EEP_DefTrpToBat, 1, Default);
   \   0022   16....         MOVW      HL,#DATDbkMirrors+19
   \   0025   31E607         BT        [HL].6, ??DATTrpPage3InvertedDataReceivedOK_Static_41
   \   0028   A100           MOV       A,#0
   \   002A   71E2           SET1      [HL].6
   \   002C   9A....         CALL      DATDbkStartUpdate
    863                      if(cFalse == mDATRead(U1Bit, DO_DATA_IMMOBILIZERProtection, Default))
   \                     ??DATTrpPage3InvertedDataReceivedOK_Static_41:
   \   002F   8E....         MOV       A,bDO_DATA_IMMOBILIZERProtected
   \   0032   4D00           CMP       A,#0
   \   0034   BD0E           BNZ       ??DATTrpPage3InvertedDataReceivedOK_Static_42
    864                      {
    865                          u8TempL = mDATRead(U8Bit, EEP_CDImmo, Default);
   \   0036   8E....         MOV       A,DATDbkMirrors+18
    866                          if(u8TempL < cMaxCDImmoCounter)
   \   0039   41             INC       A
   \   003A   AD08           BZ        ??DATTrpPage3InvertedDataReceivedOK_Static_42
    867                          {
    868                              u8TempL++;
    869                              mDATWrite(U8Bit, EEP_CDImmo, u8TempL, Default);
   \   003C   9E....         MOV       DATDbkMirrors+18,A
   \   003F   A100           MOV       A,#0
   \   0041   9A....         CALL      DATDbkStartUpdate
    870                          }
    871                      }
    872                      mDATWrite(U1Bit, DO_DATA_IMMOBILIZERProtection, 1, Default);
   \                     ??DATTrpPage3InvertedDataReceivedOK_Static_42:
   \   0044   A101           MOV       A,#1
   \   0046   9E....         MOV       bDO_DATA_IMMOBILIZERProtected,A
   \   0049   AF             RET       
    873                      break;
    874          
    875                      case cLDBTrpShortCircuitToGnd :
    876                      mDATWrite(U1Bit, DefTrpShortCircuitToGnd, 1, Default);
   \                     ??DATTrpPage3InvertedDataReceivedOK_Static_39:
   \   004A   A101           MOV       A,#1
   \   004C   16....         MOVW      HL,#DATCmnData+12
   \   004F   97             MOV       [HL],A
    877                      mDATWrite(U1Bit, DefTrpShortCircuitToBat, 0, Default);
   \   0050   A100           MOV       A,#0
   \   0052   86             INCW      HL
   \   0053   97             MOV       [HL],A
    878                      mDATWrite(U1Bit, EEP_DefTrpToGnd, 1, Default);
   \   0054   16....         MOVW      HL,#DATDbkMirrors+19
   \   0057   31F60F         BT        [HL].7, ??DATTrpPage3InvertedDataReceivedOK_Static_37
   \   005A   71F2           SET1      [HL].7
   \   005C   9B....         BR        N:DATDbkStartUpdate
    879                      break;
    880          
    881                      case cLDBTrpNoError :
    882                      // Clear all error
    883                      mDATWrite(U1Bit, DefTrpShortCircuitToBat, 0, Default);
   \                     ??DATTrpPage3InvertedDataReceivedOK_Static_40:
   \   005F   A100           MOV       A,#0
   \   0061   16....         MOVW      HL,#DATCmnData+13
   \   0064   97             MOV       [HL],A
    884                      mDATWrite(U1Bit, DefTrpShortCircuitToGnd, 0, Default);
   \   0065   16....         MOVW      HL,#DATCmnData+12
   \   0068   97             MOV       [HL],A
    885                      break;
    886          
    887                      //CCOV: amanevd: Cannot be covered because this default case rises explicit assert
    888                      default :
    889                      mLIBassert(cFalse);
    890                      break;
    891                  }
    892              }
    893          }
   \                     ??DATTrpPage3InvertedDataReceivedOK_Static_37:
   \   0069   AF             RET       
   \   006A                  REQUIRE ?CL78K_V4_6_L00
    894          
    895          //*****************************************************************************
    896          //  DESCRIPTION         : Signals the end of a sending with address.
    897          //
    898          //  PARAMETERS          : tAddress Address = transponder commands
    899          //  (Type,Name,Min,Max)   tStatus Status = cLDBCorrect, cLDBError
    900          //
    901          //  RETURN VALUE        : None
    902          //
    903          //  DESIGN INFORMATION  : Refer to Detailed Design Document
    904          //
    905          //*****************************************************************************
    906          //QACJ 3227:amanevd: The function is declared without use of 'const' in standard components
    907          //QACJ 3227:amanevd: The function is declared without use of 'const' in standard components

   \                                 In  segment BCODE, align 1, keep-with-next
    908          MEM_TYPE void DATTrpCallBackTxWithAddr(tAddress Address, tStatus Status)
   \                     DATTrpCallBackTxWithAddr:
    909          {  
   \   0000                  ; * Stack frame (at entry) *
   \   0000                  ; Param size: 0
   \   0000                  ; Total Auto size: 0
   \   0000   D6             MOVW      HL,AX
    910              mLIBassert((Status == cLDBCorrect) || (Status == cLDBError));
    911          
    912              mMarkTrpOutInactive();
   \   0001   A100           MOV       A,#0
   \   0003   9E....         MOV       u8DATTrpOutState,A
    913          
    914              if (Address != cLDBTrpStartAuth)
   \   0006   67             MOV       A,H
   \   0007   EA1800         CMPW      AX,#24
   \   000A   AD0F           BZ        ??DATTrpPage3InvertedDataReceivedOK_Static_43
    915              {
    916                  mSetFlagImmoAntAnswerReceived();
   \   000C   63             MOV       A,B
   \   000D   16....         MOVW      HL,#DatTrpLocalData+30
   \   0010   7182           SET1      [HL].0
    917          
    918                  if (Status == cLDBCorrect)
   \   0012   4D00           CMP       A,#0
   \   0014   BD03           BNZ       ??DATTrpPage3InvertedDataReceivedOK_Static_44
    919                  {
    920                      mSetFlagAnswerReceivedOK();
   \   0016   7192           SET1      [HL].1
   \   0018   AF             RET       
    921                  }
    922                  else
    923                  {
    924                      mClearFlagAnswerReceivedOK();
   \                     ??DATTrpPage3InvertedDataReceivedOK_Static_44:
   \   0019   7193           CLR1      [HL].1
    925                  }
    926              }
    927              // else : in case of Start authentication service, this call back is ignored.
    928          }
   \                     ??DATTrpPage3InvertedDataReceivedOK_Static_43:
   \   001B   AF             RET       
   \   001C                  REQUIRE ?CL78K_V4_6_L00
    929          
    930          //*****************************************************************************
    931          //  DESCRIPTION         : Signals the end of a control and its status.
    932          //
    933          //  PARAMETERS          : tCtrl Ctrl = cLDBTrpWakeUp, cLDBTrpSleep, cLDBTrpStop
    934          //  (Type,Name,Min,Max)   tStatus Status = cLDBCorrect, cLDBError
    935          //
    936          //  RETURN VALUE        : None
    937          //
    938          //  DESIGN INFORMATION  : Refer to Detailed Design Document
    939          //
    940          //*****************************************************************************
    941          //QACJ 3227:amanevd: The function is declared without use of 'const' in standard components
    942          //QACJ 3227:amanevd: The function is declared without use of 'const' in standard components

   \                                 In  segment BCODE, align 1, keep-with-next
    943          MEM_TYPE void DATTrpCallBackEndCtrl(tCtrl Ctrl, tStatus Status)
   \                     DATTrpCallBackEndCtrl:
    944          {
   \   0000                  ; * Stack frame (at entry) *
   \   0000                  ; Param size: 0
   \   0000                  ; Total Auto size: 0
   \   0000   70             MOV       X,A
    945              mLIBassert((Ctrl == cLDBTrpWakeUp) || (Ctrl == cLDBTrpSleep));
    946              mLIBassert((Status == cLDBCorrect) || (Status == cLDBError));
    947          
    948              mSetFlagImmoAntAnswerReceived();
   \   0001   A100           MOV       A,#0
   \   0003   16....         MOVW      HL,#DatTrpLocalData+30
   \   0006   7182           SET1      [HL].0
    949              mMarkTrpOutInactive();
   \   0008   9E....         MOV       u8DATTrpOutState,A
    950          
    951              if (Status == cLDBCorrect)
   \   000B   63             MOV       A,B
   \   000C   4D00           CMP       A,#0
   \   000E   BD04           BNZ       ??DATTrpPage3InvertedDataReceivedOK_Static_45
    952              {
    953                  mSetFlagAnswerReceivedOK();
   \   0010   7192           SET1      [HL].1
   \   0012   FA02           BR        ??DATTrpPage3InvertedDataReceivedOK_Static_46
    954              }
    955              else
    956              {
    957                  mClearFlagAnswerReceivedOK();
   \                     ??DATTrpPage3InvertedDataReceivedOK_Static_45:
   \   0014   7193           CLR1      [HL].1
    958              }
    959          
    960              if ((Ctrl == cLDBTrpSleep) && (DatTrpExportData.SleepControlState == cDATTrpServiceInProgress))
   \                     ??DATTrpPage3InvertedDataReceivedOK_Static_46:
   \   0016   60             MOV       A,X
   \   0017   51             DEC       A
   \   0018   BD0D           BNZ       ??DATTrpPage3InvertedDataReceivedOK_Static_47
   \   001A   8E....         MOV       A,DatTrpExportData+46
   \   001D   51             DEC       A
   \   001E   BD1B           BNZ       ??DATTrpPage3InvertedDataReceivedOK_Static_48
    961              {
    962                  DatTrpExportData.SleepControlState = cDATTrpServiceSuccessful;
   \   0020   A102           MOV       A,#2
   \   0022   16....         MOVW      HL,#DatTrpExportData+46
   \   0025   FA26           BR        ??DATTrpPage3InvertedDataReceivedOK_Static_49
    963              }
    964              else 
    965              {
    966                  if ((Ctrl == cLDBTrpSleep) && (DatTrpExportData.StopControlState == cDATTrpServiceInProgress))
    967                  {
    968                      DatTrpExportData.StopControlState = cDATTrpServiceSuccessful;
    969                  }
    970                  else 
    971                  {
    972                      if (        (Ctrl == cLDBTrpWakeUp) 
    973                         &&   (DatTrpExportData.WakeUpControlState == cDATTrpServiceInProgress))
   \                     ??DATTrpPage3InvertedDataReceivedOK_Static_47:
   \   0027   60             MOV       A,X
   \   0028   4D00           CMP       A,#0
   \   002A   BD22           BNZ       ??DATTrpPage3InvertedDataReceivedOK_Static_50
   \   002C   8E....         MOV       A,DatTrpExportData+45
   \   002F   51             DEC       A
   \   0030   BD1C           BNZ       ??DATTrpPage3InvertedDataReceivedOK_Static_50
    974                      {
    975                          if(Status == cLDBCorrect)
   \   0032   63             MOV       A,B
   \   0033   4D00           CMP       A,#0
   \   0035   BD11           BNZ       ??DATTrpPage3InvertedDataReceivedOK_Static_51
    976                          {
    977                              DatTrpExportData.WakeUpControlState = cDATTrpServiceSuccessful;
   \   0037   A102           MOV       A,#2
   \   0039   FA0F           BR        ??DATTrpPage3InvertedDataReceivedOK_Static_52
    978                          }
   \                     ??DATTrpPage3InvertedDataReceivedOK_Static_48:
   \   003B   8E....         MOV       A,DatTrpExportData+47
   \   003E   51             DEC       A
   \   003F   BD0D           BNZ       ??DATTrpPage3InvertedDataReceivedOK_Static_50
   \   0041   A102           MOV       A,#2
   \   0043   16....         MOVW      HL,#DatTrpExportData+47
   \   0046   FA05           BR        ??DATTrpPage3InvertedDataReceivedOK_Static_49
    979                          else
    980                          {
    981                              DatTrpExportData.WakeUpControlState = cDATTrpServiceNotSuccessful;
   \                     ??DATTrpPage3InvertedDataReceivedOK_Static_51:
   \   0048   A103           MOV       A,#3
   \                     ??DATTrpPage3InvertedDataReceivedOK_Static_52:
   \   004A   16....         MOVW      HL,#DatTrpExportData+45
   \                     ??DATTrpPage3InvertedDataReceivedOK_Static_49:
   \   004D   97             MOV       [HL],A
    982                          }
    983                      }
    984                      else 
    985                      {
    986                      }
    987                  }
    988              }
    989          }
   \                     ??DATTrpPage3InvertedDataReceivedOK_Static_50:
   \   004E   AF             RET       
   \   004F                  REQUIRE ?CL78K_V4_6_L00
    990          
    991          //*****************************************************************************
    992          //  DESCRIPTION         : Indicate that the LDB has received data.
    993          //
    994          //  PARAMETERS          : tStatus Status = cLDBCorrect
    995          //  (Type,Name,Min,Max)   tMsg*   pMsg
    996          //
    997          //  RETURN VALUE        : None
    998          //
    999          //  DESIGN INFORMATION  : Refer to Detailed Design Document
   1000          //
   1001          //*****************************************************************************
   1002          //QACJ 3206:amanevd: The pMsg parameter is used inside 'mLIBmemcmp' macro execution in function body
   1003          //QACJ 3206:amanevd: The pMsg parameter is used inside 'mLIBmemcmp' macro execution in function body

   \                                 In  segment BCODE, align 1, keep-with-next
   1004          MEM_TYPE void DATTrpCallBackRxSpontWithoutAddr(tStatus Status, tMsg* pMsg)
   \                     DATTrpCallBackRxSpontWithoutAddr:
   1005          {
   \   0000                  ; * Stack frame (at entry) *
   \   0000                  ; Param size: 0
   \   0000                  ; Total Auto size: 0
   1006              mLIBassert(Status == cLDBCorrect);
   1007          
   1008              mMarkTrpOutInactive();
   \   0000   A100           MOV       A,#0
   \   0002   9E....         MOV       u8DATTrpOutState,A
   1009              mSetFlagImmoAntAnswerReceived();
   1010              mSetFlagAnswerReceivedOK();
   \   0005   8E....         MOV       A,DatTrpLocalData+30
   \   0008   6D03           OR        A,#3
   \   000A   9E....         MOV       DatTrpLocalData+30,A
   1011              mLIBmemcpy((U8*)&DatTrpLocalData.u32DataBuffer, 
   1012                  pMsg->pBuffer, 
   1013                  sizeof(DatTrpLocalData.u32DataBuffer));
   \   000D   C2             MOVW      AX,BC
   \   000E   D6             MOVW      HL,AX
   \   000F   87             MOV       A,[HL]
   \   0010   70             MOV       X,A
   \   0011   AE01           MOV       A,[HL+0x01]
   \   0013   D4             MOVW      DE,AX
   \   0014   16....         MOVW      HL,#DatTrpLocalData
   \   0017   A304           MOV       B,#4
   \                     ??DATTrpCallBackRxSpontWithoutAddr_0:
   \   0019   85             MOV       A,[DE]
   \   001A   97             MOV       [HL],A
   \   001B   86             INCW      HL
   \   001C   84             INCW      DE
   \   001D   8BFA           DBNZ      B, ??DATTrpCallBackRxSpontWithoutAddr_0
   1014          }
   \   001F   AF             RET       
   \   0020                  REQUIRE ?CL78K_V4_6_L00
   1015          
   1016          //*****************************************************************************
   1017          //  DESCRIPTION         : Signals the end of a receiving with address.
   1018          //
   1019          //  PARAMETERS          : None
   1020          //  (Type,Name,Min,Max) 
   1021          //
   1022          //  RETURN VALUE        : cFalse or cTrue
   1023          //
   1024          //  DESIGN INFORMATION  : Refer to Detailed Design Document
   1025          //
   1026          //*****************************************************************************
   1027          //QACJ 3227:amanevd: The function is declared without use of 'const' in standard components
   1028          //QACJ 3206:amanevd: Address parameter is declared in standart interface LDBParam, it could not be changed.

   \                                 In  segment BCODE, align 1, keep-with-next
   1029          MEM_TYPE void DATTrpCallBackRxWithAddr(tAddress Address, tStatus Status)
   \                     DATTrpCallBackRxWithAddr:
   1030          {
   \   0000                  ; * Stack frame (at entry) *
   \   0000                  ; Param size: 0
   \   0000                  ; Total Auto size: 0
   1031              mLIBassert((Status == cLDBCorrect) || (Status == cLDBError));
   1032          
   1033              mSetFlagImmoAntAnswerReceived();
   \   0000   A100           MOV       A,#0
   \   0002   16....         MOVW      HL,#DatTrpLocalData+30
   \   0005   7182           SET1      [HL].0
   1034              mMarkTrpOutInactive();
   \   0007   9E....         MOV       u8DATTrpOutState,A
   1035          
   1036              if (Status == cLDBCorrect)
   \   000A   63             MOV       A,B
   \   000B   4D00           CMP       A,#0
   \   000D   BD03           BNZ       ??DATTrpPage3InvertedDataReceivedOK_Static_53
   1037              {
   1038                  mSetFlagAnswerReceivedOK();
   \   000F   7192           SET1      [HL].1
   \   0011   AF             RET       
   1039              }
   1040              else
   1041              {
   1042                  mClearFlagAnswerReceivedOK();
   \                     ??DATTrpPage3InvertedDataReceivedOK_Static_53:
   \   0012   7193           CLR1      [HL].1
   1043              }
   1044          }
   \   0014   AF             RET       
   \   0015                  REQUIRE ?CL78K_V4_6_L00
   1045          
   1046          //*****************************************************************************
   1047          //  DESCRIPTION         : Test if challenge received is valid
   1048          //
   1049          //  PARAMETERS          : None
   1050          //  (Type,Name,Min,Max) 
   1051          //
   1052          //  RETURN VALUE        : cFalse or cTrue
   1053          //
   1054          //  DESIGN INFORMATION  : Refer to Detailed Design Document
   1055          //
   1056          //*****************************************************************************

   \                                 In  segment CODE, align 1, keep-with-next
   1057          BOOL DATTrpAnswerChallengeReceivedOK(void)
   \                     DATTrpAnswerChallengeReceivedOK:
   1058          {
   \   0000                  ; * Stack frame (at entry) *
   \   0000                  ; Param size: 0
   \   0000   B5             PUSH      DE
   \   0001                  ; Total Auto size: 0
   1059          #ifdef X90_PROJECT
   1060              return DATTrpAnswerChallengeReceivedOK_Static();
   \   0001   16....         MOVW      HL,#LWRD(DATTrpAnswerChallengeReceivedOK_Static)
   \   0004   A4..           MOV       E,#BYTE3(DATTrpAnswerChallengeReceivedOK_Static)
   \   0006   ..             CALLT     [__T_?FAR_CALL_L07]
   \   0007   B4             POP       DE
   \   0008   AF             RET       
   \   0009                  REQUIRE ?CL78K_V4_6_L00
   1061          }
   1062          #pragma optimize=no_inline

   \                                 In  segment BCODE, align 1, keep-with-next
   1063          static MEM_TYPE BOOL DATTrpAnswerChallengeReceivedOK_Static(void)
   \                     DATTrpAnswerChallengeReceivedOK_Static:
   1064          {
   \   0000                  ; * Stack frame (at entry) *
   \   0000                  ; Param size: 0
   \   0000   B3             PUSH      BC
   \   0001                  ; Total Auto size: 2
   \   0001   B7             PUSH      HL
   1065          #endif
   1066          
   1067              BOOL bResultL = cFalse;
   \   0002   891C           MOVW      AX,SP
   \   0004   D6             MOVW      HL,AX
   \   0005   A100           MOV       A,#0
   \   0007   97             MOV       [HL],A
   1068          
   1069              if (mGetFlagAnswerReceivedOK())
   \   0008   16....         MOVW      HL,#DatTrpLocalData+30
   \   000B   319603         BT        [HL].1, $+6
   \   000E   9B....         BR        N:??DATTrpPage3InvertedDataReceivedOK_Static_54
   1070              {
   1071                  mLIBassert((cTrue == (BOOL)DatTrpExportData.AuthentInLearningMode) 
   1072                      || (DatTrpExportData.IndexOfKeyRecognized < cDATTrpMaxNumberOfKey));
   1073          
   1074                  DatTrpExportData.ResponseToChallengeIsPresent = 1;
   \   0011   16....         MOVW      HL,#DatTrpExportData+50
   \   0014   71F2           SET1      [HL].7
   1075          
   1076                  //-------------------------------//
   1077                  // Decoding of Page 3 of Block 0
   1078                  //-------------------------------//
   1079                  DatTrpExportData.RepToChallange = DatTrpLocalData.u32DataBuffer;
   \   0016   02....         MOVW      AX,DatTrpLocalData+2
   \   0019   03....         MOVW      DatTrpExportData+26,AX
   \   001C   02....         MOVW      AX,DatTrpLocalData
   \   001F   03....         MOVW      DatTrpExportData+24,AX
   1080                  LIBPcfCipheredData = U32ReverseByteOrder(DatTrpLocalData.u32DataBuffer);
   \   0022   02....         MOVW      AX,DatTrpLocalData+2
   \   0025   D2             MOVW      BC,AX
   \   0026   02....         MOVW      AX,DatTrpLocalData
   \   0029   9A....         CALL      U32ReverseByteOrder
   \   002C   99..           MOVW      S:LIBPcfCipheredData,AX
   \   002E   C2             MOVW      AX,BC
   \   002F   99..           MOVW      S:LIBPcfCipheredData+2,AX
   1081                  LDBRefreshWatchDog();
   \   0031   9A....         CALL      LDBRefreshWatchDog
   1082                  LIBPcfCipherFunction(cPageLength);
   \   0034   A120           MOV       A,#32
   \   0036   16....         MOVW      HL,#LWRD(LIBPcfCipherFunction)
   \   0039   A4..           MOV       E,#BYTE3(LIBPcfCipherFunction)
   \   003B   ..             CALLT     [__T_?FAR_CALL_L07]
   1083                  LDBRefreshWatchDog();
   \   003C   9A....         CALL      LDBRefreshWatchDog
   1084                  DatTrpExportData.DataRead  = U32ReverseByteOrder(LIBPcfCipheredData);
   \   003F   89..           MOVW      AX,S:LIBPcfCipheredData+2
   \   0041   D2             MOVW      BC,AX
   \   0042   89..           MOVW      AX,S:LIBPcfCipheredData
   \   0044   9A....         CALL      U32ReverseByteOrder
   \   0047   03....         MOVW      DatTrpExportData+16,AX
   \   004A   C2             MOVW      AX,BC
   \   004B   03....         MOVW      DatTrpExportData+18,AX
   1085                  DatTrpExportData.RepToChallangeDecrypt = DatTrpExportData.DataRead;
   \   004E   03....         MOVW      DatTrpExportData+30,AX
   \   0051   02....         MOVW      AX,DatTrpExportData+16
   \   0054   03....         MOVW      DatTrpExportData+28,AX
   1086          
   1087                  if ((BOOL)DatTrpExportData.AuthentInLearningMode == cFalse)
   \   0057   16....         MOVW      HL,#DatTrpExportData+50
   \   005A   318703         BF        [HL].0, $+6
   \   005D   9B....         BR        N:??DATTrpPage3InvertedDataReceivedOK_Static_55
   1088                  {
   1089                      //---------------------------------------//
   1090                      // Update key informations
   1091                      //---------------------------------------//
   1092                      DatTrpExportData.PresentKeyLocked = ((DatTrpExportData.DataRead & cKeyLocked) == cKeyLocked);
   1093                      DatTrpExportData.KeyWithRF = ((DatTrpExportData.IdentifierOfPresentKey & cKeyWithRF) == cKeyWithRF);
   1094                      DatTrpExportData.KeyStandard = ((DatTrpExportData.IdentifierOfPresentKey & cKeyStandardMsk) == cKeyStandard);
   \   0060   02....         MOVW      AX,DatTrpExportData+12
   \   0063   60             MOV       A,X
   \   0064   5DF0           AND       A,#240
   \   0066   4D10           CMP       A,#16
   \   0068   BD04           BNZ       ??DATTrpPage3InvertedDataReceivedOK_Static_56
   \   006A   A101           MOV       A,#1
   \   006C   FA02           BR        ??DATTrpPage3InvertedDataReceivedOK_Static_57
   \                     ??DATTrpPage3InvertedDataReceivedOK_Static_56:
   \   006E   A100           MOV       A,#0
   \                     ??DATTrpPage3InvertedDataReceivedOK_Static_57:
   \   0070   A008           MOV       X,#8
   \   0072   3188           MULU      X
   \   0074   60             MOV       A,X
   \   0075   5D08           AND       A,#8
   \   0077   76             MOV       L,A
   \   0078   02....         MOVW      AX,DatTrpExportData+12
   \   007B   60             MOV       A,X
   \   007C   24             ROR       A,0x1
   \   007D   25             RORC      A,0x1
   \   007E   25             RORC      A,0x1
   \   007F   5D04           AND       A,#4
   \   0081   75             MOV       D,A
   \   0082   A41E           MOV       E,#30
   \   0084   02....         MOVW      AX,DatTrpExportData+16
   \   0087   9A....         CALL      ?UL_RSH_L03
   \   008A   60             MOV       A,X
   \   008B   21             CLR1      CY
   \   008C   27             ROLC      A,0x1
   \   008D   70             MOV       X,A
   \   008E   8E....         MOV       A,DatTrpExportData+51
   \   0091   5DFD           AND       A,#253
   \   0093   6168           OR        A,X
   \   0095   5DF3           AND       A,#243
   \   0097   616D           OR        A,D
   \   0099   616E           OR        A,L
   \   009B   9E....         MOV       DatTrpExportData+51,A
   1095                      DatTrpExportData.FrequencyOfPresentKey = (U8)(DatTrpExportData.DataRead >> cShift16) & cFrequencyMask;
   \   009E   02....         MOVW      AX,DatTrpExportData+18
   \   00A1   60             MOV       A,X
   \   00A2   5D30           AND       A,#48
   \   00A4   9E....         MOV       DatTrpExportData+39,A
   1096                      DatTrpExportData.KeyWithExtendedMemory = ((DatTrpExportData.DataRead & cKeyWithExtendedMemory) == cKeyWithExtendedMemory);       
   \   00A7   A6..           MOV       L,#LOW(DatTrpExportData+50)
   \   00A9   A417           MOV       E,#23
   \   00AB   8E....         MOV       A,DatTrpExportData+19
   \   00AE   D2             MOVW      BC,AX
   \   00AF   02....         MOVW      AX,DatTrpExportData+16
   \   00B2   9A....         CALL      ?UL_RSH_L03
   \   00B5   60             MOV       A,X
   \   00B6   618C           MOV1      CY,A.0
   \   00B8   71C1           MOV1      [HL].4,CY
   1097                      // Update of DiagKeyFrequency signal
   1098                      SignalCurrentKeyFrequency();
   \   00BA   16....         MOVW      HL,#LWRD(SignalCurrentKeyFrequency)
   \   00BD   A4..           MOV       E,#BYTE3(SignalCurrentKeyFrequency)
   \   00BF   ..             CALLT     [__T_?FAR_FAST_CALL_L07]
   1099                      //-------------------------------------------------------------------//
   1100                      // If received password tag is known by the BCM or if Learning Mode  
   1101                      // is in progress, the challenge is accepted.
   1102                      //-------------------------------------------------------------------//    
   1103                      bResultL = (BOOL)( ((DatTrpExportData.DataRead & c24bitMask) == mDATReadTable(U32Bit, EEP_PwdTag, DatTrpExportData.IndexOfKeyRecognized, Default)));
   \   00C0   8E....         MOV       A,DatTrpExportData+41
   \   00C3   A004           MOV       X,#4
   \   00C5   3188           MULU      X
   \   00C7   CA....         ADDW      AX,#DATDbkMirrors+86
   \   00CA   D6             MOVW      HL,AX
   \   00CB   87             MOV       A,[HL]
   \   00CC   70             MOV       X,A
   \   00CD   AE01           MOV       A,[HL+0x01]
   \   00CF   D2             MOVW      BC,AX
   \   00D0   100000         MOVW      AX,#0
   \   00D3   B3             PUSH      BC
   \   00D4   B1             PUSH      AX
   \   00D5   8E....         MOV       A,DatTrpExportData+41
   \   00D8   A004           MOV       X,#4
   \   00DA   3188           MULU      X
   \   00DC   CA....         ADDW      AX,#DATDbkMirrors+84
   \   00DF   D6             MOVW      HL,AX
   \   00E0   87             MOV       A,[HL]
   \   00E1   70             MOV       X,A
   \   00E2   AE01           MOV       A,[HL+0x01]
   \   00E4   120000         MOVW      BC,#0
   \   00E7   D6             MOVW      HL,AX
   \   00E8   891C           MOVW      AX,SP
   \   00EA   E6             XCHW      AX,HL
   \   00EB   E2             XCHW      AX,BC
   \   00EC   0902           ADD       A,[HL+0x02]
   \   00EE   30             XCH       A,X
   \   00EF   0903           ADD       A,[HL+0x03]
   \   00F1   E2             XCHW      AX,BC
   \   00F2   B6             POP       HL
   \   00F3   B6             POP       HL
   \   00F4   B3             PUSH      BC
   \   00F5   B1             PUSH      AX
   \   00F6   10FF00         MOVW      AX,#255
   \   00F9   B1             PUSH      AX
   \   00FA   A1FF           MOV       A,#255
   \   00FC   B1             PUSH      AX
   \   00FD   02....         MOVW      AX,DatTrpExportData+18
   \   0100   D2             MOVW      BC,AX
   \   0101   02....         MOVW      AX,DatTrpExportData+16
   \   0104   9A....         CALL      ?L_AND_L03
   \   0107   D6             MOVW      HL,AX
   \   0108   891C           MOVW      AX,SP
   \   010A   E6             XCHW      AX,HL
   \   010B   B5             PUSH      DE
   \   010C   D4             MOVW      DE,AX
   \   010D   64             MOV       A,E
   \   010E   1F             SUB       A,[HL]
   \   010F   70             MOV       X,A
   \   0110   65             MOV       A,D
   \   0111   3901           SUBC      A,[HL+0x01]
   \   0113   6160           OR        X,A
   \   0115   62             MOV       A,C
   \   0116   3902           SUBC      A,[HL+0x02]
   \   0118   6160           OR        X,A
   \   011A   63             MOV       A,B
   \   011B   3903           SUBC      A,[HL+0x03]
   \   011D   6160           OR        X,A
   \   011F   B4             POP       DE
   \   0120   B6             POP       HL
   \   0121   B6             POP       HL
   \   0122   BD06           BNZ       ??DATTrpPage3InvertedDataReceivedOK_Static_58
   \   0124   891C           MOVW      AX,SP
   \   0126   D6             MOVW      HL,AX
   \   0127   A101           MOV       A,#1
   \   0129   97             MOV       [HL],A
   1104          
   1105                      DatTrpExportData.ResponseToChallengeIsValid = bResultL;
   \                     ??DATTrpPage3InvertedDataReceivedOK_Static_58:
   \   012A   16....         MOVW      HL,#DatTrpExportData+51
   \   012D   B7             PUSH      HL
   \   012E   B4             POP       DE
   \   012F   891C           MOVW      AX,SP
   \   0131   D6             MOVW      HL,AX
   \   0132   87             MOV       A,[HL]
   \   0133   B5             PUSH      DE
   \   0134   B6             POP       HL
   \   0135   618C           MOV1      CY,A.0
   \   0137   7181           MOV1      [HL].0,CY
   \   0139   FA11           BR        ??DATTrpPage3InvertedDataReceivedOK_Static_54
   1106                  }
   1107                  else
   1108                  {
   1109                      //------------------------------------------------------------------//
   1110                      // Prepare inverted Page3 reading to ensure good Page3 and good IDE
   1111                      //------------------------------------------------------------------//
   1112                      DatTrpLocalData.InvertedReadingCommand  = 
   1113                          ComputeCommandWithPageNumber(cPage3, cLDBTrpRdPageInv);
   \                     ??DATTrpPage3InvertedDataReceivedOK_Static_55:
   \   013B   A103           MOV       A,#3
   \   013D   120800         MOVW      BC,#8
   \   0140   9A....         CALL      ComputeCommandWithPageNumber
   \   0143   03....         MOVW      DatTrpLocalData+26,AX
   1114          
   1115                      bResultL = cTrue;
   \   0146   891C           MOVW      AX,SP
   \   0148   D6             MOVW      HL,AX
   \   0149   A101           MOV       A,#1
   \   014B   97             MOV       [HL],A
   1116                  }
   1117              }
   1118          
   1119              return bResultL;
   \                     ??DATTrpPage3InvertedDataReceivedOK_Static_54:
   \   014C   9B....         BR        N:?Subroutine3
   \   014F                  REQUIRE ?CL78K_V4_6_L00
   1120          }

   \                                 In  segment BCODE, align 1, keep-with-next
   \                     ?Subroutine3:
   \   0000   891C           MOVW      AX,SP
   \   0002   D6             MOVW      HL,AX
   \   0003   87             MOV       A,[HL]
   \   0004   B2             POP       BC
   \   0005   B2             POP       BC
   \   0006   AF             RET       
   \   0007                  REQUIRE ?CL78K_V4_6_L00
   1121          //*****************************************************************************
   1122          //  DESCRIPTION         : Authentication service not success
   1123          //
   1124          //  PARAMETERS          : None
   1125          //  (Type,Name,Min,Max) 
   1126          //
   1127          //  RETURN VALUE        : None
   1128          //
   1129          //  DESIGN INFORMATION  : Refer to Detailed Design Document (REQ: prsFS_IMMO-684)
   1130          //
   1131          //*****************************************************************************

   \                                 In  segment CODE, align 1, keep-with-next
   1132          void DATTrpAuthenticationNotSuccess(void)
   \                     DATTrpAuthenticationNotSuccess:
   1133          {
   \   0000                  ; * Stack frame (at entry) *
   \   0000                  ; Param size: 0
   \   0000   B5             PUSH      DE
   \   0001                  ; Total Auto size: 0
   1134          #ifdef X90_PROJECT
   1135              DATTrpAuthenticationNotSuccess_Static();
   \   0001   16....         MOVW      HL,#LWRD(DATTrpAuthenticationNotSuccess_Static)
   \   0004   A4..           MOV       E,#BYTE3(DATTrpAuthenticationNotSuccess_Static)
   \   0006   ..             CALLT     [__T_?FAR_CALL_L07]
   1136          }
   \   0007   B4             POP       DE
   \   0008   AF             RET       
   \   0009                  REQUIRE ?CL78K_V4_6_L00
   1137          #pragma optimize=no_inline

   \                                 In  segment BCODE, align 1, keep-with-next
   1138          static MEM_TYPE void DATTrpAuthenticationNotSuccess_Static(void)
   \                     DATTrpAuthenticationNotSuccess_Static:
   1139          {
   \   0000                  ; * Stack frame (at entry) *
   \   0000                  ; Param size: 0
   \   0000                  ; Total Auto size: 0
   1140          #endif
   1141          
   1142              U8 u8AuthentFailureCounterL = mDATRead(U8Bit, EEP_AuthentFailureCounter, Default);
   \   0000   8E....         MOV       A,DATDbkMirrors+2
   1143          
   1144              mLIBassert(DatTrpExportData.AuthenticationState == cDATTrpServiceInProgress);
   1145          
   1146              if(u8AuthentFailureCounterL < cMaxAuthentFailureCounter)
   \   0003   41             INC       A
   \   0004   AD08           BZ        ??DATTrpPage3InvertedDataReceivedOK_Static_59
   1147              {
   1148                  u8AuthentFailureCounterL++;
   1149                  mDATWrite(U8Bit, EEP_AuthentFailureCounter, u8AuthentFailureCounterL, Default);
   \   0006   9E....         MOV       DATDbkMirrors+2,A
   \   0009   A100           MOV       A,#0
   \   000B   9A....         CALL      DATDbkStartUpdate
   1150              }
   1151          
   1152              mDATWrite(U8Bit, EEP_AuthentDelayedCounter, 0, Default);
   \                     ??DATTrpPage3InvertedDataReceivedOK_Static_59:
   \   000E   8E....         MOV       A,DATDbkMirrors+1
   \   0011   4D00           CMP       A,#0
   \   0013   AD08           BZ        ??DATTrpPage3InvertedDataReceivedOK_Static_60
   \   0015   A100           MOV       A,#0
   \   0017   9E....         MOV       DATDbkMirrors+1,A
   \   001A   9A....         CALL      DATDbkStartUpdate
   1153          
   1154              DatTrpExportData.AuthenticationState = cDATTrpServiceNotSuccessful;
   \                     ??DATTrpPage3InvertedDataReceivedOK_Static_60:
   \   001D   A103           MOV       A,#3
   \   001F   16....         MOVW      HL,#DatTrpExportData+44
   \   0022   97             MOV       [HL],A
   1155          }
   \   0023   AF             RET       
   \   0024                  REQUIRE ?CL78K_V4_6_L00
   1156          //*****************************************************************************
   1157          //  DESCRIPTION         : Authentication service success
   1158          //
   1159          //  PARAMETERS          : None
   1160          //  (Type,Name,Min,Max) 
   1161          //
   1162          //  RETURN VALUE        : None
   1163          //
   1164          //  DESIGN INFORMATION  : Refer to Detailed Design Document
   1165          //
   1166          //*****************************************************************************

   \                                 In  segment CODE, align 1, keep-with-next
   1167          void DATTrpAuthenticationSuccess(void)
   \                     DATTrpAuthenticationSuccess:
   1168          {
   \   0000                  ; * Stack frame (at entry) *
   \   0000                  ; Param size: 0
   \   0000   B5             PUSH      DE
   \   0001                  ; Total Auto size: 0
   1169          #ifdef X90_PROJECT
   1170              DATTrpAuthenticationSuccess_Static();
   \   0001   16....         MOVW      HL,#LWRD(DATTrpAuthenticationSuccess_Static)
   \   0004   A4..           MOV       E,#BYTE3(DATTrpAuthenticationSuccess_Static)
   \   0006   ..             CALLT     [__T_?FAR_CALL_L07]
   1171          }
   \   0007   B4             POP       DE
   \   0008   AF             RET       
   \   0009                  REQUIRE ?CL78K_V4_6_L00
   1172          #pragma optimize=no_inline

   \                                 In  segment BCODE, align 1, keep-with-next
   1173          static MEM_TYPE void DATTrpAuthenticationSuccess_Static(void)
   \                     DATTrpAuthenticationSuccess_Static:
   1174          {
   \   0000                  ; * Stack frame (at entry) *
   \   0000                  ; Param size: 0
   \   0000   10....         MOVW      AX,#DatTrpExportData+32
   \   0003   B3             PUSH      BC
   \   0004                  ; Total Auto size: 0
   1175          #endif
   1176          
   1177              REG u32ResL;
   1178          
   1179              mLIBassert(DatTrpExportData.AuthenticationState == cDATTrpServiceInProgress);
   1180          
   1181              //QACJ 0543:amanevd: Result of mLIBmemcmp() expansion to NOP() in LIB.h Authentication with transport ISK (virgin key test mode only)
   1182              u32ResL = (REG)mLIBmemcmp(&DatTrpExportData.ISKForAuthent[0],
   1183                          DATTrpTransportISK,
   1184                          cDATTrpISKLengthInBytes);
   \   0004   140600         MOVW      DE,#6
   \   0007   12....         MOVW      BC,#DATTrpTransportISK
   \   000A   9A....         CALL      memcmp
   \   000D   60             MOV       A,X
   1185          
   1186              if ((REG)0 == u32ResL)
   \   000E   4D00           CMP       A,#0
   \   0010   BD07           BNZ       ??DATTrpPage3InvertedDataReceivedOK_Static_61
   1187              {
   1188                  DatTrpExportData.VirginKeyAuthentOk = 1;
   \                     ??DATTrpAuthenticationSuccess_Static_0:
   \   0012   16....         MOVW      HL,#DatTrpExportData+50
   \   0015   71B2           SET1      [HL].3
   \   0017   FA06           BR        ??DATTrpPage3InvertedDataReceivedOK_Static_62
   1189              }
   1190              // prsFS_IMMO-1107
   1191              else if(cDATFactoryMode == mDATRead(U8Bit, LearningModeInProgress, Default))
   \                     ??DATTrpPage3InvertedDataReceivedOK_Static_61:
   \   0019   8E....         MOV       A,DATCmnImmoData+17
   \   001C   51             DEC       A
   \   001D   ADF3           BZ        ??DATTrpAuthenticationSuccess_Static_0
   1192              {
   1193                  DatTrpExportData.VirginKeyAuthentOk = 1;
   1194              }
   1195              else
   1196              {
   1197                  // Nothing to do
   1198              }
   1199          
   1200              // Clear all error
   1201              mDATWrite(U1Bit, DefTrpShortCircuitToBat, 0, Default);
   \                     ??DATTrpPage3InvertedDataReceivedOK_Static_62:
   \   001F   A100           MOV       A,#0
   \   0021   16....         MOVW      HL,#DATCmnData+13
   \   0024   97             MOV       [HL],A
   1202              mDATWrite(U1Bit, DefTrpShortCircuitToGnd, 0, Default);
   \   0025   16....         MOVW      HL,#DATCmnData+12
   \   0028   97             MOV       [HL],A
   1203              DatTrpExportData.AuthenticationState = cDATTrpServiceSuccessful;
   \   0029   A102           MOV       A,#2
   \   002B   16....         MOVW      HL,#DatTrpExportData+44
   \   002E   97             MOV       [HL],A
   1204          }
   \   002F   B2             POP       BC
   \   0030   AF             RET       
   \   0031                  REQUIRE ?CL78K_V4_6_L00
   1205          
   1206          //*****************************************************************************
   1207          //  DESCRIPTION         : TfcDiag service not success
   1208          //
   1209          //  PARAMETERS          : None
   1210          //  (Type,Name,Min,Max) 
   1211          //
   1212          //  RETURN VALUE        : None
   1213          //
   1214          //  DESIGN INFORMATION  : Refer to Detailed Design Document (REQ: prsFS_IMMO-684)
   1215          //
   1216          //*****************************************************************************

   \                                 In  segment CODE, align 1, keep-with-next
   1217          void DATTrpTfcDiagNotSuccess(void)
   \                     DATTrpTfcDiagNotSuccess:
   1218          {
   \   0000                  ; * Stack frame (at entry) *
   \   0000                  ; Param size: 0
   \   0000                  ; Total Auto size: 0
   1219              DatTrpExportData.AuthenticationState = cDATTrpServiceNotSuccessful;
   \   0000   A103           MOV       A,#3
   \   0002                  REQUIRE ?CL78K_V4_6_L00
   \   0002                  REQUIRE ?Subroutine0
   \   0002                  ; // Fall through to label ?Subroutine0
   1220          }

   \                                 In  segment CODE, align 1, keep-with-next
   \                     ?Subroutine0:
   \   0000   16....         MOVW      HL,#DatTrpExportData+44
   \   0003   97             MOV       [HL],A
   \   0004   AF             RET       
   \   0005                  REQUIRE ?CL78K_V4_6_L00
   1221          
   1222          //*****************************************************************************
   1223          //  DESCRIPTION         : TfcDiag service success
   1224          //
   1225          //  PARAMETERS          : None
   1226          //  (Type,Name,Min,Max) 
   1227          //
   1228          //  RETURN VALUE        : None
   1229          //
   1230          //  DESIGN INFORMATION  : Refer to Detailed Design Document
   1231          //
   1232          //*****************************************************************************

   \                                 In  segment CODE, align 1, keep-with-next
   1233          void DATTrpTfcDiagSuccess(void)
   \                     DATTrpTfcDiagSuccess:
   1234          {
   \   0000                  ; * Stack frame (at entry) *
   \   0000                  ; Param size: 0
   \   0000                  ; Total Auto size: 0
   1235              DatTrpExportData.AuthenticationState = cDATTrpServiceSuccessful;
   \   0000   A102           MOV       A,#2
   \   0002   9B....         BR        N:?Subroutine0
   \   0005                  REQUIRE ?CL78K_V4_6_L00
   1236          }
   1237          
   1238          //*****************************************************************************
   1239          //  DESCRIPTION         : Compute and send the authentication challenge.
   1240          //
   1241          //  PARAMETERS          : None
   1242          //  (Type,Name,Min,Max) 
   1243          //
   1244          //  RETURN VALUE        : None
   1245          //
   1246          //  DESIGN INFORMATION  : Refer to Detailed Design Document
   1247          //
   1248          //*****************************************************************************

   \                                 In  segment CODE, align 1, keep-with-next
   1249          void DATTrpCalculateChallenge(void)
   \                     DATTrpCalculateChallenge:
   1250          {
   \   0000                  ; * Stack frame (at entry) *
   \   0000                  ; Param size: 0
   \   0000   B5             PUSH      DE
   \   0001                  ; Total Auto size: 0
   1251          #ifdef X90_PROJECT
   1252              DATTrpCalculateChallenge_Static();
   \   0001   16....         MOVW      HL,#LWRD(DATTrpCalculateChallenge_Static)
   \   0004   A4..           MOV       E,#BYTE3(DATTrpCalculateChallenge_Static)
   \   0006   ..             CALLT     [__T_?FAR_CALL_L07]
   1253          }
   \   0007   B4             POP       DE
   \   0008   AF             RET       
   \   0009                  REQUIRE ?CL78K_V4_6_L00
   1254          #pragma optimize=no_inline

   \                                 In  segment BCODE, align 1, keep-with-next
   1255          static MEM_TYPE void DATTrpCalculateChallenge_Static(void)
   \                     DATTrpCalculateChallenge_Static:
   1256          {
   \   0000                  ; * Stack frame (at entry) *
   \   0000                  ; Param size: 0
   \   0000   B3             PUSH      BC
   \   0001                  ; Total Auto size: 0
   1257          #endif
   1258          
   1259              //--------------------------//
   1260              // Initialize TAG algorithm
   1261              //--------------------------//
   1262              LIBPcfRandomNumber = LIBCalculateRandomNb(TOSClock);
   \   0001   02....         MOVW      AX,TOSClock
   \   0004   120000         MOVW      BC,#0
   \   0007   9A....         CALL      LIBCalculateRandomNb
   \   000A   99..           MOVW      S:LIBPcfRandomNumber,AX
   \   000C   C2             MOVW      AX,BC
   \   000D   99..           MOVW      S:LIBPcfRandomNumber+2,AX
   1263              pLIBPcfSecretKey   = DatTrpExportData.ISKForAuthent;  
   \   000F   EE......       MOVW      S:pLIBPcfSecretKey,#DatTrpExportData+32
   1264              DatTrpLocalData.ExchIdentifier[cPage0] = 
   1265                  (U8)((DatTrpExportData.IdentifierOfPresentKey >> cShift24) & cMaskByte1);
   \   0013   02....         MOVW      AX,DatTrpExportData+14
   \   0016   9E....         MOV       DatTrpLocalData+4,A
   1266              DatTrpLocalData.ExchIdentifier[cPage1] = 
   1267                  (U8)((DatTrpExportData.IdentifierOfPresentKey >> cShift16) & cMaskByte1);
   \   0019   60             MOV       A,X
   \   001A   9E....         MOV       DatTrpLocalData+5,A
   1268              DatTrpLocalData.ExchIdentifier[cPage2] = 
   1269                  (U8)((DatTrpExportData.IdentifierOfPresentKey >> cShift8 ) & cMaskByte1);
   \   001D   02....         MOVW      AX,DatTrpExportData+12
   \   0020   9E....         MOV       DatTrpLocalData+6,A
   1270              DatTrpLocalData.ExchIdentifier[cPage3] = 
   1271                  (U8)(DatTrpExportData.IdentifierOfPresentKey & cMaskByte1);
   \   0023   60             MOV       A,X
   \   0024   9E....         MOV       DatTrpLocalData+7,A
   1272          
   1273              pLIBPcfIdentifier = DatTrpLocalData.ExchIdentifier;
   \   0027   EE......       MOVW      S:pLIBPcfIdentifier,#DatTrpLocalData+4
   1274              LDBRefreshWatchDog();
   \   002B   9A....         CALL      LDBRefreshWatchDog
   1275              LIBPcfInitialize();
   \   002E   16....         MOVW      HL,#LWRD(LIBPcfInitialize)
   \   0031   A4..           MOV       E,#BYTE3(LIBPcfInitialize)
   \   0033   ..             CALLT     [__T_?FAR_CALL_L07]
   1276          
   1277              //----------------------------------//
   1278              // Generate the encrypted signature
   1279              //----------------------------------//
   1280              LIBPcfCipheredData = cSignatureInitialValue;
   \   0034   EE..FFFF       MOVW      S:LIBPcfCipheredData,#65535
   \   0038   EE..FFFF       MOVW      S:LIBPcfCipheredData+2,#65535
   1281              LDBRefreshWatchDog();
   \   003C   9A....         CALL      LDBRefreshWatchDog
   1282              LIBPcfCipherFunction(cSignatureLength);
   \   003F   A120           MOV       A,#32
   \   0041   16....         MOVW      HL,#LWRD(LIBPcfCipherFunction)
   \   0044   A4..           MOV       E,#BYTE3(LIBPcfCipherFunction)
   \   0046   ..             CALLT     [__T_?FAR_CALL_L07]
   1283              LDBRefreshWatchDog();
   \   0047   9A....         CALL      LDBRefreshWatchDog
   1284              LIBPcfRandomNumber = U32ReverseByteOrder(LIBPcfRandomNumber);
   \   004A   89..           MOVW      AX,S:LIBPcfRandomNumber+2
   \   004C   D2             MOVW      BC,AX
   \   004D   89..           MOVW      AX,S:LIBPcfRandomNumber
   \   004F   9A....         CALL      U32ReverseByteOrder
   \   0052   99..           MOVW      S:LIBPcfRandomNumber,AX
   \   0054   C2             MOVW      AX,BC
   \   0055   99..           MOVW      S:LIBPcfRandomNumber+2,AX
   1285              LIBPcfCipheredData = U32ReverseByteOrder(LIBPcfCipheredData);
   \   0057   89..           MOVW      AX,S:LIBPcfCipheredData+2
   \   0059   D2             MOVW      BC,AX
   \   005A   89..           MOVW      AX,S:LIBPcfCipheredData
   \   005C   9A....         CALL      U32ReverseByteOrder
   \   005F   99..           MOVW      S:LIBPcfCipheredData,AX
   \   0061   C2             MOVW      AX,BC
   \   0062   99..           MOVW      S:LIBPcfCipheredData+2,AX
   1286          
   1287              //------------------------------------------//
   1288              // Indicate that answer is not received yet
   1289              //------------------------------------------//
   1290              mClearFlagImmoAntAnswerReceived();
   1291              mClearFlagAnswerReceivedOK();
   \   0064   8E....         MOV       A,DatTrpLocalData+30
   \   0067   5DFC           AND       A,#252
   \   0069   9E....         MOV       DatTrpLocalData+30,A
   1292          
   1293              //------------------------------------------------//
   1294              // Prepare the message to send to the transponder
   1295              //------------------------------------------------//
   1296              DatTrpExportData.ExchChallenge.ulRandomNumber    = LIBPcfRandomNumber;
   \   006C   89..           MOVW      AX,S:LIBPcfRandomNumber+2
   \   006E   D2             MOVW      BC,AX
   \   006F   89..           MOVW      AX,S:LIBPcfRandomNumber
   \   0071   03....         MOVW      DatTrpExportData+4,AX
   \   0074   C2             MOVW      AX,BC
   \   0075   03....         MOVW      DatTrpExportData+6,AX
   1297              DatTrpExportData.ExchChallenge.ulSignature       = LIBPcfCipheredData;
   \   0078   89..           MOVW      AX,S:LIBPcfCipheredData+2
   \   007A   D2             MOVW      BC,AX
   \   007B   89..           MOVW      AX,S:LIBPcfCipheredData
   \   007D   03....         MOVW      DatTrpExportData,AX
   \   0080   C2             MOVW      AX,BC
   \   0081   03....         MOVW      DatTrpExportData+2,AX
   1298              DatTrpLocalData.TransponderMessage.Lng          = cChallengeLength;
   \   0084   104000         MOVW      AX,#64
   \   0087   03....         MOVW      DatTrpLocalData+10,AX
   1299              //QACJ 0310:amanevd: LIBPcf knows how data is structured in tChallange type so cast to (U8*) is not a problem
   1300              DatTrpLocalData.TransponderMessage.pBuffer = (U8*)(&DatTrpExportData.ExchChallenge);
   \   008A   10....         MOVW      AX,#DatTrpExportData
   \   008D   03....         MOVW      DatTrpLocalData+8,AX
   1301          
   1302              //---------------------------//
   1303              // Start communication timer
   1304              //---------------------------//
   1305              DatTrpLocalData.CommandTimeOut = cChallengeTimeOut;
   \   0090   100800         MOVW      AX,#8
   \   0093   03....         MOVW      DatTrpLocalData+18,AX
   1306              TOSStartTimer(&DatTrpLocalData.TimeOutWaitingForImmoANTReply);
   \   0096   10....         MOVW      AX,#DatTrpLocalData+12
   \   0099   ..             CALLT     [__T_TOSStartTimer]
   1307          
   1308              //----------------------------------//
   1309              // Start the sending of the message
   1310              //----------------------------------//
   1311          
   1312              LDBSendWithAddr(cLDBChannelTrp, cLDBTrpStartAuth, &DatTrpLocalData.TransponderMessage);
   \   009A   101800         MOVW      AX,#24
   \   009D   12....         MOVW      BC,#DatTrpLocalData+8
   \   00A0   16....         MOVW      HL,#LWRD(LDBTrpSendWithAddr)
   \   00A3   A4..           MOV       E,#BYTE3(LDBTrpSendWithAddr)
   \   00A5   ..             CALLT     [__T_?FAR_CALL_L07]
   1313          }
   \   00A6   B2             POP       BC
   \   00A7   AF             RET       
   \   00A8                  REQUIRE ?CL78K_V4_6_L00
   1314          
   1315          //*****************************************************************************
   1316          //  DESCRIPTION         : Identifier received OK for authentication service.
   1317          //
   1318          //  PARAMETERS          : None
   1319          //  (Type,Name,Min,Max) 
   1320          //
   1321          //  RETURN VALUE        : cFalse or cTrue.
   1322          //
   1323          //  DESIGN INFORMATION  : Refer to Detailed Design Document
   1324          //
   1325          //*****************************************************************************

   \                                 In  segment CODE, align 1, keep-with-next
   1326          BOOL DATTrpIdentifierReceivedOK(void)
   \                     DATTrpIdentifierReceivedOK:
   1327          {
   \   0000                  ; * Stack frame (at entry) *
   \   0000                  ; Param size: 0
   \   0000   B5             PUSH      DE
   \   0001                  ; Total Auto size: 0
   1328          #ifdef X90_PROJECT
   1329              return DATTrpIdentifierReceivedOK_Static();
   \   0001   16....         MOVW      HL,#LWRD(DATTrpIdentifierReceivedOK_Static)
   \   0004   A4..           MOV       E,#BYTE3(DATTrpIdentifierReceivedOK_Static)
   \   0006   ..             CALLT     [__T_?FAR_CALL_L07]
   \   0007   B4             POP       DE
   \   0008   AF             RET       
   \   0009                  REQUIRE ?CL78K_V4_6_L00
   1330          }
   1331          #pragma optimize=no_inline

   \                                 In  segment BCODE, align 1, keep-with-next
   1332          static MEM_TYPE BOOL DATTrpIdentifierReceivedOK_Static(void)
   \                     DATTrpIdentifierReceivedOK_Static:
   1333          {
   \   0000                  ; * Stack frame (at entry) *
   \   0000                  ; Param size: 0
   \   0000   B3             PUSH      BC
   \   0001                  ; Total Auto size: 2
   \   0001   B7             PUSH      HL
   1334          #endif
   1335          
   1336              BOOL bResultL = cFalse;
   \   0002   A500           MOV       D,#0
   1337              U8   ucKeyNumberL;
   1338          
   1339              if (mGetFlagAnswerReceivedOK())
   \   0004   16....         MOVW      HL,#DatTrpLocalData+30
   \   0007   319603         BT        [HL].1, $+6
   \   000A   9B....         BR        N:??DATTrpPage3InvertedDataReceivedOK_Static_63
   1340              {
   1341                  DatTrpExportData.IdentifierOfPresentKey = DatTrpLocalData.u32DataBuffer;
   \   000D   02....         MOVW      AX,DatTrpLocalData+2
   \   0010   03....         MOVW      DatTrpExportData+14,AX
   \   0013   02....         MOVW      AX,DatTrpLocalData
   \   0016   03....         MOVW      DatTrpExportData+12,AX
   1342                  DatTrpExportData.IdentifierOfPresentKeyIsReceived = 1;
   \   0019   10....         MOVW      AX,#DATDbkMirrors
   \   001C   16....         MOVW      HL,#DatTrpExportData+50
   \   001F   71D2           SET1      [HL].5
   1343                  //-------------------------------------------------------------------//
   1344                  // Compare identifier received with all identifiers stored in Eeprom
   1345                  //-------------------------------------------------------------------//
   1346                  for ( ucKeyNumberL = 0; 
   \   0021   A400           MOV       E,#0
   \   0023   B6             POP       HL
   \   0024   B1             PUSH      AX
   \                     ??DATTrpIdentifierReceivedOK_Static_0:
   \   0025   16....         MOVW      HL,#DatTrpExportData+50
   \   0028   31E66B         BT        [HL].6, ??DATTrpPage3InvertedDataReceivedOK_Static_64
   1347                  (ucKeyNumberL < cDATTrpMaxNumberOfKey) && (cFalse == (BOOL)DatTrpExportData.IdentifierOfPresentKeyIsValid); 
   1348                  ucKeyNumberL++)
   1349                  {
   1350                      if (mDATReadTable(U32Bit, EEP_KeyIdentifier, ucKeyNumberL, Default) == DatTrpExportData.IdentifierOfPresentKey)
   \   002B   891C           MOVW      AX,SP
   \   002D   D6             MOVW      HL,AX
   \   002E   87             MOV       A,[HL]
   \   002F   70             MOV       X,A
   \   0030   AE01           MOV       A,[HL+0x01]
   \   0032   D6             MOVW      HL,AX
   \   0033   AE46           MOV       A,[HL+0x46]
   \   0035   70             MOV       X,A
   \   0036   AE47           MOV       A,[HL+0x47]
   \   0038   D2             MOVW      BC,AX
   \   0039   100000         MOVW      AX,#0
   \   003C   B3             PUSH      BC
   \   003D   B1             PUSH      AX
   \   003E   891C           MOVW      AX,SP
   \   0040   D6             MOVW      HL,AX
   \   0041   AE04           MOV       A,[HL+0x04]
   \   0043   70             MOV       X,A
   \   0044   AE05           MOV       A,[HL+0x05]
   \   0046   D6             MOVW      HL,AX
   \   0047   AE44           MOV       A,[HL+0x44]
   \   0049   70             MOV       X,A
   \   004A   AE45           MOV       A,[HL+0x45]
   \   004C   120000         MOVW      BC,#0
   \   004F   D6             MOVW      HL,AX
   \   0050   891C           MOVW      AX,SP
   \   0052   E6             XCHW      AX,HL
   \   0053   E2             XCHW      AX,BC
   \   0054   0902           ADD       A,[HL+0x02]
   \   0056   30             XCH       A,X
   \   0057   0903           ADD       A,[HL+0x03]
   \   0059   E2             XCHW      AX,BC
   \   005A   B6             POP       HL
   \   005B   B6             POP       HL
   \   005C   B5             PUSH      DE
   \   005D   D4             MOVW      DE,AX
   \   005E   64             MOV       A,E
   \   005F   18....         SUB       A,DatTrpExportData+12
   \   0062   70             MOV       X,A
   \   0063   65             MOV       A,D
   \   0064   38....         SUBC      A,DatTrpExportData+13
   \   0067   6160           OR        X,A
   \   0069   62             MOV       A,C
   \   006A   38....         SUBC      A,DatTrpExportData+14
   \   006D   6160           OR        X,A
   \   006F   63             MOV       A,B
   \   0070   38....         SUBC      A,DatTrpExportData+15
   \   0073   6160           OR        X,A
   \   0075   B4             POP       DE
   \   0076   BD09           BNZ       ??DATTrpPage3InvertedDataReceivedOK_Static_65
   1351                      {
   1352                          DatTrpExportData.IdentifierOfPresentKeyIsValid = 1;
   \   0078   64             MOV       A,E
   \   0079   16....         MOVW      HL,#DatTrpExportData+50
   \   007C   71E2           SET1      [HL].6
   1353                          DatTrpExportData.IndexOfKeyRecognized = ucKeyNumberL;
   \   007E   9E....         MOV       DatTrpExportData+41,A
   1354                      }
   1355                  }
   \                     ??DATTrpPage3InvertedDataReceivedOK_Static_65:
   \   0081   44             INC       E
   \   0082   891C           MOVW      AX,SP
   \   0084   D6             MOVW      HL,AX
   \   0085   87             MOV       A,[HL]
   \   0086   70             MOV       X,A
   \   0087   AE01           MOV       A,[HL+0x01]
   \   0089   D6             MOVW      HL,AX
   \   008A   86             INCW      HL
   \   008B   86             INCW      HL
   \   008C   86             INCW      HL
   \   008D   86             INCW      HL
   \   008E   C6             MOVW      AX,HL
   \   008F   B6             POP       HL
   \   0090   B1             PUSH      AX
   \   0091   64             MOV       A,E
   \   0092   4D04           CMP       A,#4
   \   0094   8D8F           BC        ??DATTrpIdentifierReceivedOK_Static_0
   1356                  //-------------------------------------------------------------------//
   1357                  // If received identifier is known by the BCM or if Learning Mode is 
   1358                  // in progress, the identifier is accepted.
   1359                  //-------------------------------------------------------------------//
   1360                  bResultL = (BOOL)(   (DatTrpExportData.AuthentInLearningMode) 
   1361                                   || (DatTrpExportData.IdentifierOfPresentKeyIsValid)
   1362                                  );
   \                     ??DATTrpPage3InvertedDataReceivedOK_Static_64:
   \   0096   8E....         MOV       A,DatTrpExportData+50
   \   0099   5D41           AND       A,#65
   \   009B   AD02           BZ        ??DATTrpPage3InvertedDataReceivedOK_Static_63
   \   009D   A501           MOV       D,#1
   1363              }
   1364          
   1365              return bResultL;
   \                     ??DATTrpPage3InvertedDataReceivedOK_Static_63:
   \   009F   65             MOV       A,D
   \   00A0   B2             POP       BC
   \   00A1   B2             POP       BC
   \   00A2   AF             RET       
   \   00A3                  REQUIRE ?CL78K_V4_6_L00
   1366          }
   1367          
   1368          //*****************************************************************************
   1369          //  DESCRIPTION         : Identifier received OK for TfcDiag service.
   1370          //
   1371          //  PARAMETERS          : None
   1372          //  (Type,Name,Min,Max) 
   1373          //
   1374          //  RETURN VALUE        : cFalse or cTrue.
   1375          //
   1376          //  DESIGN INFORMATION  : Refer to Detailed Design Document
   1377          //
   1378          //*****************************************************************************

   \                                 In  segment CODE, align 1, keep-with-next
   1379          BOOL DATTrpTfcResponceOK(void)
   \                     DATTrpTfcResponceOK:
   1380          {
   \   0000                  ; * Stack frame (at entry) *
   \   0000                  ; Param size: 0
   \   0000                  ; Total Auto size: 0
   1381              return (mGetFlagAnswerReceivedOK());
   \   0000   A100           MOV       A,#0
   \   0002   16....         MOVW      HL,#DatTrpLocalData+30
   \   0005   7194           MOV1      CY,[HL].1
   \   0007   27             ROLC      A,0x1
   \   0008   AF             RET       
   \   0009                  REQUIRE ?CL78K_V4_6_L00
   1382          }
   1383          
   1384          //*****************************************************************************
   1385          //  DESCRIPTION         : Compute and send read command.
   1386          //
   1387          //  PARAMETERS          : None
   1388          //  (Type,Name,Min,Max) 
   1389          //
   1390          //  RETURN VALUE        : None
   1391          //
   1392          //  DESIGN INFORMATION  : Refer to Detailed Design Document
   1393          //
   1394          //*****************************************************************************

   \                                 In  segment CODE, align 1, keep-with-next
   1395          void DATTrpSendReadCommand(void)
   \                     DATTrpSendReadCommand:
   1396          {
   \   0000                  ; * Stack frame (at entry) *
   \   0000                  ; Param size: 0
   \   0000   B5             PUSH      DE
   \   0001                  ; Total Auto size: 0
   1397          #ifdef X90_PROJECT
   1398              DATTrpSendReadCommand_Static();
   \   0001   16....         MOVW      HL,#LWRD(DATTrpSendReadCommand_Static)
   \   0004   A4..           MOV       E,#BYTE3(DATTrpSendReadCommand_Static)
   \   0006   ..             CALLT     [__T_?FAR_CALL_L07]
   1399          }
   \   0007   B4             POP       DE
   \   0008   AF             RET       
   \   0009                  REQUIRE ?CL78K_V4_6_L00
   1400          #pragma optimize=no_inline

   \                                 In  segment BCODE, align 1, keep-with-next
   1401          static MEM_TYPE void DATTrpSendReadCommand_Static(void)
   \                     DATTrpSendReadCommand_Static:
   1402          {
   \   0000                  ; * Stack frame (at entry) *
   \   0000                  ; Param size: 0
   \   0000   B3             PUSH      BC
   \   0001                  ; Total Auto size: 0
   1403          #endif
   1404          
   1405              tTrpCommand EncodedReadingCommand;
   1406          
   1407              // Prevention of simultaneous access of antena by immo or exm components
   1408              // like:    if (DatTrpLocalData.CipheredCommunication == cTrue)
   1409              //------------------------//
   1410              // Encode command to send
   1411              //------------------------//
   1412              EncodedReadingCommand = EncodeCommand(DatTrpLocalData.ReadingCommand);
   \   0001   02....         MOVW      AX,DatTrpLocalData+24
   \   0004   9A....         CALL      EncodeCommand
   \   0007   D4             MOVW      DE,AX
   1413          
   1414              //-------------------------------------------------//
   1415              // Prepare message to receive the page value
   1416              //-------------------------------------------------//
   1417              DatTrpLocalData.TransponderMessage.Lng  = cPageLength;
   \   0008   102000         MOVW      AX,#32
   \   000B   03....         MOVW      DatTrpLocalData+10,AX
   1418              DatTrpLocalData.u32DataBuffer            = 0;
   \   000E   70             MOV       X,A
   \   000F   03....         MOVW      DatTrpLocalData+2,AX
   \   0012   03....         MOVW      DatTrpLocalData,AX
   1419              //QACJ 0310:amanevd: Test on target prooves that this cast is compiled correct. As well as this is how it comes from reuse.
   1420              DatTrpLocalData.TransponderMessage.pBuffer = (U8*)&DatTrpLocalData.u32DataBuffer;
   \   0015   10....         MOVW      AX,#DatTrpLocalData
   \   0018   03....         MOVW      DatTrpLocalData+8,AX
   1421          
   1422              //------------------------------------------//
   1423              // Indicate that answer is not received yet
   1424              //------------------------------------------//
   1425              mClearFlagImmoAntAnswerReceived();
   1426              mClearFlagAnswerReceivedOK();
   \   001B   8E....         MOV       A,DatTrpLocalData+30
   \   001E   5DFC           AND       A,#252
   \   0020   9E....         MOV       DatTrpLocalData+30,A
   1427          
   1428              //---------------------------//
   1429              // Start communication timer
   1430              //---------------------------//
   1431              DatTrpLocalData.CommandTimeOut = cReadCmdTimeOut;
   \   0023   100800         MOVW      AX,#8
   \   0026   03....         MOVW      DatTrpLocalData+18,AX
   1432              TOSStartTimer(&DatTrpLocalData.TimeOutWaitingForImmoANTReply);
   \   0029   10....         MOVW      AX,#DatTrpLocalData+12
   \   002C   ..             CALLT     [__T_TOSStartTimer]
   1433          
   1434              //----------------------------------//
   1435              // Start the sending of the message
   1436              //----------------------------------//  
   1437          
   1438              LDBReceiveWithAddr(cLDBChannelTrp, EncodedReadingCommand, &DatTrpLocalData.TransponderMessage);
   \   002D   9B....         BR        N:?Subroutine2
   \   0030                  REQUIRE ?CL78K_V4_6_L00
   1439          }

   \                                 In  segment BCODE, align 1, keep-with-next
   \                     ?Subroutine2:
   \   0000   C4             MOVW      AX,DE
   \   0001                  REQUIRE ?CL78K_V4_6_L00
   \   0001                  REQUIRE ??Subroutine6_0
   \   0001                  ; // Fall through to label ??Subroutine6_0

   \                                 In  segment BCODE, align 1, keep-with-next
   \                     ??Subroutine6_0:
   \   0000   12....         MOVW      BC,#DatTrpLocalData+8
   \   0003   16....         MOVW      HL,#LWRD(LDBTrpReceiveWithAddr)
   \   0006   A4..           MOV       E,#BYTE3(LDBTrpReceiveWithAddr)
   \   0008   ..             CALLT     [__T_?FAR_CALL_L07]
   \   0009   B2             POP       BC
   \   000A   AF             RET       
   \   000B                  REQUIRE ?CL78K_V4_6_L00
   1440          //*****************************************************************************
   1441          //  DESCRIPTION         : Start Sleep Control service.
   1442          //
   1443          //  PARAMETERS          : None
   1444          //  (Type,Name,Min,Max) 
   1445          //
   1446          //  RETURN VALUE        : None
   1447          //
   1448          //  DESIGN INFORMATION  : Refer to Detailed Design Document
   1449          //
   1450          //*****************************************************************************

   \                                 In  segment CODE, align 1, keep-with-next
   1451          void DATTrpSendSleepControl(void)
   \                     DATTrpSendSleepControl:
   1452          {
   \   0000                  ; * Stack frame (at entry) *
   \   0000                  ; Param size: 0
   \   0000   B5             PUSH      DE
   \   0001                  ; Total Auto size: 0
   1453              DatTrpLocalData.u8AuthentLocalCounter++;
   \   0001   8E....         MOV       A,DatTrpLocalData+32
   \   0004   41             INC       A
   \   0005   9E....         MOV       DatTrpLocalData+32,A
   1454          
   1455              DatTrpLocalData.CommandTimeOut = cControlTimeOut;
   \   0008   100600         MOVW      AX,#6
   \   000B   03....         MOVW      DatTrpLocalData+18,AX
   1456              TOSStartTimer(&DatTrpLocalData.TimeOutWaitingForImmoANTReply);
   \   000E   10....         MOVW      AX,#DatTrpLocalData+12
   \   0011   ..             CALLT     [__T_TOSStartTimer]
   1457              DatTrpExportData.SleepControlState = cDATTrpServiceInProgress;
   \   0012   A101           MOV       A,#1
   \   0014   16....         MOVW      HL,#DatTrpExportData+46
   \   0017   97             MOV       [HL],A
   1458              mClearFlagImmoAntAnswerReceived();
   1459              mClearFlagAnswerReceivedOK();
   \   0018   8E....         MOV       A,DatTrpLocalData+30
   \   001B   5DFC           AND       A,#252
   \   001D   9E....         MOV       DatTrpLocalData+30,A
   1460              LDBControl(cLDBChannelTrp, cLDBTrpSleep);
   \   0020   A101           MOV       A,#1
   \   0022   16....         MOVW      HL,#LWRD(LDBTrpControl)
   \   0025   A4..           MOV       E,#BYTE3(LDBTrpControl)
   \   0027   ..             CALLT     [__T_?FAR_CALL_L07]
   1461          }
   \   0028   B4             POP       DE
   \   0029   AF             RET       
   \   002A                  REQUIRE ?CL78K_V4_6_L00
   1462          
   1463          //*****************************************************************************
   1464          //  DESCRIPTION         : Sleep control finished
   1465          //
   1466          //  PARAMETERS          : None
   1467          //  (Type,Name,Min,Max) 
   1468          //
   1469          //  RETURN VALUE        : None
   1470          //
   1471          //  DESIGN INFORMATION  : Refer to Detailed Design Document
   1472          //
   1473          //*****************************************************************************

   \                                 In  segment CODE, align 1, keep-with-next
   1474          BOOL DATTrpSleepFinished(void)
   \                     DATTrpSleepFinished:
   1475          {
   \   0000                  ; * Stack frame (at entry) *
   \   0000                  ; Param size: 0
   \   0000                  ; Total Auto size: 0
   1476              return (BOOL)(DatTrpExportData.SleepControlState != cDATTrpServiceInProgress);
   \   0000   8E....         MOV       A,DatTrpExportData+46
   \   0003   51             DEC       A
   \   0004   AD03           BZ        ??DATTrpPage3InvertedDataReceivedOK_Static_0
   \   0006   A101           MOV       A,#1
   \   0008   AF             RET       
   \                     ??DATTrpPage3InvertedDataReceivedOK_Static_0:
   \   0009   A100           MOV       A,#0
   \   000B   AF             RET       
   \   000C                  REQUIRE ?CL78K_V4_6_L00
   1477          }
   1478          //*****************************************************************************
   1479          //  DESCRIPTION         : WakeUp control finished
   1480          //
   1481          //  PARAMETERS          : None
   1482          //  (Type,Name,Min,Max) 
   1483          //
   1484          //  RETURN VALUE        : None
   1485          //
   1486          //  DESIGN INFORMATION  : Refer to Detailed Design Document
   1487          //
   1488          //*****************************************************************************

   \                                 In  segment CODE, align 1, keep-with-next
   1489          BOOL DATTrpWakeUpFinished(void)
   \                     DATTrpWakeUpFinished:
   1490          {
   \   0000                  ; * Stack frame (at entry) *
   \   0000                  ; Param size: 0
   \   0000                  ; Total Auto size: 0
   1491              return (BOOL)(DatTrpExportData.WakeUpControlState == cDATTrpServiceSuccessful);
   \   0000   8E....         MOV       A,DatTrpExportData+45
   \   0003   4D02           CMP       A,#2
   \   0005   BD03           BNZ       ??DATTrpPage3InvertedDataReceivedOK_Static_1
   \   0007   A101           MOV       A,#1
   \   0009   AF             RET       
   \                     ??DATTrpPage3InvertedDataReceivedOK_Static_1:
   \   000A   A100           MOV       A,#0
   \   000C   AF             RET       
   \   000D                  REQUIRE ?CL78K_V4_6_L00
   1492          }
   1493          //*****************************************************************************
   1494          //  DESCRIPTION         : Send start authentication command to the transponder.
   1495          //
   1496          //  PARAMETERS          : None
   1497          //  (Type,Name,Min,Max) 
   1498          //
   1499          //  RETURN VALUE        : None
   1500          //
   1501          //  DESIGN INFORMATION  : Refer to Detailed Design Document
   1502          //
   1503          //*****************************************************************************

   \                                 In  segment CODE, align 1, keep-with-next
   1504          void DATTrpSendStartAuth(void)
   \                     DATTrpSendStartAuth:
   1505          {
   \   0000                  ; * Stack frame (at entry) *
   \   0000                  ; Param size: 0
   \   0000   B5             PUSH      DE
   \   0001                  ; Total Auto size: 0
   1506          #ifdef X90_PROJECT
   1507              DATTrpSendStartAuth_Static();
   \   0001   16....         MOVW      HL,#LWRD(DATTrpSendStartAuth_Static)
   \   0004   A4..           MOV       E,#BYTE3(DATTrpSendStartAuth_Static)
   \   0006   ..             CALLT     [__T_?FAR_CALL_L07]
   1508          }
   \   0007   B4             POP       DE
   \   0008   AF             RET       
   \   0009                  REQUIRE ?CL78K_V4_6_L00
   1509          #pragma optimize=no_inline

   \                                 In  segment BCODE, align 1, keep-with-next
   1510          static MEM_TYPE void DATTrpSendStartAuth_Static(void)
   \                     DATTrpSendStartAuth_Static:
   1511          {
   \   0000                  ; * Stack frame (at entry) *
   \   0000                  ; Param size: 0
   \   0000   102000         MOVW      AX,#32
   \   0003   B3             PUSH      BC
   \   0004                  ; Total Auto size: 0
   1512          #endif
   1513          
   1514              //-------------------------------------------------//
   1515              // Prepare message to receive the identifier value
   1516              //-------------------------------------------------//
   1517              DatTrpLocalData.TransponderMessage.Lng  = cIdentifierLength;
   \   0004   03....         MOVW      DatTrpLocalData+10,AX
   1518              DatTrpLocalData.u32DataBuffer            = 0;
   \   0007   70             MOV       X,A
   \   0008   03....         MOVW      DatTrpLocalData+2,AX
   \   000B   03....         MOVW      DatTrpLocalData,AX
   1519              //QACJ 0310:amanevd: Test on target prooves that this cast is compiled correct. As well as this is how it comes from reuse.
   1520              DatTrpLocalData.TransponderMessage.pBuffer = (U8*)&DatTrpLocalData.u32DataBuffer;
   \   000E   10....         MOVW      AX,#DatTrpLocalData
   \   0011   03....         MOVW      DatTrpLocalData+8,AX
   1521          
   1522              //------------------------------------------//
   1523              // Indicate that answer is not received yet
   1524              //------------------------------------------//
   1525              mClearFlagImmoAntAnswerReceived();
   1526              mClearFlagAnswerReceivedOK();
   \   0014   8E....         MOV       A,DatTrpLocalData+30
   \   0017   5DFC           AND       A,#252
   \   0019   9E....         MOV       DatTrpLocalData+30,A
   1527          
   1528              //---------------------------//
   1529              // Start communication timer
   1530              //---------------------------//
   1531              DatTrpLocalData.CommandTimeOut = cIDEReadingTimeOut;
   \   001C   100600         MOVW      AX,#6
   \   001F   03....         MOVW      DatTrpLocalData+18,AX
   1532              TOSStartTimer(&DatTrpLocalData.TimeOutWaitingForImmoANTReply);
   \   0022   10....         MOVW      AX,#DatTrpLocalData+12
   \   0025   ..             CALLT     [__T_TOSStartTimer]
   1533          
   1534              //---------------------------//
   1535              // prsFS_IMMO-683:
   1536              // increase by 1 the counter "compt_nb_int" 
   1537              //---------------------------//
   1538              DatTrpExportData.AuthentTryCounter++;
   \   0026   8E....         MOV       A,DatTrpExportData+43
   \   0029   41             INC       A
   \   002A   9E....         MOV       DatTrpExportData+43,A
   1539          
   1540              //----------------------------------//
   1541              // Start the sending of the message
   1542              //----------------------------------//
   1543          
   1544              LDBReceiveWithAddr(cLDBChannelTrp, cLDBTrpStartAuth, &DatTrpLocalData.TransponderMessage);
   \   002D   101800         MOVW      AX,#24
   \   0030   9B....         BR        N:??Subroutine6_0
   \   0033                  REQUIRE ?CL78K_V4_6_L00
   1545          }
   1546          //*****************************************************************************
   1547          //  DESCRIPTION         : Write Access service not successful.
   1548          //
   1549          //  PARAMETERS          : None
   1550          //  (Type,Name,Min,Max) 
   1551          //
   1552          //  RETURN VALUE        : None
   1553          //
   1554          //  DESIGN INFORMATION  : Refer to Detailed Design Document
   1555          //
   1556          //*****************************************************************************

   \                                 In  segment CODE, align 1, keep-with-next
   1557          void DATTrpWriteNotSuccess(void)
   \                     DATTrpWriteNotSuccess:
   1558          {
   \   0000                  ; * Stack frame (at entry) *
   \   0000                  ; Param size: 0
   \   0000                  ; Total Auto size: 0
   1559              mLIBassert(DatTrpExportData.WriteAccessState == cDATTrpServiceInProgress);
   1560          
   1561              DatTrpExportData.WriteAccessState = cDATTrpServiceNotSuccessful;
   \   0000   A103           MOV       A,#3
   \   0002                  REQUIRE ?CL78K_V4_6_L00
   \   0002                  REQUIRE ?Subroutine1
   \   0002                  ; // Fall through to label ?Subroutine1
   1562          }

   \                                 In  segment CODE, align 1, keep-with-next
   \                     ?Subroutine1:
   \   0000   16....         MOVW      HL,#DatTrpExportData+48
   \   0003   97             MOV       [HL],A
   \   0004   AF             RET       
   \   0005                  REQUIRE ?CL78K_V4_6_L00
   1563          //*****************************************************************************
   1564          //  DESCRIPTION         : Write Access service successful.
   1565          //
   1566          //  PARAMETERS          : None
   1567          //  (Type,Name,Min,Max) 
   1568          //
   1569          //  RETURN VALUE        : None
   1570          //
   1571          //  DESIGN INFORMATION  : Refer to Detailed Design Document
   1572          //
   1573          //*****************************************************************************

   \                                 In  segment CODE, align 1, keep-with-next
   1574          void DATTrpWriteSuccess(void)
   \                     DATTrpWriteSuccess:
   1575          {
   \   0000                  ; * Stack frame (at entry) *
   \   0000                  ; Param size: 0
   \   0000                  ; Total Auto size: 0
   1576              mLIBassert(DatTrpExportData.WriteAccessState == cDATTrpServiceInProgress);
   1577          
   1578          
   1579              DatTrpExportData.WriteAccessWritingError = 0;
   1580              DatTrpExportData.WriteAccessReadingError = 0;
   \   0000   8E....         MOV       A,DatTrpExportData+51
   \   0003   5D9F           AND       A,#159
   \   0005   9E....         MOV       DatTrpExportData+51,A
   1581          
   1582              DatTrpExportData.WriteAccessState = cDATTrpServiceSuccessful;
   \   0008   A102           MOV       A,#2
   \   000A   9B....         BR        N:?Subroutine1
   \   000D                  REQUIRE ?CL78K_V4_6_L00
   1583          }
   1584          //*****************************************************************************
   1585          //  DESCRIPTION         : Test if there is a transponder answer error or a 
   1586          //                        time out on the current command.
   1587          //
   1588          //  PARAMETERS          : None
   1589          //  (Type,Name,Min,Max) 
   1590          //
   1591          //  RETURN VALUE        : cFalse or cTrue.
   1592          //
   1593          //  DESIGN INFORMATION  : Refer to Detailed Design Document
   1594          //
   1595          //*****************************************************************************

   \                                 In  segment CODE, align 1, keep-with-next
   1596          BOOL DATTrpAnswerReceivedNOKOrTimeOut(void)
   \                     DATTrpAnswerReceivedNOKOrTimeOut:
   1597          {
   \   0000                  ; * Stack frame (at entry) *
   \   0000                  ; Param size: 0
   \   0000   B3             PUSH      BC
   \   0001                  ; Total Auto size: 0
   1598              const BOOL bTimerElapsedL = TOSIsTimerElapsed(
   1599                              &DatTrpLocalData.TimeOutWaitingForImmoANTReply, 
   1600                              DatTrpLocalData.CommandTimeOut);
   \   0001   02....         MOVW      AX,DatTrpLocalData+18
   \   0004   D2             MOVW      BC,AX
   \   0005   10....         MOVW      AX,#DatTrpLocalData+12
   \   0008   ..             CALLT     [__T_TOSIsTimerElapsed]
   \   0009   70             MOV       X,A
   1601          
   1602              return  (   
   1603                          (  
   1604                              (cFalse == (BOOL)mGetFlagAnswerReceivedOK())
   1605                           && (cTrue == (BOOL)mGetFlagImmoAntAnswerReceived()) 
   1606                          )
   1607                       || (cFalse != bTimerElapsedL)
   1608                      );
   \   000A   8E....         MOV       A,DatTrpLocalData+30
   \   000D   5D03           AND       A,#3
   \   000F   51             DEC       A
   \   0010   AD05           BZ        ??DATTrpPage3InvertedDataReceivedOK_Static_2
   \   0012   60             MOV       A,X
   \   0013   4D00           CMP       A,#0
   \   0015   AD04           BZ        ??DATTrpPage3InvertedDataReceivedOK_Static_3
   \                     ??DATTrpPage3InvertedDataReceivedOK_Static_2:
   \   0017   A101           MOV       A,#1
   \   0019   FA02           BR        ??DATTrpPage3InvertedDataReceivedOK_Static_4
   \                     ??DATTrpPage3InvertedDataReceivedOK_Static_3:
   \   001B   A100           MOV       A,#0
   \                     ??DATTrpPage3InvertedDataReceivedOK_Static_4:
   \   001D   B2             POP       BC
   \   001E   AF             RET       
   \   001F                  REQUIRE ?CL78K_V4_6_L00
   1609          }
   1610          
   1611          //*****************************************************************************
   1612          //  DESCRIPTION         : Wake Up Control Not Successful.
   1613          //
   1614          //  PARAMETERS          : None
   1615          //  (Type,Name,Min,Max) 
   1616          //
   1617          //  RETURN VALUE        : None
   1618          //
   1619          //  DESIGN INFORMATION  : Refer to Detailed Design Document
   1620          //
   1621          //*****************************************************************************

   \                                 In  segment CODE, align 1, keep-with-next
   1622          void DATTrpOnWakeUpControlNotSuccessful(void)
   \                     DATTrpOnWakeUpControlNotSuccessful:
   1623          {
   \   0000                  ; * Stack frame (at entry) *
   \   0000                  ; Param size: 0
   \   0000                  ; Total Auto size: 0
   1624              DatTrpExportData.WakeUpControlState = cDATTrpServiceNotSuccessful;
   \   0000   A103           MOV       A,#3
   \   0002   16....         MOVW      HL,#DatTrpExportData+45
   \   0005   97             MOV       [HL],A
   1625          }
   \   0006   AF             RET       
   \   0007                  REQUIRE ?CL78K_V4_6_L00
   1626          
   1627          //*****************************************************************************
   1628          //  DESCRIPTION         : Start Wake Up Control service.
   1629          //
   1630          //  PARAMETERS          : None
   1631          //  (Type,Name,Min,Max) 
   1632          //
   1633          //  RETURN VALUE        : None
   1634          //
   1635          //  DESIGN INFORMATION  : Refer to Detailed Design Document
   1636          //
   1637          //*****************************************************************************

   \                                 In  segment CODE, align 1, keep-with-next
   1638          void DATTrpSendWakeUpControl(void)
   \                     DATTrpSendWakeUpControl:
   1639          {
   \   0000                  ; * Stack frame (at entry) *
   \   0000                  ; Param size: 0
   \   0000   B5             PUSH      DE
   \   0001                  ; Total Auto size: 0
   1640          #ifdef X90_PROJECT
   1641              DATTrpSendWakeUpControl_Static();
   \   0001   16....         MOVW      HL,#LWRD(DATTrpSendWakeUpControl_Static)
   \   0004   A4..           MOV       E,#BYTE3(DATTrpSendWakeUpControl_Static)
   \   0006   ..             CALLT     [__T_?FAR_CALL_L07]
   1642          }
   \   0007   B4             POP       DE
   \   0008   AF             RET       
   \   0009                  REQUIRE ?CL78K_V4_6_L00
   1643          #pragma optimize=no_inline

   \                                 In  segment BCODE, align 1, keep-with-next
   1644          static MEM_TYPE void DATTrpSendWakeUpControl_Static(void)
   \                     DATTrpSendWakeUpControl_Static:
   1645          {
   \   0000                  ; * Stack frame (at entry) *
   \   0000                  ; Param size: 0
   \   0000                  ; Total Auto size: 0
   1646          #endif
   1647              mLIBassert(DatTrpExportData.WakeUpControlState != cDATTrpServiceInProgress);
   1648              DatTrpLocalData.CommandTimeOut = cControlTimeOut;
   \   0000   100600         MOVW      AX,#6
   \   0003   03....         MOVW      DatTrpLocalData+18,AX
   1649              TOSStartTimer(&DatTrpLocalData.TimeOutWaitingForImmoANTReply);
   \   0006   10....         MOVW      AX,#DatTrpLocalData+12
   \   0009   ..             CALLT     [__T_TOSStartTimer]
   1650              DatTrpExportData.WakeUpControlState = cDATTrpServiceInProgress;
   \   000A   A101           MOV       A,#1
   \   000C   16....         MOVW      HL,#DatTrpExportData+45
   \   000F   97             MOV       [HL],A
   1651              mClearFlagImmoAntAnswerReceived();
   1652              mClearFlagAnswerReceivedOK();
   \   0010   8E....         MOV       A,DatTrpLocalData+30
   \   0013   5DFC           AND       A,#252
   \   0015   9E....         MOV       DatTrpLocalData+30,A
   1653              LDBControl(cLDBChannelTrp, cLDBTrpWakeUp);
   \   0018   A100           MOV       A,#0
   \   001A   9B....         BR        N:?Subroutine4
   \   001D                  REQUIRE ?CL78K_V4_6_L00
   1654          }
   1655          //*****************************************************************************
   1656          //  DESCRIPTION         : Test if authentication service is not successfully 
   1657          //                        finished.
   1658          //
   1659          //  PARAMETERS          : None
   1660          //  (Type,Name,Min,Max) 
   1661          //
   1662          //  RETURN VALUE        : cFalse or cTrue
   1663          //
   1664          //  DESIGN INFORMATION  : Refer to Detailed Design Document
   1665          //
   1666          //*****************************************************************************

   \                                 In  segment CODE, align 1, keep-with-next
   1667          BOOL DATTrpAuhenticationServiceFinishedNOK(void)
   \                     DATTrpAuhenticationServiceFinishedNOK:
   1668          {
   \   0000                  ; * Stack frame (at entry) *
   \   0000                  ; Param size: 0
   \   0000                  ; Total Auto size: 0
   1669              return (BOOL)(DatTrpExportData.AuthenticationState == cDATTrpServiceNotSuccessful);
   \   0000   8E....         MOV       A,DatTrpExportData+44
   \   0003   4D03           CMP       A,#3
   \   0005   BD03           BNZ       ??DATTrpPage3InvertedDataReceivedOK_Static_5
   \   0007   A101           MOV       A,#1
   \   0009   AF             RET       
   \                     ??DATTrpPage3InvertedDataReceivedOK_Static_5:
   \   000A   A100           MOV       A,#0
   \   000C   AF             RET       
   \   000D                  REQUIRE ?CL78K_V4_6_L00
   1670          }
   1671          //*****************************************************************************
   1672          //  DESCRIPTION         : Test if authentication service is successfully 
   1673          //                        finished.
   1674          //
   1675          //  PARAMETERS          : None
   1676          //  (Type,Name,Min,Max) 
   1677          //
   1678          //  RETURN VALUE        : cFalse or cTrue
   1679          //
   1680          //  DESIGN INFORMATION  : Refer to Detailed Design Document
   1681          //
   1682          //*****************************************************************************

   \                                 In  segment CODE, align 1, keep-with-next
   1683          BOOL DATTrpAuhenticationServiceFinishedOK(void)
   \                     DATTrpAuhenticationServiceFinishedOK:
   1684          {
   \   0000                  ; * Stack frame (at entry) *
   \   0000                  ; Param size: 0
   \   0000                  ; Total Auto size: 0
   1685              return (BOOL)(DatTrpExportData.AuthenticationState == cDATTrpServiceSuccessful);
   \   0000   8E....         MOV       A,DatTrpExportData+44
   \   0003   4D02           CMP       A,#2
   \   0005   BD03           BNZ       ??DATTrpPage3InvertedDataReceivedOK_Static_6
   \   0007   A101           MOV       A,#1
   \   0009   AF             RET       
   \                     ??DATTrpPage3InvertedDataReceivedOK_Static_6:
   \   000A   A100           MOV       A,#0
   \   000C   AF             RET       
   \   000D                  REQUIRE ?CL78K_V4_6_L00
   1686          }
   1687          //*****************************************************************************
   1688          //  DESCRIPTION         : Test if a new authentication is authorized.
   1689          //
   1690          //  PARAMETERS          : None
   1691          //  (Type,Name,Min,Max) 
   1692          //
   1693          //  RETURN VALUE        : cFalse or cTrue
   1694          //
   1695          //  DESIGN INFORMATION  : Refer to Detailed Design Document 
   1696          //
   1697          //*****************************************************************************

   \                                 In  segment CODE, align 1, keep-with-next
   1698          BOOL DATTrpNewAuthenticationAuthorized(void)
   \                     DATTrpNewAuthenticationAuthorized:
   1699          {
   \   0000                  ; * Stack frame (at entry) *
   \   0000                  ; Param size: 0
   \   0000   B5             PUSH      DE
   \   0001                  ; Total Auto size: 0
   1700          #ifdef X90_PROJECT
   1701              return DATTrpNewAuthenticationAuthorized_Static();
   \   0001   16....         MOVW      HL,#LWRD(DATTrpNewAuthenticationAuthorized_Static)
   \   0004   A4..           MOV       E,#BYTE3(DATTrpNewAuthenticationAuthorized_Static)
   \   0006   ..             CALLT     [__T_?FAR_CALL_L07]
   \   0007   B4             POP       DE
   \   0008   AF             RET       
   \   0009                  REQUIRE ?CL78K_V4_6_L00
   1702          }
   1703          #pragma optimize=no_inline

   \                                 In  segment BCODE, align 1, keep-with-next
   1704          static MEM_TYPE BOOL DATTrpNewAuthenticationAuthorized_Static(void)
   \                     DATTrpNewAuthenticationAuthorized_Static:
   1705          {
   \   0000                  ; * Stack frame (at entry) *
   \   0000                  ; Param size: 0
   \   0000   B3             PUSH      BC
   \   0001                  ; Total Auto size: 0
   1706          #endif
   1707          
   1708              BOOL    bResultL = cFalse;
   \   0001   A000           MOV       X,#0
   1709              tTOSTimer   TempTimer;
   1710          
   1711              if (cFalse == (BOOL)DatTrpExportData.ActiveTestMode)
   \   0003   16....         MOVW      HL,#DatTrpExportData+50
   \   0006   31A64B         BT        [HL].2, ??DATTrpPage3InvertedDataReceivedOK_Static_66
   1712              {
   1713                  if (cFalse == (BOOL)DatTrpExportData.AuthentInLearningMode)
   \   0009   8E....         MOV       A,DatTrpLocalData+32
   \   000C   318636         BT        [HL].0, ??DATTrpPage3InvertedDataReceivedOK_Static_67
   1714                  {
   1715                      // (REQ: prsFS_IMMO-479)
   1716                      if(DatTrpLocalData.u8AuthentLocalCounter < cMaxAuthentTrialsCustomerMode)
   \   000F   4D03           CMP       A,#3
   \   0011   9D41           BNC       ??DATTrpPage3InvertedDataReceivedOK_Static_66
   1717                      {
   1718                          //QACJ 3226: amanevd: This is intentional and is checked out for problems.
   1719                          TempTimer = mTimeOutAuthent();
   \   0013   02....         MOVW      AX,DatTrpLocalData+28
   \   0016   30             XCH       A,X
   \   0017   18....         SUB       A,DATDbkMirrors+30
   \   001A   30             XCH       A,X
   \   001B   38....         SUBC      A,DATDbkMirrors+31
   \   001E   6168           OR        A,X
   \   0020   BD05           BNZ       ??DATTrpPage3InvertedDataReceivedOK_Static_68
   \   0022   02....         MOVW      AX,DatTrpLocalData+20
   \   0025   FA0A           BR        ??DATTrpPage3InvertedDataReceivedOK_Static_69
   \                     ??DATTrpPage3InvertedDataReceivedOK_Static_68:
   \   0027   02....         MOVW      AX,DATDbkMirrors+30
   \   002A   03....         MOVW      DatTrpLocalData+28,AX
   \   002D   A20A           MOV       C,#10
   \   002F   3182           DIVUW     C
   \                     ??DATTrpPage3InvertedDataReceivedOK_Static_69:
   \   0031   03....         MOVW      DatTrpLocalData+20,AX
   1720                          bResultL = TOSIsTimerElapsed(&(DatTrpLocalData.AuthenticationTimeOut), 
   1721                                                      TempTimer);
   1722                          bResultL = (cFalse == bResultL);
   \   0034   D2             MOVW      BC,AX
   \   0035   10....         MOVW      AX,#DatTrpLocalData+16
   \   0038   ..             CALLT     [__T_TOSIsTimerElapsed]
   \   0039   4D00           CMP       A,#0
   \   003B   BD04           BNZ       ??DATTrpPage3InvertedDataReceivedOK_Static_70
   \                     ??DATTrpNewAuthenticationAuthorized_Static_0:
   \   003D   A001           MOV       X,#1
   \   003F   FA13           BR        ??DATTrpPage3InvertedDataReceivedOK_Static_66
   \                     ??DATTrpPage3InvertedDataReceivedOK_Static_70:
   \   0041   A000           MOV       X,#0
   \   0043   FA0F           BR        ??DATTrpPage3InvertedDataReceivedOK_Static_66
   1723                      }
   1724                  }
   1725                  else
   1726                  {
   1727                      if(DatTrpLocalData.u8AuthentLocalCounter < cMaxAuthentTrialsLearningMode)
   \                     ??DATTrpPage3InvertedDataReceivedOK_Static_67:
   \   0045   4D02           CMP       A,#2
   \   0047   9D0B           BNC       ??DATTrpPage3InvertedDataReceivedOK_Static_66
   1728                      {
   1729                          bResultL = (     (cFalse == (BOOL)DatTrpExportData.KeyLearningElapsed)
   1730                                      &&  (cFalse == DatTrpLocalData.bStopAuthentService)
   1731                                    );
   \   0049   86             INCW      HL
   \   004A   31C607         BT        [HL].4, ??DATTrpPage3InvertedDataReceivedOK_Static_66
   \   004D   8E....         MOV       A,DatTrpLocalData+37
   \   0050   4D00           CMP       A,#0
   \   0052   ADE9           BZ        ??DATTrpNewAuthenticationAuthorized_Static_0
   1732                      }
   1733                  }
   1734              }    
   1735              return (bResultL);
   \                     ??DATTrpPage3InvertedDataReceivedOK_Static_66:
   \   0054   60             MOV       A,X
   \   0055   B2             POP       BC
   \   0056   AF             RET       
   \   0057                  REQUIRE ?CL78K_V4_6_L00
   1736          }
   1737          //*****************************************************************************
   1738          //  DESCRIPTION         : Increase Retry Counters
   1739          //
   1740          //  PARAMETERS          : None
   1741          //  (Type,Name,Min,Max) 
   1742          //
   1743          //  RETURN VALUE        : None
   1744          //
   1745          //  DESIGN INFORMATION  : Refer to Detailed Design Document (REQ: prsFS_IMMO-480)
   1746          //
   1747          //*****************************************************************************

   \                                 In  segment CODE, align 1, keep-with-next
   1748          void DATTrpIncreaseRetryCounters(void)
   \                     DATTrpIncreaseRetryCounters:
   1749          {
   \   0000                  ; * Stack frame (at entry) *
   \   0000                  ; Param size: 0
   \   0000                  ; Total Auto size: 0
   1750              U8 u8AuthentDelayedCounterL = mDATRead(U8Bit, EEP_AuthentDelayedCounter, Default);
   \   0000   8E....         MOV       A,DATDbkMirrors+1
   1751          
   1752              if(u8AuthentDelayedCounterL < cMaxAuthentDelayedCounter)
   \   0003   41             INC       A
   \   0004   AD08           BZ        ??DATTrpPage3InvertedDataReceivedOK_Static_7
   1753              {
   1754                  u8AuthentDelayedCounterL++;
   1755                  mDATWrite(U8Bit, EEP_AuthentDelayedCounter, u8AuthentDelayedCounterL, Default);
   \   0006   9E....         MOV       DATDbkMirrors+1,A
   \   0009   A100           MOV       A,#0
   \   000B   9A....         CALL      DATDbkStartUpdate
   1756              }
   1757          }
   \                     ??DATTrpPage3InvertedDataReceivedOK_Static_7:
   \   000E   AF             RET       
   \   000F                  REQUIRE ?CL78K_V4_6_L00
   1758          
   1759          //*****************************************************************************
   1760          //  DESCRIPTION         : Resynchronization service not successful.
   1761          //
   1762          //  PARAMETERS          : None
   1763          //  (Type,Name,Min,Max) 
   1764          //
   1765          //  RETURN VALUE        : None
   1766          //
   1767          //  DESIGN INFORMATION  : Refer to Detailed Design Document
   1768          //
   1769          //*****************************************************************************

   \                                 In  segment CODE, align 1, keep-with-next
   1770          void DATTrpResynchronizationNotSuccess(void)
   \                     DATTrpResynchronizationNotSuccess:
   1771          {
   \   0000                  ; * Stack frame (at entry) *
   \   0000                  ; Param size: 0
   \   0000   B5             PUSH      DE
   \   0001                  ; Total Auto size: 0
   1772          #ifdef X90_PROJECT
   1773              DATTrpResynchronizationNotSuccess_Static();
   \   0001   16....         MOVW      HL,#LWRD(DATTrpResynchronizationNotSuccess_Static)
   \   0004   A4..           MOV       E,#BYTE3(DATTrpResynchronizationNotSuccess_Static)
   \   0006   ..             CALLT     [__T_?FAR_CALL_L07]
   1774          }
   \   0007   B4             POP       DE
   \   0008   AF             RET       
   \   0009                  REQUIRE ?CL78K_V4_6_L00
   1775          #pragma optimize=no_inline

   \                                 In  segment BCODE, align 1, keep-with-next
   1776          static MEM_TYPE void DATTrpResynchronizationNotSuccess_Static(void)
   \                     DATTrpResynchronizationNotSuccess_Static:
   1777          {
   \   0000                  ; * Stack frame (at entry) *
   \   0000                  ; Param size: 0
   \   0000   B3             PUSH      BC
   \   0001                  ; Total Auto size: 0
   1778          #endif
   1779          
   1780              U8 ucResynchroFailureL;
   1781          
   1782              mLIBassert(   (DatTrpExportData.ResynchronizationState == cDATTrpServiceInProgress)
   1783                  || ((cFalse == (BOOL)DatTrpExportData.AuthentInLearningMode) && (DatTrpExportData.IndexOfKeyRecognized < cDATTrpMaxNumberOfKey)) );
   1784          
   1785              if (cFalse == (BOOL)DatTrpExportData.ActiveTestMode)
   \   0001   16....         MOVW      HL,#DatTrpExportData+50
   \   0004   31A703         BF        [HL].2, $+6
   \   0007   9B....         BR        N:??DATTrpPage3InvertedDataReceivedOK_Static_71
   1786              {
   1787                  //------------------------------------------//
   1788                  // Update resynchronization failure counter
   1789                  //------------------------------------------//
   1790                  ucResynchroFailureL = mDATRead(U8Bit, EEP_ResynchroFailureCounter, Default);
   \   000A   8E....         MOV       A,DATDbkMirrors+3
   \   000D   72             MOV       C,A
   1791                  if (ucResynchroFailureL < cMaxWritingDefault)
   \   000E   41             INC       A
   \   000F   AD13           BZ        ??DATTrpPage3InvertedDataReceivedOK_Static_72
   1792                  {
   1793                      mDATWrite(U8Bit, EEP_ResynchroFailureCounter, (ucResynchroFailureL + 1), Default);
   \   0011   62             MOV       A,C
   \   0012   70             MOV       X,A
   \   0013   A100           MOV       A,#0
   \   0015   80             INCW      AX
   \   0016   5DFF           AND       A,#255
   \   0018   BD05           BNZ       ??DATTrpPage3InvertedDataReceivedOK_Static_73
   \   001A   42             INC       C
   \   001B   62             MOV       A,C
   \   001C   9E....         MOV       DATDbkMirrors+3,A
   \                     ??DATTrpPage3InvertedDataReceivedOK_Static_73:
   \   001F   A100           MOV       A,#0
   \   0021   9A....         CALL      DATDbkStartUpdate
   1794                  }
   1795          
   1796                  // Writing in EEPROM is not authorized as long as the learning mode is in progress.
   1797                  if (cFalse == (BOOL)DatTrpExportData.AuthentInLearningMode)
   \                     ??DATTrpPage3InvertedDataReceivedOK_Static_72:
   \   0024   16....         MOVW      HL,#DatTrpExportData+50
   \   0027   318703         BF        [HL].0, $+6
   \   002A   9B....         BR        N:??DATTrpPage3InvertedDataReceivedOK_Static_71
   1798                  {
   1799                      //------------------------------------------------------------//
   1800                      // Write the last reading data or the default value in EEPROM
   1801                      //------------------------------------------------------------//
   1802                      mDATWriteTable(U32Bit, EEP_DefResynchroValueRead, DatTrpExportData.IndexOfKeyRecognized, DatTrpExportData.DataRead, Default);
   \   002D   8E....         MOV       A,DatTrpExportData+41
   \   0030   A004           MOV       X,#4
   \   0032   3188           MULU      X
   \   0034   CA....         ADDW      AX,#DATDbkMirrors+178
   \   0037   D6             MOVW      HL,AX
   \   0038   87             MOV       A,[HL]
   \   0039   70             MOV       X,A
   \   003A   AE01           MOV       A,[HL+0x01]
   \   003C   D2             MOVW      BC,AX
   \   003D   100000         MOVW      AX,#0
   \   0040   B3             PUSH      BC
   \   0041   B1             PUSH      AX
   \   0042   8E....         MOV       A,DatTrpExportData+41
   \   0045   A004           MOV       X,#4
   \   0047   3188           MULU      X
   \   0049   CA....         ADDW      AX,#DATDbkMirrors+176
   \   004C   D6             MOVW      HL,AX
   \   004D   87             MOV       A,[HL]
   \   004E   70             MOV       X,A
   \   004F   AE01           MOV       A,[HL+0x01]
   \   0051   120000         MOVW      BC,#0
   \   0054   D6             MOVW      HL,AX
   \   0055   891C           MOVW      AX,SP
   \   0057   E6             XCHW      AX,HL
   \   0058   E2             XCHW      AX,BC
   \   0059   0902           ADD       A,[HL+0x02]
   \   005B   30             XCH       A,X
   \   005C   0903           ADD       A,[HL+0x03]
   \   005E   E2             XCHW      AX,BC
   \   005F   B6             POP       HL
   \   0060   B6             POP       HL
   \   0061   B5             PUSH      DE
   \   0062   D4             MOVW      DE,AX
   \   0063   64             MOV       A,E
   \   0064   18....         SUB       A,DatTrpExportData+16
   \   0067   70             MOV       X,A
   \   0068   65             MOV       A,D
   \   0069   38....         SUBC      A,DatTrpExportData+17
   \   006C   6160           OR        X,A
   \   006E   62             MOV       A,C
   \   006F   38....         SUBC      A,DatTrpExportData+18
   \   0072   6160           OR        X,A
   \   0074   63             MOV       A,B
   \   0075   38....         SUBC      A,DatTrpExportData+19
   \   0078   6160           OR        X,A
   \   007A   B4             POP       DE
   \   007B   AD2D           BZ        ??DATTrpPage3InvertedDataReceivedOK_Static_74
   \   007D   02....         MOVW      AX,DatTrpExportData+16
   \   0080   D4             MOVW      DE,AX
   \   0081   8E....         MOV       A,DatTrpExportData+41
   \   0084   A004           MOV       X,#4
   \   0086   3188           MULU      X
   \   0088   CA....         ADDW      AX,#DATDbkMirrors+176
   \   008B   D6             MOVW      HL,AX
   \   008C   C4             MOVW      AX,DE
   \   008D   BE01           MOV       [HL+0x01],A
   \   008F   60             MOV       A,X
   \   0090   97             MOV       [HL],A
   \   0091   02....         MOVW      AX,DatTrpExportData+18
   \   0094   D4             MOVW      DE,AX
   \   0095   8E....         MOV       A,DatTrpExportData+41
   \   0098   A004           MOV       X,#4
   \   009A   3188           MULU      X
   \   009C   CA....         ADDW      AX,#DATDbkMirrors+178
   \   009F   D6             MOVW      HL,AX
   \   00A0   C4             MOVW      AX,DE
   \   00A1   BE01           MOV       [HL+0x01],A
   \   00A3   60             MOV       A,X
   \   00A4   97             MOV       [HL],A
   \   00A5   A104           MOV       A,#4
   \   00A7   9A....         CALL      DATDbkStartUpdate
   1803          
   1804                      //---------------------------------------//
   1805                      // Write the last writing data in EEPROM
   1806                      //---------------------------------------//
   1807                      mDATWriteTable(U32Bit, EEP_DefResynchroValueWrite, DatTrpExportData.IndexOfKeyRecognized, DatTrpExportData.ResynchronizationValue, Default);
   \                     ??DATTrpPage3InvertedDataReceivedOK_Static_74:
   \   00AA   8E....         MOV       A,DatTrpExportData+41
   \   00AD   A004           MOV       X,#4
   \   00AF   3188           MULU      X
   \   00B1   CA....         ADDW      AX,#DATDbkMirrors+194
   \   00B4   D6             MOVW      HL,AX
   \   00B5   87             MOV       A,[HL]
   \   00B6   70             MOV       X,A
   \   00B7   AE01           MOV       A,[HL+0x01]
   \   00B9   D2             MOVW      BC,AX
   \   00BA   100000         MOVW      AX,#0
   \   00BD   B3             PUSH      BC
   \   00BE   B1             PUSH      AX
   \   00BF   8E....         MOV       A,DatTrpExportData+41
   \   00C2   A004           MOV       X,#4
   \   00C4   3188           MULU      X
   \   00C6   CA....         ADDW      AX,#DATDbkMirrors+192
   \   00C9   D6             MOVW      HL,AX
   \   00CA   87             MOV       A,[HL]
   \   00CB   70             MOV       X,A
   \   00CC   AE01           MOV       A,[HL+0x01]
   \   00CE   120000         MOVW      BC,#0
   \   00D1   D6             MOVW      HL,AX
   \   00D2   891C           MOVW      AX,SP
   \   00D4   E6             XCHW      AX,HL
   \   00D5   E2             XCHW      AX,BC
   \   00D6   0902           ADD       A,[HL+0x02]
   \   00D8   30             XCH       A,X
   \   00D9   0903           ADD       A,[HL+0x03]
   \   00DB   E2             XCHW      AX,BC
   \   00DC   B6             POP       HL
   \   00DD   B6             POP       HL
   \   00DE   B5             PUSH      DE
   \   00DF   D4             MOVW      DE,AX
   \   00E0   64             MOV       A,E
   \   00E1   18....         SUB       A,DatTrpExportData+20
   \   00E4   70             MOV       X,A
   \   00E5   65             MOV       A,D
   \   00E6   38....         SUBC      A,DatTrpExportData+21
   \   00E9   6160           OR        X,A
   \   00EB   62             MOV       A,C
   \   00EC   38....         SUBC      A,DatTrpExportData+22
   \   00EF   6160           OR        X,A
   \   00F1   63             MOV       A,B
   \   00F2   38....         SUBC      A,DatTrpExportData+23
   \   00F5   6160           OR        X,A
   \   00F7   B4             POP       DE
   \   00F8   AD2D           BZ        ??DATTrpPage3InvertedDataReceivedOK_Static_71
   \   00FA   02....         MOVW      AX,DatTrpExportData+20
   \   00FD   D4             MOVW      DE,AX
   \   00FE   8E....         MOV       A,DatTrpExportData+41
   \   0101   A004           MOV       X,#4
   \   0103   3188           MULU      X
   \   0105   CA....         ADDW      AX,#DATDbkMirrors+192
   \   0108   D6             MOVW      HL,AX
   \   0109   C4             MOVW      AX,DE
   \   010A   BE01           MOV       [HL+0x01],A
   \   010C   60             MOV       A,X
   \   010D   97             MOV       [HL],A
   \   010E   02....         MOVW      AX,DatTrpExportData+22
   \   0111   D4             MOVW      DE,AX
   \   0112   8E....         MOV       A,DatTrpExportData+41
   \   0115   A004           MOV       X,#4
   \   0117   3188           MULU      X
   \   0119   CA....         ADDW      AX,#DATDbkMirrors+194
   \   011C   D6             MOVW      HL,AX
   \   011D   C4             MOVW      AX,DE
   \   011E   BE01           MOV       [HL+0x01],A
   \   0120   60             MOV       A,X
   \   0121   97             MOV       [HL],A
   \   0122   A104           MOV       A,#4
   \   0124   9A....         CALL      DATDbkStartUpdate
   1808                  }
   1809              }
   1810          
   1811              DatTrpExportData.ResynchronizationState = cDATTrpServiceNotSuccessful;
   \                     ??DATTrpPage3InvertedDataReceivedOK_Static_71:
   \   0127   A103           MOV       A,#3
   \   0129                  REQUIRE ?CL78K_V4_6_L00
   \   0129                  REQUIRE ?Subroutine5
   \   0129                  ; // Fall through to label ?Subroutine5
   1812          }

   \                                 In  segment BCODE, align 1, keep-with-next
   \                     ?Subroutine5:
   \   0000   16....         MOVW      HL,#DatTrpExportData+49
   \   0003   97             MOV       [HL],A
   \   0004   B2             POP       BC
   \   0005   AF             RET       
   \   0006                  REQUIRE ?CL78K_V4_6_L00
   1813          //*****************************************************************************
   1814          //  DESCRIPTION         : Resynchronization service successful.
   1815          //
   1816          //  PARAMETERS          : None
   1817          //  (Type,Name,Min,Max) 
   1818          //
   1819          //  RETURN VALUE        : None
   1820          //
   1821          //  DESIGN INFORMATION  : Refer to Detailed Design Document
   1822          //
   1823          //*****************************************************************************

   \                                 In  segment CODE, align 1, keep-with-next
   1824          void DATTrpResynchronizationSuccess(void)
   \                     DATTrpResynchronizationSuccess:
   1825          {
   \   0000                  ; * Stack frame (at entry) *
   \   0000                  ; Param size: 0
   \   0000   B5             PUSH      DE
   \   0001                  ; Total Auto size: 0
   1826          #ifdef X90_PROJECT
   1827              DATTrpResynchronizationSuccess_Static();
   \   0001   16....         MOVW      HL,#LWRD(DATTrpResynchronizationSuccess_Static)
   \   0004   A4..           MOV       E,#BYTE3(DATTrpResynchronizationSuccess_Static)
   \   0006   ..             CALLT     [__T_?FAR_CALL_L07]
   1828          }
   \   0007   B4             POP       DE
   \   0008   AF             RET       
   \   0009                  REQUIRE ?CL78K_V4_6_L00
   1829          #pragma optimize=no_inline

   \                                 In  segment BCODE, align 1, keep-with-next
   1830          static MEM_TYPE void DATTrpResynchronizationSuccess_Static(void)
   \                     DATTrpResynchronizationSuccess_Static:
   1831          {
   \   0000                  ; * Stack frame (at entry) *
   \   0000                  ; Param size: 0
   \   0000   B3             PUSH      BC
   \   0001                  ; Total Auto size: 0
   1832          #endif
   1833          
   1834              U8 ucClearResynchroFlagL;
   1835              U8 ucResynchroSuccessfulL;
   1836          
   1837              mLIBassert((cTrue == (BOOL)DatTrpExportData.AuthentInLearningMode) || (DatTrpExportData.IndexOfKeyRecognized < cDATTrpMaxNumberOfKey));
   1838              mLIBassert(DatTrpExportData.ResynchronizationState == cDATTrpServiceInProgress);
   1839          
   1840              if (cFalse == (BOOL)DatTrpExportData.ActiveTestMode)
   \   0001   16....         MOVW      HL,#DatTrpExportData+50
   \   0004   31A703         BF        [HL].2, $+6
   \   0007   9B....         BR        N:??DATTrpPage3InvertedDataReceivedOK_Static_75
   1841              {
   1842                  //--------------------------------------------//
   1843                  // Update resynchronization successful counter
   1844                  //--------------------------------------------//
   1845                  ucResynchroSuccessfulL = mDATRead(U8Bit, EEP_ResynchroSuccessfulCounter, Default);
   \   000A   8E....         MOV       A,DATDbkMirrors+4
   \   000D   72             MOV       C,A
   1846                  if (ucResynchroSuccessfulL < cMaxResynchroSuccessfulCounter)
   \   000E   41             INC       A
   \   000F   AD13           BZ        ??DATTrpPage3InvertedDataReceivedOK_Static_76
   1847                  {
   1848                      mDATWrite(U8Bit, EEP_ResynchroSuccessfulCounter,
   1849                          (ucResynchroSuccessfulL + 1), Default);
   \   0011   62             MOV       A,C
   \   0012   70             MOV       X,A
   \   0013   A100           MOV       A,#0
   \   0015   80             INCW      AX
   \   0016   5DFF           AND       A,#255
   \   0018   BD05           BNZ       ??DATTrpPage3InvertedDataReceivedOK_Static_77
   \   001A   42             INC       C
   \   001B   62             MOV       A,C
   \   001C   9E....         MOV       DATDbkMirrors+4,A
   \                     ??DATTrpPage3InvertedDataReceivedOK_Static_77:
   \   001F   A100           MOV       A,#0
   \   0021   9A....         CALL      DATDbkStartUpdate
   \                     ??DATTrpPage3InvertedDataReceivedOK_Static_76:
   \   0024   16....         MOVW      HL,#DatTrpExportData+50
   \   0027   318703         BF        [HL].0, $+6
   \   002A   9B....         BR        N:??DATTrpPage3InvertedDataReceivedOK_Static_78
   1850                  }
   1851          
   1852                  if (cFalse == (BOOL)DatTrpExportData.AuthentInLearningMode)
   1853                  {
   1854                      mDATWriteTable(U32Bit, EEP_InitialResynchroValue, DatTrpExportData.IndexOfKeyRecognized, DatTrpExportData.ResynchronizationValue, Default);
   \   002D   8E....         MOV       A,DatTrpExportData+41
   \   0030   A004           MOV       X,#4
   \   0032   3188           MULU      X
   \   0034   CA....         ADDW      AX,#DATDbkMirrors+162
   \   0037   D6             MOVW      HL,AX
   \   0038   87             MOV       A,[HL]
   \   0039   70             MOV       X,A
   \   003A   AE01           MOV       A,[HL+0x01]
   \   003C   D2             MOVW      BC,AX
   \   003D   100000         MOVW      AX,#0
   \   0040   B3             PUSH      BC
   \   0041   B1             PUSH      AX
   \   0042   8E....         MOV       A,DatTrpExportData+41
   \   0045   A004           MOV       X,#4
   \   0047   3188           MULU      X
   \   0049   CA....         ADDW      AX,#DATDbkMirrors+160
   \   004C   D6             MOVW      HL,AX
   \   004D   87             MOV       A,[HL]
   \   004E   70             MOV       X,A
   \   004F   AE01           MOV       A,[HL+0x01]
   \   0051   120000         MOVW      BC,#0
   \   0054   D6             MOVW      HL,AX
   \   0055   891C           MOVW      AX,SP
   \   0057   E6             XCHW      AX,HL
   \   0058   E2             XCHW      AX,BC
   \   0059   0902           ADD       A,[HL+0x02]
   \   005B   30             XCH       A,X
   \   005C   0903           ADD       A,[HL+0x03]
   \   005E   E2             XCHW      AX,BC
   \   005F   B6             POP       HL
   \   0060   B6             POP       HL
   \   0061   B5             PUSH      DE
   \   0062   D4             MOVW      DE,AX
   \   0063   64             MOV       A,E
   \   0064   18....         SUB       A,DatTrpExportData+20
   \   0067   70             MOV       X,A
   \   0068   65             MOV       A,D
   \   0069   38....         SUBC      A,DatTrpExportData+21
   \   006C   6160           OR        X,A
   \   006E   62             MOV       A,C
   \   006F   38....         SUBC      A,DatTrpExportData+22
   \   0072   6160           OR        X,A
   \   0074   63             MOV       A,B
   \   0075   38....         SUBC      A,DatTrpExportData+23
   \   0078   6160           OR        X,A
   \   007A   B4             POP       DE
   \   007B   AD2D           BZ        ??DATTrpPage3InvertedDataReceivedOK_Static_79
   \   007D   02....         MOVW      AX,DatTrpExportData+20
   \   0080   D4             MOVW      DE,AX
   \   0081   8E....         MOV       A,DatTrpExportData+41
   \   0084   A004           MOV       X,#4
   \   0086   3188           MULU      X
   \   0088   CA....         ADDW      AX,#DATDbkMirrors+160
   \   008B   D6             MOVW      HL,AX
   \   008C   C4             MOVW      AX,DE
   \   008D   BE01           MOV       [HL+0x01],A
   \   008F   60             MOV       A,X
   \   0090   97             MOV       [HL],A
   \   0091   02....         MOVW      AX,DatTrpExportData+22
   \   0094   D4             MOVW      DE,AX
   \   0095   8E....         MOV       A,DatTrpExportData+41
   \   0098   A004           MOV       X,#4
   \   009A   3188           MULU      X
   \   009C   CA....         ADDW      AX,#DATDbkMirrors+162
   \   009F   D6             MOVW      HL,AX
   \   00A0   C4             MOVW      AX,DE
   \   00A1   BE01           MOV       [HL+0x01],A
   \   00A3   60             MOV       A,X
   \   00A4   97             MOV       [HL],A
   \   00A5   A104           MOV       A,#4
   \   00A7   9A....         CALL      DATDbkStartUpdate
   1855                      mDATWriteTable(U32Bit, EEP_SI28Bits, DatTrpExportData.IndexOfKeyRecognized, DatTrpExportData.ResynchronizationValue, Default);
   \                     ??DATTrpPage3InvertedDataReceivedOK_Static_79:
   \   00AA   8E....         MOV       A,DatTrpExportData+41
   \   00AD   A004           MOV       X,#4
   \   00AF   3188           MULU      X
   \   00B1   CA....         ADDW      AX,#DATDbkMirrors+146
   \   00B4   D6             MOVW      HL,AX
   \   00B5   87             MOV       A,[HL]
   \   00B6   70             MOV       X,A
   \   00B7   AE01           MOV       A,[HL+0x01]
   \   00B9   D2             MOVW      BC,AX
   \   00BA   100000         MOVW      AX,#0
   \   00BD   B3             PUSH      BC
   \   00BE   B1             PUSH      AX
   \   00BF   8E....         MOV       A,DatTrpExportData+41
   \   00C2   A004           MOV       X,#4
   \   00C4   3188           MULU      X
   \   00C6   CA....         ADDW      AX,#DATDbkMirrors+144
   \   00C9   D6             MOVW      HL,AX
   \   00CA   87             MOV       A,[HL]
   \   00CB   70             MOV       X,A
   \   00CC   AE01           MOV       A,[HL+0x01]
   \   00CE   120000         MOVW      BC,#0
   \   00D1   D6             MOVW      HL,AX
   \   00D2   891C           MOVW      AX,SP
   \   00D4   E6             XCHW      AX,HL
   \   00D5   E2             XCHW      AX,BC
   \   00D6   0902           ADD       A,[HL+0x02]
   \   00D8   30             XCH       A,X
   \   00D9   0903           ADD       A,[HL+0x03]
   \   00DB   E2             XCHW      AX,BC
   \   00DC   B6             POP       HL
   \   00DD   B6             POP       HL
   \   00DE   B5             PUSH      DE
   \   00DF   D4             MOVW      DE,AX
   \   00E0   64             MOV       A,E
   \   00E1   18....         SUB       A,DatTrpExportData+20
   \   00E4   70             MOV       X,A
   \   00E5   65             MOV       A,D
   \   00E6   38....         SUBC      A,DatTrpExportData+21
   \   00E9   6160           OR        X,A
   \   00EB   62             MOV       A,C
   \   00EC   38....         SUBC      A,DatTrpExportData+22
   \   00EF   6160           OR        X,A
   \   00F1   63             MOV       A,B
   \   00F2   38....         SUBC      A,DatTrpExportData+23
   \   00F5   6160           OR        X,A
   \   00F7   B4             POP       DE
   \   00F8   AD2D           BZ        ??DATTrpPage3InvertedDataReceivedOK_Static_80
   \   00FA   02....         MOVW      AX,DatTrpExportData+20
   \   00FD   D4             MOVW      DE,AX
   \   00FE   8E....         MOV       A,DatTrpExportData+41
   \   0101   A004           MOV       X,#4
   \   0103   3188           MULU      X
   \   0105   CA....         ADDW      AX,#DATDbkMirrors+144
   \   0108   D6             MOVW      HL,AX
   \   0109   C4             MOVW      AX,DE
   \   010A   BE01           MOV       [HL+0x01],A
   \   010C   60             MOV       A,X
   \   010D   97             MOV       [HL],A
   \   010E   02....         MOVW      AX,DatTrpExportData+22
   \   0111   D4             MOVW      DE,AX
   \   0112   8E....         MOV       A,DatTrpExportData+41
   \   0115   A004           MOV       X,#4
   \   0117   3188           MULU      X
   \   0119   CA....         ADDW      AX,#DATDbkMirrors+146
   \   011C   D6             MOVW      HL,AX
   \   011D   C4             MOVW      AX,DE
   \   011E   BE01           MOV       [HL+0x01],A
   \   0120   60             MOV       A,X
   \   0121   97             MOV       [HL],A
   \   0122   A104           MOV       A,#4
   \   0124   9A....         CALL      DATDbkStartUpdate
   1856          
   1857                      ucClearResynchroFlagL = mDATRead(U8Bit, EEP_ResynchroRequest, Default);
   1858                      ucClearResynchroFlagL &= (U8)(~((U8)((U8)1 << DatTrpExportData.IndexOfKeyRecognized)));
   \                     ??DATTrpPage3InvertedDataReceivedOK_Static_80:
   \   0127   8E....         MOV       A,DatTrpExportData+41
   \   012A   72             MOV       C,A
   \   012B   100100         MOVW      AX,#1
   \   012E   ..             CALLT     [__T_?I_LSH_L02]
   \   012F   60             MOV       A,X
   \   0130   7DFF           XOR       A,#255
   \   0132   58....         AND       A,DATDbkMirrors+208
   \   0135   70             MOV       X,A
   1859                      mDATWrite(U8Bit, EEP_ResynchroRequest, ucClearResynchroFlagL, Default);
   \   0136   8E....         MOV       A,DATDbkMirrors+208
   \   0139   6148           CMP       A,X
   \   013B   BD03           BNZ       $+5
   \   013D   9B....         BR        N:??DATTrpPage3InvertedDataReceivedOK_Static_75
   \   0140   60             MOV       A,X
   \   0141   9E....         MOV       DATDbkMirrors+208,A
   \   0144   A104           MOV       A,#4
   \   0146   9A....         CALL      DATDbkStartUpdate
   \   0149   9B....         BR        N:??DATTrpPage3InvertedDataReceivedOK_Static_75
   1860                  }
   1861                  else
   1862                  {
   1863                      //------------------------------------------------------------//
   1864                      // Write the last reading data or the default value in EEPROM
   1865                      //------------------------------------------------------------//
   1866                      mDATWriteTable(U32Bit, EEP_DefResynchroValueRead, mDATRead(U8Bit, NumberOfKeysLearnt, Default), DatTrpExportData.ResynchronizationValue, Default);
   \                     ??DATTrpPage3InvertedDataReceivedOK_Static_78:
   \   014C   8E....         MOV       A,DATCmnImmoData+13
   \   014F   A004           MOV       X,#4
   \   0151   3188           MULU      X
   \   0153   CA....         ADDW      AX,#DATDbkMirrors+178
   \   0156   D6             MOVW      HL,AX
   \   0157   87             MOV       A,[HL]
   \   0158   70             MOV       X,A
   \   0159   AE01           MOV       A,[HL+0x01]
   \   015B   D2             MOVW      BC,AX
   \   015C   100000         MOVW      AX,#0
   \   015F   B3             PUSH      BC
   \   0160   B1             PUSH      AX
   \   0161   8E....         MOV       A,DATCmnImmoData+13
   \   0164   A004           MOV       X,#4
   \   0166   3188           MULU      X
   \   0168   CA....         ADDW      AX,#DATDbkMirrors+176
   \   016B   D6             MOVW      HL,AX
   \   016C   87             MOV       A,[HL]
   \   016D   70             MOV       X,A
   \   016E   AE01           MOV       A,[HL+0x01]
   \   0170   120000         MOVW      BC,#0
   \   0173   D6             MOVW      HL,AX
   \   0174   891C           MOVW      AX,SP
   \   0176   E6             XCHW      AX,HL
   \   0177   E2             XCHW      AX,BC
   \   0178   0902           ADD       A,[HL+0x02]
   \   017A   30             XCH       A,X
   \   017B   0903           ADD       A,[HL+0x03]
   \   017D   E2             XCHW      AX,BC
   \   017E   B6             POP       HL
   \   017F   B6             POP       HL
   \   0180   B5             PUSH      DE
   \   0181   D4             MOVW      DE,AX
   \   0182   64             MOV       A,E
   \   0183   18....         SUB       A,DatTrpExportData+20
   \   0186   70             MOV       X,A
   \   0187   65             MOV       A,D
   \   0188   38....         SUBC      A,DatTrpExportData+21
   \   018B   6160           OR        X,A
   \   018D   62             MOV       A,C
   \   018E   38....         SUBC      A,DatTrpExportData+22
   \   0191   6160           OR        X,A
   \   0193   63             MOV       A,B
   \   0194   38....         SUBC      A,DatTrpExportData+23
   \   0197   6160           OR        X,A
   \   0199   B4             POP       DE
   \   019A   AD2D           BZ        ??DATTrpPage3InvertedDataReceivedOK_Static_81
   \   019C   02....         MOVW      AX,DatTrpExportData+20
   \   019F   D4             MOVW      DE,AX
   \   01A0   8E....         MOV       A,DATCmnImmoData+13
   \   01A3   A004           MOV       X,#4
   \   01A5   3188           MULU      X
   \   01A7   CA....         ADDW      AX,#DATDbkMirrors+176
   \   01AA   D6             MOVW      HL,AX
   \   01AB   C4             MOVW      AX,DE
   \   01AC   BE01           MOV       [HL+0x01],A
   \   01AE   60             MOV       A,X
   \   01AF   97             MOV       [HL],A
   \   01B0   02....         MOVW      AX,DatTrpExportData+22
   \   01B3   D4             MOVW      DE,AX
   \   01B4   8E....         MOV       A,DATCmnImmoData+13
   \   01B7   A004           MOV       X,#4
   \   01B9   3188           MULU      X
   \   01BB   CA....         ADDW      AX,#DATDbkMirrors+178
   \   01BE   D6             MOVW      HL,AX
   \   01BF   C4             MOVW      AX,DE
   \   01C0   BE01           MOV       [HL+0x01],A
   \   01C2   60             MOV       A,X
   \   01C3   97             MOV       [HL],A
   \   01C4   A104           MOV       A,#4
   \   01C6   9A....         CALL      DATDbkStartUpdate
   1867          
   1868                      //---------------------------------------//
   1869                      // Write the last writing data in EEPROM
   1870                      //---------------------------------------//
   1871                      mDATWriteTable(U32Bit, EEP_DefResynchroValueWrite, mDATRead(U8Bit, NumberOfKeysLearnt, Default), DatTrpExportData.ResynchronizationValue, Default);
   \                     ??DATTrpPage3InvertedDataReceivedOK_Static_81:
   \   01C9   8E....         MOV       A,DATCmnImmoData+13
   \   01CC   A004           MOV       X,#4
   \   01CE   3188           MULU      X
   \   01D0   CA....         ADDW      AX,#DATDbkMirrors+194
   \   01D3   D6             MOVW      HL,AX
   \   01D4   87             MOV       A,[HL]
   \   01D5   70             MOV       X,A
   \   01D6   AE01           MOV       A,[HL+0x01]
   \   01D8   D2             MOVW      BC,AX
   \   01D9   100000         MOVW      AX,#0
   \   01DC   B3             PUSH      BC
   \   01DD   B1             PUSH      AX
   \   01DE   8E....         MOV       A,DATCmnImmoData+13
   \   01E1   A004           MOV       X,#4
   \   01E3   3188           MULU      X
   \   01E5   CA....         ADDW      AX,#DATDbkMirrors+192
   \   01E8   D6             MOVW      HL,AX
   \   01E9   87             MOV       A,[HL]
   \   01EA   70             MOV       X,A
   \   01EB   AE01           MOV       A,[HL+0x01]
   \   01ED   120000         MOVW      BC,#0
   \   01F0   D6             MOVW      HL,AX
   \   01F1   891C           MOVW      AX,SP
   \   01F3   E6             XCHW      AX,HL
   \   01F4   E2             XCHW      AX,BC
   \   01F5   0902           ADD       A,[HL+0x02]
   \   01F7   30             XCH       A,X
   \   01F8   0903           ADD       A,[HL+0x03]
   \   01FA   E2             XCHW      AX,BC
   \   01FB   B6             POP       HL
   \   01FC   B6             POP       HL
   \   01FD   B5             PUSH      DE
   \   01FE   D4             MOVW      DE,AX
   \   01FF   64             MOV       A,E
   \   0200   18....         SUB       A,DatTrpExportData+20
   \   0203   70             MOV       X,A
   \   0204   65             MOV       A,D
   \   0205   38....         SUBC      A,DatTrpExportData+21
   \   0208   6160           OR        X,A
   \   020A   62             MOV       A,C
   \   020B   38....         SUBC      A,DatTrpExportData+22
   \   020E   6160           OR        X,A
   \   0210   63             MOV       A,B
   \   0211   38....         SUBC      A,DatTrpExportData+23
   \   0214   6160           OR        X,A
   \   0216   B4             POP       DE
   \   0217   AD2D           BZ        ??DATTrpPage3InvertedDataReceivedOK_Static_75
   \   0219   02....         MOVW      AX,DatTrpExportData+20
   \   021C   D4             MOVW      DE,AX
   \   021D   8E....         MOV       A,DATCmnImmoData+13
   \   0220   A004           MOV       X,#4
   \   0222   3188           MULU      X
   \   0224   CA....         ADDW      AX,#DATDbkMirrors+192
   \   0227   D6             MOVW      HL,AX
   \   0228   C4             MOVW      AX,DE
   \   0229   BE01           MOV       [HL+0x01],A
   \   022B   60             MOV       A,X
   \   022C   97             MOV       [HL],A
   \   022D   02....         MOVW      AX,DatTrpExportData+22
   \   0230   D4             MOVW      DE,AX
   \   0231   8E....         MOV       A,DATCmnImmoData+13
   \   0234   A004           MOV       X,#4
   \   0236   3188           MULU      X
   \   0238   CA....         ADDW      AX,#DATDbkMirrors+194
   \   023B   D6             MOVW      HL,AX
   \   023C   C4             MOVW      AX,DE
   \   023D   BE01           MOV       [HL+0x01],A
   \   023F   60             MOV       A,X
   \   0240   97             MOV       [HL],A
   \   0241   A104           MOV       A,#4
   \   0243   9A....         CALL      DATDbkStartUpdate
   1872                  }
   1873              }
   1874          
   1875              DatTrpExportData.ResynchronizationState = cDATTrpServiceSuccessful;
   \                     ??DATTrpPage3InvertedDataReceivedOK_Static_75:
   \   0246   A102           MOV       A,#2
   \   0248   9B....         BR        N:?Subroutine5
   \   024B                  REQUIRE ?CL78K_V4_6_L00
   1876          }
   1877          //*****************************************************************************
   1878          //  DESCRIPTION         : Start the Write Access service in the context of the
   1879          //                        Resynchronization service.
   1880          //
   1881          //  PARAMETERS          : None
   1882          //  (Type,Name,Min,Max) 
   1883          //
   1884          //  RETURN VALUE        : None
   1885          //
   1886          //  DESIGN INFORMATION  : Refer to Detailed Design Document
   1887          //
   1888          //*****************************************************************************

   \                                 In  segment CODE, align 1, keep-with-next
   1889          void DATTrpStartWriteServiceForResync(void)
   \                     DATTrpStartWriteServiceForResync:
   1890          {
   \   0000                  ; * Stack frame (at entry) *
   \   0000                  ; Param size: 0
   \   0000                  ; Total Auto size: 0
   1891              mLIBassert(DatTrpExportData.WriteAccessState != cDATTrpServiceInProgress);
   1892          
   1893              DatTrpExportData.WriteAccessState = cDATTrpServiceInProgress;
   \   0000   A101           MOV       A,#1
   \   0002   16....         MOVW      HL,#DatTrpExportData+48
   \   0005   97             MOV       [HL],A
   1894              TOSSeqActivateGraph(cTOSSeqGraphIdDATTrpWriteAccess);
   \   0006   A11E           MOV       A,#30
   \   0008   ..             CALLT     [__T_TOSSeqActivateGraph]
   1895          }
   \   0009   AF             RET       
   \   000A                  REQUIRE ?CL78K_V4_6_L00
   1896          //*****************************************************************************
   1897          //  DESCRIPTION         : Test if Write Access service is not successfully 
   1898          //                        finished.
   1899          //
   1900          //  PARAMETERS          : None
   1901          //  (Type,Name,Min,Max) 
   1902          //
   1903          //  RETURN VALUE        : None
   1904          //
   1905          //  DESIGN INFORMATION  : Refer to Detailed Design Document
   1906          //
   1907          //*****************************************************************************

   \                                 In  segment CODE, align 1, keep-with-next
   1908          BOOL DATTrpWriteServiceFinishedNOK(void)
   \                     DATTrpWriteServiceFinishedNOK:
   1909          {
   \   0000                  ; * Stack frame (at entry) *
   \   0000                  ; Param size: 0
   \   0000                  ; Total Auto size: 0
   1910              return (BOOL)(DatTrpExportData.WriteAccessState == cDATTrpServiceNotSuccessful);
   \   0000   8E....         MOV       A,DatTrpExportData+48
   \   0003   4D03           CMP       A,#3
   \   0005   BD03           BNZ       ??DATTrpPage3InvertedDataReceivedOK_Static_8
   \   0007   A101           MOV       A,#1
   \   0009   AF             RET       
   \                     ??DATTrpPage3InvertedDataReceivedOK_Static_8:
   \   000A   A100           MOV       A,#0
   \   000C   AF             RET       
   \   000D                  REQUIRE ?CL78K_V4_6_L00
   1911          }
   1912          //*****************************************************************************
   1913          //  DESCRIPTION         : Test if Write Access service is successfully finished.
   1914          //
   1915          //  PARAMETERS          : None
   1916          //  (Type,Name,Min,Max) 
   1917          //
   1918          //  RETURN VALUE        : None
   1919          //
   1920          //  DESIGN INFORMATION  : Refer to Detailed Design Document
   1921          //
   1922          //*****************************************************************************

   \                                 In  segment CODE, align 1, keep-with-next
   1923          BOOL DATTrpWriteServiceFinishedOK(void)
   \                     DATTrpWriteServiceFinishedOK:
   1924          {
   \   0000                  ; * Stack frame (at entry) *
   \   0000                  ; Param size: 0
   \   0000                  ; Total Auto size: 0
   1925              return (BOOL)(DatTrpExportData.WriteAccessState == cDATTrpServiceSuccessful);
   \   0000   8E....         MOV       A,DatTrpExportData+48
   \   0003   4D02           CMP       A,#2
   \   0005   BD03           BNZ       ??DATTrpPage3InvertedDataReceivedOK_Static_9
   \   0007   A101           MOV       A,#1
   \   0009   AF             RET       
   \                     ??DATTrpPage3InvertedDataReceivedOK_Static_9:
   \   000A   A100           MOV       A,#0
   \   000C   AF             RET       
   \   000D                  REQUIRE ?CL78K_V4_6_L00
   1926          }
   1927          //*****************************************************************************
   1928          //  DESCRIPTION         : Test if a new read or write access is authorized.
   1929          //
   1930          //  PARAMETERS          : None
   1931          //  (Type,Name,Min,Max) 
   1932          //
   1933          //  RETURN VALUE        : cFalse or cTrue
   1934          //
   1935          //  DESIGN INFORMATION  : Refer to Detailed Design Document
   1936          //
   1937          //*****************************************************************************

   \                                 In  segment CODE, align 1, keep-with-next
   1938          BOOL DATTrpNewTryAuthorized(void)
   \                     DATTrpNewTryAuthorized:
   1939          {
   \   0000                  ; * Stack frame (at entry) *
   \   0000                  ; Param size: 0
   \   0000   B5             PUSH      DE
   \   0001                  ; Total Auto size: 0
   1940          #ifdef X90_PROJECT
   1941              return DATTrpNewTryAuthorized_Static();
   \   0001   16....         MOVW      HL,#LWRD(DATTrpNewTryAuthorized_Static)
   \   0004   A4..           MOV       E,#BYTE3(DATTrpNewTryAuthorized_Static)
   \   0006   ..             CALLT     [__T_?FAR_CALL_L07]
   \   0007   B4             POP       DE
   \   0008   AF             RET       
   \   0009                  REQUIRE ?CL78K_V4_6_L00
   1942          }
   1943          #pragma optimize=no_inline

   \                                 In  segment BCODE, align 1, keep-with-next
   1944          static MEM_TYPE BOOL DATTrpNewTryAuthorized_Static(void)
   \                     DATTrpNewTryAuthorized_Static:
   1945          {
   \   0000                  ; * Stack frame (at entry) *
   \   0000                  ; Param size: 0
   \   0000                  ; Total Auto size: 0
   1946          #endif
   1947              BOOL bResultL = cFalse;
   \   0000   A000           MOV       X,#0
   1948          
   1949              if (cFalse == (BOOL)DatTrpExportData.ActiveTestMode) 
   \   0002   16....         MOVW      HL,#DatTrpExportData+50
   \   0005   31A612         BT        [HL].2, ??DATTrpPage3InvertedDataReceivedOK_Static_82
   1950              {
   1951                  if (cFalse == (BOOL)DatTrpExportData.AuthentInLearningMode)
   \   0008   318609         BT        [HL].0, ??DATTrpPage3InvertedDataReceivedOK_Static_83
   1952                  {
   1953                      //---------------------------------------------------------------//
   1954                      // In normal mode, use the max number of try to leave the service
   1955                      //---------------------------------------------------------------//
   1956                      bResultL = (DatTrpLocalData.u8ReadOrWriteNumberOfTry < cDATTrpTransponderAccessMaxNumberOfTry);
   \   000B   8E....         MOV       A,DatTrpLocalData+31
   \   000E   4D03           CMP       A,#3
   \   0010   9D08           BNC       ??DATTrpPage3InvertedDataReceivedOK_Static_82
   \   0012   FA04           BR        ??DATTrpPage3InvertedDataReceivedOK_Static_84
   1957                  }
   1958                  else
   1959                  {
   1960                      //---------------------------------------------------------------//
   1961                      // In learning mode, use a time out to leave the service
   1962                      //---------------------------------------------------------------//
   1963                      bResultL = (cFalse == (BOOL)DatTrpExportData.KeyLearningElapsed);
   \                     ??DATTrpPage3InvertedDataReceivedOK_Static_83:
   \   0014   86             INCW      HL
   \   0015   31C602         BT        [HL].4, ??DATTrpPage3InvertedDataReceivedOK_Static_82
   \                     ??DATTrpPage3InvertedDataReceivedOK_Static_84:
   \   0018   A001           MOV       X,#1
   1964                  }
   1965              }
   1966              return (bResultL);
   \                     ??DATTrpPage3InvertedDataReceivedOK_Static_82:
   \   001A   60             MOV       A,X
   \   001B   AF             RET       
   \   001C                  REQUIRE ?CL78K_V4_6_L00
   1967          }
   1968          
   1969          //*****************************************************************************
   1970          //  DESCRIPTION         : Test if in Learning Mode and if Maximum number of
   1971          //                        writing trials are being made.
   1972          //
   1973          //  PARAMETERS          : None
   1974          //  (Type,Name,Min,Max) 
   1975          //
   1976          //  RETURN VALUE        : cFalse or cTrue
   1977          //
   1978          //  DESIGN INFORMATION  : Refer to Detailed Design Document
   1979          //
   1980          //*****************************************************************************

   \                                 In  segment CODE, align 1, keep-with-next
   1981          BOOL DATTrpInLearningModeAndLessThanMaxTrials(void)
   \                     DATTrpInLearningModeAndLessThanMaxTrials:
   1982          {
   \   0000                  ; * Stack frame (at entry) *
   \   0000                  ; Param size: 0
   \   0000   B5             PUSH      DE
   \   0001                  ; Total Auto size: 0
   1983          #ifdef X90_PROJECT
   1984              return DATTrpInLearningModeAndLessThanMaxTrials_Static();
   \   0001   16....         MOVW      HL,#LWRD(DATTrpInLearningModeAndLessThanMaxTrials_Static)
   \   0004   A4..           MOV       E,#BYTE3(DATTrpInLearningModeAndLessThanMaxTrials_Static)
   \   0006   ..             CALLT     [__T_?FAR_CALL_L07]
   \   0007   B4             POP       DE
   \   0008   AF             RET       
   \   0009                  REQUIRE ?CL78K_V4_6_L00
   1985          }
   1986          #pragma optimize=no_inline

   \                                 In  segment BCODE, align 1, keep-with-next
   1987          static MEM_TYPE BOOL DATTrpInLearningModeAndLessThanMaxTrials_Static(void)
   \                     DATTrpInLearningModeAndLessThanMaxTrials_Static:
   1988          {
   \   0000                  ; * Stack frame (at entry) *
   \   0000                  ; Param size: 0
   \   0000                  ; Total Auto size: 0
   1989          #endif
   1990              BOOL bResultL = cFalse;
   \   0000   A000           MOV       X,#0
   1991          
   1992              if (cFalse == (BOOL)DatTrpExportData.ActiveTestMode) 
   \   0002   16....         MOVW      HL,#DatTrpExportData+50
   \   0005   31A610         BT        [HL].2, ??DATTrpPage3InvertedDataReceivedOK_Static_85
   1993              {
   1994                  DatTrpLocalData.u8ReadOrWriteNumberOfTry++;
   \   0008   8E....         MOV       A,DatTrpLocalData+31
   \   000B   41             INC       A
   \   000C   9E....         MOV       DatTrpLocalData+31,A
   1995          
   1996                  if (cFalse != (BOOL)DatTrpExportData.AuthentInLearningMode)
   \   000F   318706         BF        [HL].0, ??DATTrpPage3InvertedDataReceivedOK_Static_85
   1997                  {
   1998                      //---------------------------------------------------------------//
   1999                      // In learning mode, count the max number of trials before new authent
   2000                      //---------------------------------------------------------------//
   2001                      bResultL = DatTrpLocalData.u8ReadOrWriteNumberOfTry < cDATTrpTransponderAccessMaxNumberOfTry;
   \   0012   4D03           CMP       A,#3
   \   0014   9D02           BNC       ??DATTrpPage3InvertedDataReceivedOK_Static_85
   \   0016   A001           MOV       X,#1
   2002                  }
   2003              }
   2004              return (bResultL);
   \                     ??DATTrpPage3InvertedDataReceivedOK_Static_85:
   \   0018   60             MOV       A,X
   \   0019   AF             RET       
   \   001A                  REQUIRE ?CL78K_V4_6_L00
   2005          }
   2006          
   2007          //*****************************************************************************
   2008          //  DESCRIPTION         : Compute and send inverted read command.
   2009          //
   2010          //  PARAMETERS          : None
   2011          //  (Type,Name,Min,Max) 
   2012          //
   2013          //  RETURN VALUE        : None
   2014          //
   2015          //  DESIGN INFORMATION  : Refer to Detailed Design Document
   2016          //
   2017          //*****************************************************************************

   \                                 In  segment CODE, align 1, keep-with-next
   2018          void DATTrpSendInvertedReadCommand(void)
   \                     DATTrpSendInvertedReadCommand:
   2019          {
   \   0000                  ; * Stack frame (at entry) *
   \   0000                  ; Param size: 0
   \   0000   B5             PUSH      DE
   \   0001                  ; Total Auto size: 0
   2020          #ifdef X90_PROJECT
   2021              DATTrpSendInvertedReadCommand_Static();
   \   0001   16....         MOVW      HL,#LWRD(DATTrpSendInvertedReadCommand_Static)
   \   0004   A4..           MOV       E,#BYTE3(DATTrpSendInvertedReadCommand_Static)
   \   0006   ..             CALLT     [__T_?FAR_CALL_L07]
   2022          }
   \   0007   B4             POP       DE
   \   0008   AF             RET       
   \   0009                  REQUIRE ?CL78K_V4_6_L00
   2023          #pragma optimize=no_inline

   \                                 In  segment BCODE, align 1, keep-with-next
   2024          static MEM_TYPE void DATTrpSendInvertedReadCommand_Static(void)
   \                     DATTrpSendInvertedReadCommand_Static:
   2025          {
   \   0000                  ; * Stack frame (at entry) *
   \   0000                  ; Param size: 0
   \   0000   B3             PUSH      BC
   \   0001                  ; Total Auto size: 0
   2026          #endif
   2027          
   2028              tTrpCommand EncodedInvertedReadingCommand;
   2029          
   2030              // Prevention of simultaneous access of antena by immo or exm components
   2031              // like:    if (DatTrpLocalData.CipheredCommunication == cTrue)
   2032              //------------------------//
   2033              // Encode command to send
   2034              //------------------------//
   2035              EncodedInvertedReadingCommand = EncodeCommand(DatTrpLocalData.InvertedReadingCommand);
   \   0001   02....         MOVW      AX,DatTrpLocalData+26
   \   0004   9A....         CALL      EncodeCommand
   \   0007   D4             MOVW      DE,AX
   2036          
   2037              DatTrpLocalData.TransponderMessage.Lng  = cPageLength;
   \   0008   102000         MOVW      AX,#32
   \   000B   03....         MOVW      DatTrpLocalData+10,AX
   2038              DatTrpLocalData.u32DataBuffer            = 0;
   \   000E   70             MOV       X,A
   \   000F   03....         MOVW      DatTrpLocalData+2,AX
   \   0012   03....         MOVW      DatTrpLocalData,AX
   2039              //QACJ 0310:amanevd: Test on target prooves that this cast is compiled correct. As well as this is how it comes from reuse.
   2040              DatTrpLocalData.TransponderMessage.pBuffer = (U8*)&DatTrpLocalData.u32DataBuffer;
   \   0015   10....         MOVW      AX,#DatTrpLocalData
   \   0018   03....         MOVW      DatTrpLocalData+8,AX
   2041          
   2042              //------------------------------------------//
   2043              // Indicate that answer is not received yet
   2044              //------------------------------------------//
   2045              mClearFlagImmoAntAnswerReceived();
   2046              mClearFlagAnswerReceivedOK();
   \   001B   8E....         MOV       A,DatTrpLocalData+30
   \   001E   5DFC           AND       A,#252
   \   0020   9E....         MOV       DatTrpLocalData+30,A
   2047          
   2048              //---------------------------//
   2049              // Start communication timer
   2050              //---------------------------//
   2051              DatTrpLocalData.CommandTimeOut = cReadCmdTimeOut;
   \   0023   100800         MOVW      AX,#8
   \   0026   03....         MOVW      DatTrpLocalData+18,AX
   2052              TOSStartTimer(&DatTrpLocalData.TimeOutWaitingForImmoANTReply);
   \   0029   10....         MOVW      AX,#DatTrpLocalData+12
   \   002C   ..             CALLT     [__T_TOSStartTimer]
   2053          
   2054              //----------------------------------//
   2055              // Start the sending of the message
   2056              //----------------------------------//  
   2057          
   2058              LDBReceiveWithAddr(cLDBChannelTrp, EncodedInvertedReadingCommand, &DatTrpLocalData.TransponderMessage);
   \   002D   9B....         BR        N:?Subroutine2
   \   0030                  REQUIRE ?CL78K_V4_6_L00
   2059          }
   2060          
   2061          //*****************************************************************************
   2062          //  DESCRIPTION         : Test if write command is successful.
   2063          //
   2064          //  PARAMETERS          : None
   2065          //  (Type,Name,Min,Max) 
   2066          //
   2067          //  RETURN VALUE        : cFalse or cTrue
   2068          //
   2069          //  DESIGN INFORMATION  : Refer to Detailed Design Document
   2070          //
   2071          //*****************************************************************************

   \                                 In  segment CODE, align 1, keep-with-next
   2072          BOOL DATTrpPageWrittenOK(void)
   \                     DATTrpPageWrittenOK:
   2073          {
   \   0000                  ; * Stack frame (at entry) *
   \   0000                  ; Param size: 0
   \   0000   10....         MOVW      AX,#DatTrpLocalData+14
   \   0003   B3             PUSH      BC
   \   0004                  ; Total Auto size: 0
   2074              BOOL bTimerElapsedL;
   2075          
   2076              bTimerElapsedL = TOSIsTimerElapsed(&DatTrpLocalData.TimeOutWaitingForWriting, 
   2077              cWritingInTrpTimeOut);
   \   0004   120400         MOVW      BC,#4
   \   0007   ..             CALLT     [__T_TOSIsTimerElapsed]
   2078          
   2079              return (    (cTrue == (BOOL)mGetFlagAnswerReceivedOK()) 
   2080                       && (cFalse != bTimerElapsedL));
   \   0008   16....         MOVW      HL,#DatTrpLocalData+30
   \   000B   319708         BF        [HL].1, ??DATTrpPage3InvertedDataReceivedOK_Static_10
   \   000E   4D00           CMP       A,#0
   \   0010   AD04           BZ        ??DATTrpPage3InvertedDataReceivedOK_Static_10
   \   0012   A101           MOV       A,#1
   \   0014   FA02           BR        ??DATTrpPage3InvertedDataReceivedOK_Static_11
   \                     ??DATTrpPage3InvertedDataReceivedOK_Static_10:
   \   0016   A100           MOV       A,#0
   \                     ??DATTrpPage3InvertedDataReceivedOK_Static_11:
   \   0018   B2             POP       BC
   \   0019   AF             RET       
   \   001A                  REQUIRE ?CL78K_V4_6_L00
   2081          }
   2082          //*****************************************************************************
   2083          //  DESCRIPTION         : Test if data read is OK and equal to the last data
   2084          //                        written.
   2085          //
   2086          //  PARAMETERS          : None
   2087          //  (Type,Name,Min,Max) 
   2088          //
   2089          //  RETURN VALUE        : cFalse or cTrue
   2090          //
   2091          //  DESIGN INFORMATION  : Refer to Detailed Design Document
   2092          //
   2093          //*****************************************************************************

   \                                 In  segment CODE, align 1, keep-with-next
   2094          BOOL DATTrpReadAndCompareOK(void)
   \                     DATTrpReadAndCompareOK:
   2095          {
   \   0000                  ; * Stack frame (at entry) *
   \   0000                  ; Param size: 0
   \   0000   B5             PUSH      DE
   \   0001                  ; Total Auto size: 0
   2096          #ifdef X90_PROJECT
   2097              return DATTrpReadAndCompareOK_Static();
   \   0001   16....         MOVW      HL,#LWRD(DATTrpReadAndCompareOK_Static)
   \   0004   A4..           MOV       E,#BYTE3(DATTrpReadAndCompareOK_Static)
   \   0006   ..             CALLT     [__T_?FAR_CALL_L07]
   \   0007   B4             POP       DE
   \   0008   AF             RET       
   \   0009                  REQUIRE ?CL78K_V4_6_L00
   2098          }
   2099          #pragma optimize=no_inline

   \                                 In  segment BCODE, align 1, keep-with-next
   2100          static MEM_TYPE BOOL DATTrpReadAndCompareOK_Static(void)
   \                     DATTrpReadAndCompareOK_Static:
   2101          {
   \   0000                  ; * Stack frame (at entry) *
   \   0000                  ; Param size: 0
   \   0000   B3             PUSH      BC
   \   0001                  ; Total Auto size: 2
   \   0001   B7             PUSH      HL
   2102          #endif
   2103          
   2104              BOOL bResultL = cFalse;
   \   0002   891C           MOVW      AX,SP
   \   0004   D6             MOVW      HL,AX
   \   0005   A100           MOV       A,#0
   \   0007   97             MOV       [HL],A
   2105          
   2106              if (mGetFlagAnswerReceivedOK())
   \   0008   16....         MOVW      HL,#DatTrpLocalData+30
   \   000B   319603         BT        [HL].1, $+6
   \   000E   9B....         BR        N:??DATTrpPage3InvertedDataReceivedOK_Static_86
   2107              {
   2108                  // Prevention of simultaneous access of antena by immo or exm components
   2109                  // like:    if (DatTrpLocalData.CipheredCommunication == cTrue)
   2110                  //----------------------------//
   2111                  // Decode and store data read
   2112                  //----------------------------//
   2113                  LIBPcfCipheredData = U32ReverseByteOrder(DatTrpLocalData.u32DataBuffer);
   \   0011   02....         MOVW      AX,DatTrpLocalData+2
   \   0014   D2             MOVW      BC,AX
   \   0015   02....         MOVW      AX,DatTrpLocalData
   \   0018   9A....         CALL      U32ReverseByteOrder
   \   001B   99..           MOVW      S:LIBPcfCipheredData,AX
   \   001D   C2             MOVW      AX,BC
   \   001E   99..           MOVW      S:LIBPcfCipheredData+2,AX
   2114                  LDBRefreshWatchDog();
   \   0020   9A....         CALL      LDBRefreshWatchDog
   2115                  LIBPcfCipherFunction(cPageLength);
   \   0023   A120           MOV       A,#32
   \   0025   16....         MOVW      HL,#LWRD(LIBPcfCipherFunction)
   \   0028   A4..           MOV       E,#BYTE3(LIBPcfCipherFunction)
   \   002A   ..             CALLT     [__T_?FAR_CALL_L07]
   2116                  LDBRefreshWatchDog();
   \   002B   9A....         CALL      LDBRefreshWatchDog
   2117                  DatTrpExportData.DataRead  =  U32ReverseByteOrder(LIBPcfCipheredData);
   \   002E   89..           MOVW      AX,S:LIBPcfCipheredData+2
   \   0030   D2             MOVW      BC,AX
   \   0031   89..           MOVW      AX,S:LIBPcfCipheredData
   \   0033   9A....         CALL      U32ReverseByteOrder
   \   0036   03....         MOVW      DatTrpExportData+16,AX
   \   0039   C2             MOVW      AX,BC
   \   003A   03....         MOVW      DatTrpExportData+18,AX
   2118          
   2119                  if (cFalse == (BOOL)DatTrpExportData.WriteSecretKeyHigh)
   \   003D   16....         MOVW      HL,#DatTrpExportData+50
   \   0040   31962B         BT        [HL].1, ??DATTrpPage3InvertedDataReceivedOK_Static_87
   2120                  {
   2121                      bResultL = (BOOL)(DatTrpExportData.DataToWrite == DatTrpExportData.DataRead);
   \   0043   02....         MOVW      AX,DatTrpExportData+10
   \   0046   D2             MOVW      BC,AX
   \   0047   02....         MOVW      AX,DatTrpExportData+8
   \   004A   B5             PUSH      DE
   \   004B   D4             MOVW      DE,AX
   \   004C   64             MOV       A,E
   \   004D   18....         SUB       A,DatTrpExportData+16
   \   0050   70             MOV       X,A
   \   0051   65             MOV       A,D
   \   0052   38....         SUBC      A,DatTrpExportData+17
   \   0055   6160           OR        X,A
   \   0057   62             MOV       A,C
   \   0058   38....         SUBC      A,DatTrpExportData+18
   \   005B   6160           OR        X,A
   \   005D   63             MOV       A,B
   \   005E   38....         SUBC      A,DatTrpExportData+19
   \   0061   6160           OR        X,A
   \   0063   B4             POP       DE
   \   0064   BD3C           BNZ       ??DATTrpPage3InvertedDataReceivedOK_Static_86
   \                     ??DATTrpReadAndCompareOK_Static_0:
   \   0066   891C           MOVW      AX,SP
   \   0068   D6             MOVW      HL,AX
   \   0069   A101           MOV       A,#1
   \   006B   97             MOV       [HL],A
   \   006C   FA34           BR        ??DATTrpPage3InvertedDataReceivedOK_Static_86
   2122                  }
   2123                  else
   2124                  {
   2125                      bResultL = (BOOL)(DatTrpExportData.DataToWrite == (DatTrpExportData.DataRead & (cMaskByte1 | cMaskByte2)));
   \                     ??DATTrpPage3InvertedDataReceivedOK_Static_87:
   \   006E   100000         MOVW      AX,#0
   \   0071   B1             PUSH      AX
   \   0072   10FFFF         MOVW      AX,#65535
   \   0075   B1             PUSH      AX
   \   0076   02....         MOVW      AX,DatTrpExportData+16
   \   0079   9A....         CALL      ?L_AND_L03
   \   007C   B3             PUSH      BC
   \   007D   B1             PUSH      AX
   \   007E   02....         MOVW      AX,DatTrpExportData+10
   \   0081   D2             MOVW      BC,AX
   \   0082   02....         MOVW      AX,DatTrpExportData+8
   \   0085   D6             MOVW      HL,AX
   \   0086   891C           MOVW      AX,SP
   \   0088   E6             XCHW      AX,HL
   \   0089   B5             PUSH      DE
   \   008A   D4             MOVW      DE,AX
   \   008B   64             MOV       A,E
   \   008C   1F             SUB       A,[HL]
   \   008D   70             MOV       X,A
   \   008E   65             MOV       A,D
   \   008F   3901           SUBC      A,[HL+0x01]
   \   0091   6160           OR        X,A
   \   0093   62             MOV       A,C
   \   0094   3902           SUBC      A,[HL+0x02]
   \   0096   6160           OR        X,A
   \   0098   63             MOV       A,B
   \   0099   3903           SUBC      A,[HL+0x03]
   \   009B   6160           OR        X,A
   \   009D   B4             POP       DE
   \   009E   B6             POP       HL
   \   009F   B6             POP       HL
   \   00A0   ADC4           BZ        ??DATTrpReadAndCompareOK_Static_0
   2126                  }
   2127              }
   2128          
   2129              return (bResultL);
   \                     ??DATTrpPage3InvertedDataReceivedOK_Static_86:
   \   00A2   9B....         BR        N:?Subroutine3
   \   00A5                  REQUIRE ?CL78K_V4_6_L00
   2130          }
   2131          //*****************************************************************************
   2132          //  DESCRIPTION         : Action if data writing has failed
   2133          //
   2134          //  PARAMETERS          : None
   2135          //  (Type,Name,Min,Max) 
   2136          //
   2137          //  RETURN VALUE        : None
   2138          //
   2139          //  DESIGN INFORMATION  : Refer to Detailed Design Document (REQ: prsFS_IMMO-527)
   2140          //
   2141          //*****************************************************************************

   \                                 In  segment CODE, align 1, keep-with-next
   2142          void DATTrpWriteNOKAction(void)
   \                     DATTrpWriteNOKAction:
   2143          {
   \   0000                  ; * Stack frame (at entry) *
   \   0000                  ; Param size: 0
   \   0000                  ; Total Auto size: 0
   2144              DatTrpExportData.WriteAccessWritingError = 1;
   \   0000   16....         MOVW      HL,#DatTrpExportData+51
   \   0003   71D2           SET1      [HL].5
   2145          }
   \   0005   AF             RET       
   \   0006                  REQUIRE ?CL78K_V4_6_L00
   2146          
   2147          //*****************************************************************************
   2148          //  DESCRIPTION         : Action if read data is not correct
   2149          //
   2150          //  PARAMETERS          : None
   2151          //  (Type,Name,Min,Max) 
   2152          //
   2153          //  RETURN VALUE        : None
   2154          //
   2155          //  DESIGN INFORMATION  : Refer to Detailed Design Document (REQ: prsFS_IMMO-527)
   2156          //
   2157          //*****************************************************************************

   \                                 In  segment CODE, align 1, keep-with-next
   2158          void DATTrpReadNOKAction(void)
   \                     DATTrpReadNOKAction:
   2159          {
   \   0000                  ; * Stack frame (at entry) *
   \   0000                  ; Param size: 0
   \   0000                  ; Total Auto size: 0
   2160              
   2161              if(cDATTrpServiceInProgress == DatTrpExportData.ResynchronizationState)
   \   0000   8E....         MOV       A,DatTrpExportData+49
   \   0003   51             DEC       A
   \   0004   BD15           BNZ       ??DATTrpPage3InvertedDataReceivedOK_Static_12
   2162              {
   2163                  DatTrpExportData.ResynchronizationValue = 0;
   \   0006   100000         MOVW      AX,#0
   \   0009   03....         MOVW      DatTrpExportData+22,AX
   \   000C   03....         MOVW      DatTrpExportData+20,AX
   2164                  DatTrpExportData.DataToWrite = DatTrpExportData.ResynchronizationValue;
   \   000F   03....         MOVW      DatTrpExportData+10,AX
   \   0012   03....         MOVW      DatTrpExportData+8,AX
   2165                  DatTrpExportData.DataRead = 0;
   \   0015   03....         MOVW      DatTrpExportData+18,AX
   \   0018   03....         MOVW      DatTrpExportData+16,AX
   2166              }
   2167              
   2168              DatTrpExportData.WriteAccessReadingError = 1;
   \                     ??DATTrpPage3InvertedDataReceivedOK_Static_12:
   \   001B   16....         MOVW      HL,#DatTrpExportData+51
   \   001E   71E2           SET1      [HL].6
   2169          }
   \   0020   AF             RET       
   \   0021                  REQUIRE ?CL78K_V4_6_L00
   2170          
   2171          //*****************************************************************************
   2172          //  DESCRIPTION         : Compute and send write command.
   2173          //
   2174          //  PARAMETERS          : None
   2175          //  (Type,Name,Min,Max) 
   2176          //
   2177          //  RETURN VALUE        : None
   2178          //
   2179          //  DESIGN INFORMATION  : Refer to Detailed Design Document
   2180          //
   2181          //*****************************************************************************

   \                                 In  segment CODE, align 1, keep-with-next
   2182          void DATTrpSendWriteCommand(void)
   \                     DATTrpSendWriteCommand:
   2183          {
   \   0000                  ; * Stack frame (at entry) *
   \   0000                  ; Param size: 0
   \   0000   B5             PUSH      DE
   \   0001                  ; Total Auto size: 0
   2184          #ifdef X90_PROJECT
   2185              DATTrpSendWriteCommand_Static();
   \   0001   16....         MOVW      HL,#LWRD(DATTrpSendWriteCommand_Static)
   \   0004   A4..           MOV       E,#BYTE3(DATTrpSendWriteCommand_Static)
   \   0006   ..             CALLT     [__T_?FAR_CALL_L07]
   2186          }
   \   0007   B4             POP       DE
   \   0008   AF             RET       
   \   0009                  REQUIRE ?CL78K_V4_6_L00
   2187          #pragma optimize=no_inline

   \                                 In  segment BCODE, align 1, keep-with-next
   2188          static MEM_TYPE void DATTrpSendWriteCommand_Static(void)
   \                     DATTrpSendWriteCommand_Static:
   2189          {
   \   0000                  ; * Stack frame (at entry) *
   \   0000                  ; Param size: 0
   \   0000   100000         MOVW      AX,#0
   \   0003   B3             PUSH      BC
   \   0004                  ; Total Auto size: 0
   2190          #endif
   2191          
   2192              tTrpCommand EncodedWritingCommand;
   2193          
   2194              //-----------------------------------//
   2195              // Set data read to the default value
   2196              //-----------------------------------//
   2197              DatTrpExportData.DataRead = cDATTrpResyncReadFailDefaultValue;
   \   0004   03....         MOVW      DatTrpExportData+18,AX
   \   0007   03....         MOVW      DatTrpExportData+16,AX
   2198          
   2199              //------------------------//
   2200              // Encode command to send
   2201              //------------------------//
   2202              // Prevention of simultaneous access of antena by immo or exm components
   2203              // like:    if (DatTrpLocalData.CipheredCommunication == cTrue)
   2204              EncodedWritingCommand = EncodeCommand(DatTrpLocalData.WritingCommand);  
   \   000A   02....         MOVW      AX,DatTrpLocalData+22
   \   000D   9A....         CALL      EncodeCommand
   \   0010   D4             MOVW      DE,AX
   2205              //------------------------------------//
   2206              // Prepare command to send
   2207              //------------------------------------//
   2208          
   2209              DatTrpLocalData.TransponderMessage.Lng  = cCommandLength;
   \   0011   100A00         MOVW      AX,#10
   \   0014   03....         MOVW      DatTrpLocalData+10,AX
   2210              DatTrpLocalData.u32DataBuffer            = 0;
   \   0017   70             MOV       X,A
   \   0018   03....         MOVW      DatTrpLocalData+2,AX
   \   001B   03....         MOVW      DatTrpLocalData,AX
   2211              //QACJ 0310:amanevd: Test on target prooves that this cast is compiled correct. As well as this is how it comes from reuse.
   2212              DatTrpLocalData.TransponderMessage.pBuffer = (U8*)&DatTrpLocalData.u32DataBuffer;
   \   001E   10....         MOVW      AX,#DatTrpLocalData
   \   0021   03....         MOVW      DatTrpLocalData+8,AX
   2213          
   2214              //------------------------------------------//
   2215              // Indicate that answer is not received yet
   2216              //------------------------------------------//
   2217              mClearFlagImmoAntAnswerReceived();
   2218              mClearFlagAnswerReceivedOK();
   \   0024   8E....         MOV       A,DatTrpLocalData+30
   \   0027   5DFC           AND       A,#252
   \   0029   9E....         MOV       DatTrpLocalData+30,A
   2219          
   2220              //---------------------------//
   2221              // Start communication timer
   2222              //---------------------------//
   2223              DatTrpLocalData.CommandTimeOut = cSendWriteCmdTimeOut;
   \   002C   100600         MOVW      AX,#6
   \   002F   03....         MOVW      DatTrpLocalData+18,AX
   2224              TOSStartTimer(&DatTrpLocalData.TimeOutWaitingForImmoANTReply);
   \   0032   10....         MOVW      AX,#DatTrpLocalData+12
   \   0035   ..             CALLT     [__T_TOSStartTimer]
   2225              TOSStartTimer(&DatTrpLocalData.TimeOutWaitingForWriting);
   \   0036   10....         MOVW      AX,#DatTrpLocalData+14
   \   0039   ..             CALLT     [__T_TOSStartTimer]
   2226          
   2227              //----------------------------------//
   2228              // Start the sending of the message
   2229              //----------------------------------//  
   2230          
   2231              LDBReceiveWithAddr(cLDBChannelTrp, EncodedWritingCommand, &DatTrpLocalData.TransponderMessage);
   \   003A                  REQUIRE ?CL78K_V4_6_L00
   \   003A                  REQUIRE ?Subroutine2
   \   003A                  ; // Fall through to label ?Subroutine2
   2232          }
   2233          
   2234          //*****************************************************************************
   2235          //  DESCRIPTION         : Send the 32 bits data to write in the transponder
   2236          //                        memory.
   2237          //
   2238          //  PARAMETERS          : None
   2239          //  (Type,Name,Min,Max) 
   2240          //
   2241          //  RETURN VALUE        : None
   2242          //
   2243          //  DESIGN INFORMATION  : Refer to Detailed Design Document
   2244          //
   2245          //*****************************************************************************

   \                                 In  segment CODE, align 1, keep-with-next
   2246          void DATTrpSendDataToWrite(void)
   \                     DATTrpSendDataToWrite:
   2247          {
   \   0000                  ; * Stack frame (at entry) *
   \   0000                  ; Param size: 0
   \   0000   B5             PUSH      DE
   \   0001                  ; Total Auto size: 0
   2248          #ifdef X90_PROJECT
   2249              DATTrpSendDataToWrite_Static();
   \   0001   16....         MOVW      HL,#LWRD(DATTrpSendDataToWrite_Static)
   \   0004   A4..           MOV       E,#BYTE3(DATTrpSendDataToWrite_Static)
   \   0006   ..             CALLT     [__T_?FAR_CALL_L07]
   2250          }
   \   0007   B4             POP       DE
   \   0008   AF             RET       
   \   0009                  REQUIRE ?CL78K_V4_6_L00
   2251          #pragma optimize=no_inline

   \                                 In  segment BCODE, align 1, keep-with-next
   2252          static MEM_TYPE void DATTrpSendDataToWrite_Static(void)
   \                     DATTrpSendDataToWrite_Static:
   2253          {
   \   0000                  ; * Stack frame (at entry) *
   \   0000                  ; Param size: 0
   \   0000   B3             PUSH      BC
   \   0001                  ; Total Auto size: 4
   \   0001   B7             PUSH      HL
   \   0002   B7             PUSH      HL
   2254          #endif
   2255              
   2256              U32 ulEncodedDataToWriteL;
   2257          
   2258              // Prevention of simultaneous access of antena by immo or exm components
   2259              // like:    if (DatTrpLocalData.CipheredCommunication == cTrue)
   2260              //-----------------------//
   2261              // Encode data to write
   2262              //-----------------------//
   2263              LIBPcfCipheredData = U32ReverseByteOrder(DatTrpExportData.DataToWrite);
   \   0003   02....         MOVW      AX,DatTrpExportData+10
   \   0006   D2             MOVW      BC,AX
   \   0007   02....         MOVW      AX,DatTrpExportData+8
   \   000A   9A....         CALL      U32ReverseByteOrder
   \   000D   99..           MOVW      S:LIBPcfCipheredData,AX
   \   000F   C2             MOVW      AX,BC
   \   0010   99..           MOVW      S:LIBPcfCipheredData+2,AX
   2264              LDBRefreshWatchDog();
   \   0012   9A....         CALL      LDBRefreshWatchDog
   2265              LIBPcfCipherFunction(cPageLength);
   \   0015   A120           MOV       A,#32
   \   0017   16....         MOVW      HL,#LWRD(LIBPcfCipherFunction)
   \   001A   A4..           MOV       E,#BYTE3(LIBPcfCipherFunction)
   \   001C   ..             CALLT     [__T_?FAR_CALL_L07]
   2266              LDBRefreshWatchDog();
   \   001D   9A....         CALL      LDBRefreshWatchDog
   2267              ulEncodedDataToWriteL =  U32ReverseByteOrder(LIBPcfCipheredData);
   \   0020   89..           MOVW      AX,S:LIBPcfCipheredData+2
   \   0022   D2             MOVW      BC,AX
   \   0023   89..           MOVW      AX,S:LIBPcfCipheredData
   \   0025   9A....         CALL      U32ReverseByteOrder
   \   0028   D6             MOVW      HL,AX
   \   0029   891C           MOVW      AX,SP
   \   002B   E6             XCHW      AX,HL
   \   002C   BE01           MOV       [HL+0x01],A
   \   002E   60             MOV       A,X
   \   002F   97             MOV       [HL],A
   \   0030   C2             MOVW      AX,BC
   \   0031   BE03           MOV       [HL+0x03],A
   \   0033   60             MOV       A,X
   \   0034   BE02           MOV       [HL+0x02],A
   2268              //------------------------------------------//
   2269              // Prepare message to send
   2270              //------------------------------------------//
   2271          
   2272              DatTrpLocalData.Buffer[cPage0] = (U8)(ulEncodedDataToWriteL);
   \   0036   87             MOV       A,[HL]
   \   0037   9E....         MOV       DatTrpLocalData+33,A
   2273              DatTrpLocalData.Buffer[cPage1] = (U8)(ulEncodedDataToWriteL >> cShift8);
   \   003A   AE01           MOV       A,[HL+0x01]
   \   003C   9E....         MOV       DatTrpLocalData+34,A
   2274              DatTrpLocalData.Buffer[cPage2] = (U8)(ulEncodedDataToWriteL >> cShift16);
   \   003F   60             MOV       A,X
   \   0040   9E....         MOV       DatTrpLocalData+35,A
   2275              DatTrpLocalData.Buffer[cPage3] = (U8)(ulEncodedDataToWriteL >> cShift24);
   \   0043   AE03           MOV       A,[HL+0x03]
   \   0045   9E....         MOV       DatTrpLocalData+36,A
   2276          
   2277              DatTrpLocalData.TransponderMessage.Lng      = cPageLength;
   \   0048   102000         MOVW      AX,#32
   \   004B   03....         MOVW      DatTrpLocalData+10,AX
   2278              DatTrpLocalData.TransponderMessage.pBuffer  = DatTrpLocalData.Buffer;
   \   004E   10....         MOVW      AX,#DatTrpLocalData+33
   \   0051   03....         MOVW      DatTrpLocalData+8,AX
   2279          
   2280              //------------------------------------------//
   2281              // Indicate that answer is not received yet
   2282              //------------------------------------------//
   2283              mClearFlagImmoAntAnswerReceived();
   2284              mClearFlagAnswerReceivedOK();
   \   0054   8E....         MOV       A,DatTrpLocalData+30
   \   0057   5DFC           AND       A,#252
   \   0059   9E....         MOV       DatTrpLocalData+30,A
   2285          
   2286              //---------------------------//
   2287              // Start communication timer
   2288              //---------------------------//
   2289              DatTrpLocalData.CommandTimeOut = cSendDataToWriteTimeOut;
   \   005C   100600         MOVW      AX,#6
   \   005F   03....         MOVW      DatTrpLocalData+18,AX
   2290              TOSStartTimer(&DatTrpLocalData.TimeOutWaitingForImmoANTReply);
   \   0062   10....         MOVW      AX,#DatTrpLocalData+12
   \   0065   ..             CALLT     [__T_TOSStartTimer]
   2291              TOSStartTimer(&DatTrpLocalData.TimeOutWaitingForWriting);
   \   0066   10....         MOVW      AX,#DatTrpLocalData+14
   \   0069   ..             CALLT     [__T_TOSStartTimer]
   2292          
   2293              //----------------------------------//
   2294              // Start the sending of the message
   2295              //----------------------------------//  
   2296          
   2297              LDBSendWithAddr(cLDBChannelTrp, DatTrpLocalData.WritingCommand, &DatTrpLocalData.TransponderMessage);
   \   006A   12....         MOVW      BC,#DatTrpLocalData+8
   \   006D   02....         MOVW      AX,DatTrpLocalData+22
   \   0070   16....         MOVW      HL,#LWRD(LDBTrpSendWithAddr)
   \   0073   A4..           MOV       E,#BYTE3(LDBTrpSendWithAddr)
   \   0075   ..             CALLT     [__T_?FAR_CALL_L07]
   2298          }
   \   0076   B0             POP       AX
   \   0077   B0             POP       AX
   \   0078   B2             POP       BC
   \   0079   AF             RET       
   \   007A                  REQUIRE ?CL78K_V4_6_L00
   2299          //*****************************************************************************
   2300          //  DESCRIPTION         : Test if write command answer is OK.
   2301          //
   2302          //  PARAMETERS          : None
   2303          //  (Type,Name,Min,Max) 
   2304          //
   2305          //  RETURN VALUE        : cFalse or cTrue
   2306          //
   2307          //  DESIGN INFORMATION  : Refer to Detailed Design Document
   2308          //
   2309          //*****************************************************************************

   \                                 In  segment CODE, align 1, keep-with-next
   2310          BOOL DATTrpWriteCommandReceivedOK(void)
   \                     DATTrpWriteCommandReceivedOK:
   2311          {
   \   0000                  ; * Stack frame (at entry) *
   \   0000                  ; Param size: 0
   \   0000   B5             PUSH      DE
   \   0001                  ; Total Auto size: 0
   2312          #ifdef X90_PROJECT
   2313              return DATTrpWriteCommandReceivedOK_Static();
   \   0001   16....         MOVW      HL,#LWRD(DATTrpWriteCommandReceivedOK_Static)
   \   0004   A4..           MOV       E,#BYTE3(DATTrpWriteCommandReceivedOK_Static)
   \   0006   ..             CALLT     [__T_?FAR_CALL_L07]
   \   0007   B4             POP       DE
   \   0008   AF             RET       
   \   0009                  REQUIRE ?CL78K_V4_6_L00
   2314          }
   2315          #pragma optimize=no_inline

   \                                 In  segment BCODE, align 1, keep-with-next
   2316          static MEM_TYPE BOOL DATTrpWriteCommandReceivedOK_Static(void)
   \                     DATTrpWriteCommandReceivedOK_Static:
   2317          {
   \   0000                  ; * Stack frame (at entry) *
   \   0000                  ; Param size: 0
   \   0000   B3             PUSH      BC
   \   0001                  ; Total Auto size: 2
   \   0001   B7             PUSH      HL
   2318          #endif
   2319          
   2320              BOOL bResultL = cFalse;
   \   0002   891C           MOVW      AX,SP
   \   0004   D6             MOVW      HL,AX
   \   0005   A100           MOV       A,#0
   \   0007   97             MOV       [HL],A
   2321              BOOL bTimerElapsedL;
   2322          
   2323          
   2324              bTimerElapsedL = TOSIsTimerElapsed(&DatTrpLocalData.TimeOutWaitingForWriting, 
   2325              cWritingInTrpTimeOut);
   \   0008   10....         MOVW      AX,#DatTrpLocalData+14
   \   000B   120400         MOVW      BC,#4
   \   000E   ..             CALLT     [__T_TOSIsTimerElapsed]
   2326          
   2327              if (    (cTrue == (BOOL)mGetFlagAnswerReceivedOK())
   2328                   && (cFalse != bTimerElapsedL)
   2329                 )
   \   000F   16....         MOVW      HL,#DatTrpLocalData+30
   \   0012   319603         BT        [HL].1, $+6
   \   0015   9B....         BR        N:??DATTrpPage3InvertedDataReceivedOK_Static_88
   \   0018   4D00           CMP       A,#0
   \   001A   BD03           BNZ       $+5
   \   001C   9B....         BR        N:??DATTrpPage3InvertedDataReceivedOK_Static_88
   2330              {
   2331                  // Prevention of simultaneous access of antena by immo or exm components
   2332                  // like:    if (DatTrpLocalData.CipheredCommunication == cTrue)
   2333                  //-----------------------------------//
   2334                  // Decode and check command received
   2335                  //-----------------------------------//
   2336                  LIBPcfCipheredData =((DatTrpLocalData.u32DataBuffer >> cShift8 ) & cMaskByte1)
   2337                      | ((DatTrpLocalData.u32DataBuffer << (cShift8 + cShift4 + cShift2)) 
   2338                      & cMaskByte2);
   \   001F   100000         MOVW      AX,#0
   \   0022   B1             PUSH      AX
   \   0023   A1FF           MOV       A,#255
   \   0025   B1             PUSH      AX
   \   0026   A40E           MOV       E,#14
   \   0028   02....         MOVW      AX,DatTrpLocalData+2
   \   002B   D2             MOVW      BC,AX
   \   002C   02....         MOVW      AX,DatTrpLocalData
   \   002F   9A....         CALL      ?L_LSH_L03
   \   0032   9A....         CALL      ?L_AND_L03
   \   0035   B3             PUSH      BC
   \   0036   B1             PUSH      AX
   \   0037   02....         MOVW      AX,DatTrpLocalData
   \   003A   76             MOV       L,A
   \   003B   A700           MOV       H,#0
   \   003D   C6             MOVW      AX,HL
   \   003E   9A....         CALL      ?L_IOR_L03
   \   0041   99..           MOVW      S:LIBPcfCipheredData,AX
   \   0043   C2             MOVW      AX,BC
   \   0044   99..           MOVW      S:LIBPcfCipheredData+2,AX
   2339                  LDBRefreshWatchDog();
   \   0046   9A....         CALL      LDBRefreshWatchDog
   2340                  LIBPcfCipherFunction(cCommandLength);
   \   0049   A10A           MOV       A,#10
   \   004B   16....         MOVW      HL,#LWRD(LIBPcfCipherFunction)
   \   004E   A4..           MOV       E,#BYTE3(LIBPcfCipherFunction)
   \   0050   ..             CALLT     [__T_?FAR_CALL_L07]
   2341                  LDBRefreshWatchDog();
   \   0051   9A....         CALL      LDBRefreshWatchDog
   2342                  LIBPcfCipheredData =((LIBPcfCipheredData >> cShift8) & cMaskByte1)
   2343                      | ((LIBPcfCipheredData << cShift8) & cMaskByte2);
   2344                  LIBPcfCipheredData >>= (cShift4 + cShift2);
   \   0054   89..           MOVW      AX,S:LIBPcfCipheredData
   \   0056   60             MOV       A,X
   \   0057   A000           MOV       X,#0
   \   0059   D6             MOVW      HL,AX
   \   005A   89..           MOVW      AX,S:LIBPcfCipheredData
   \   005C   74             MOV       E,A
   \   005D   C6             MOVW      AX,HL
   \   005E   30             XCH       A,X
   \   005F   616C           OR        A,E
   \   0061   30             XCH       A,X
   \   0062   21             CLR1      CY
   \   0063   25             RORC      A,0x1
   \   0064   30             XCH       A,X
   \   0065   25             RORC      A,0x1
   \   0066   30             XCH       A,X
   \   0067   21             CLR1      CY
   \   0068   25             RORC      A,0x1
   \   0069   30             XCH       A,X
   \   006A   25             RORC      A,0x1
   \   006B   30             XCH       A,X
   \   006C   21             CLR1      CY
   \   006D   25             RORC      A,0x1
   \   006E   30             XCH       A,X
   \   006F   25             RORC      A,0x1
   \   0070   30             XCH       A,X
   \   0071   21             CLR1      CY
   \   0072   25             RORC      A,0x1
   \   0073   30             XCH       A,X
   \   0074   25             RORC      A,0x1
   \   0075   30             XCH       A,X
   \   0076   21             CLR1      CY
   \   0077   25             RORC      A,0x1
   \   0078   30             XCH       A,X
   \   0079   25             RORC      A,0x1
   \   007A   30             XCH       A,X
   \   007B   21             CLR1      CY
   \   007C   25             RORC      A,0x1
   \   007D   30             XCH       A,X
   \   007E   25             RORC      A,0x1
   \   007F   30             XCH       A,X
   \   0080   D4             MOVW      DE,AX
   \   0081   C4             MOVW      AX,DE
   \   0082   A700           MOV       H,#0
   \   0084   99..           MOVW      S:LIBPcfCipheredData,AX
   \   0086   C6             MOVW      AX,HL
   \   0087   99..           MOVW      S:LIBPcfCipheredData+2,AX
   2345          
   2346                  bResultL = (BOOL)(LIBPcfCipheredData == (U32)DatTrpLocalData.WritingCommand);
   \   0089   02....         MOVW      AX,DatTrpLocalData+22
   \   008C   D4             MOVW      DE,AX
   \   008D   B7             PUSH      HL
   \   008E   B5             PUSH      DE
   \   008F   89..           MOVW      AX,S:LIBPcfCipheredData
   \   0091   D6             MOVW      HL,AX
   \   0092   891C           MOVW      AX,SP
   \   0094   E6             XCHW      AX,HL
   \   0095   B5             PUSH      DE
   \   0096   D4             MOVW      DE,AX
   \   0097   64             MOV       A,E
   \   0098   1F             SUB       A,[HL]
   \   0099   70             MOV       X,A
   \   009A   65             MOV       A,D
   \   009B   3901           SUBC      A,[HL+0x01]
   \   009D   6160           OR        X,A
   \   009F   62             MOV       A,C
   \   00A0   3902           SUBC      A,[HL+0x02]
   \   00A2   6160           OR        X,A
   \   00A4   63             MOV       A,B
   \   00A5   3903           SUBC      A,[HL+0x03]
   \   00A7   6160           OR        X,A
   \   00A9   B4             POP       DE
   \   00AA   B6             POP       HL
   \   00AB   B6             POP       HL
   \   00AC   BD06           BNZ       ??DATTrpPage3InvertedDataReceivedOK_Static_88
   \   00AE   891C           MOVW      AX,SP
   \   00B0   D6             MOVW      HL,AX
   \   00B1   A101           MOV       A,#1
   \   00B3   97             MOV       [HL],A
   2347              }
   2348          
   2349              return (bResultL);
   \                     ??DATTrpPage3InvertedDataReceivedOK_Static_88:
   \   00B4                  REQUIRE ?CL78K_V4_6_L00
   \   00B4                  REQUIRE ?Subroutine3
   \   00B4                  ; // Fall through to label ?Subroutine3
   2350          }
   2351          
   2352          //*****************************************************************************
   2353          //  DESCRIPTION         : Maintain active state
   2354          //
   2355          //  PARAMETERS          : None
   2356          //  (Type,Name,Min,Max) 
   2357          //
   2358          //  RETURN VALUE        : 
   2359          //
   2360          //  DESIGN INFORMATION  : Refer to Detailed Design Document
   2361          //
   2362          //*****************************************************************************

   \                                 In  segment CODE, align 1, keep-with-next
   2363          void DATTrpMaintainActiveState (void)
   \                     DATTrpMaintainActiveState:
   2364          {
   \   0000                  ; * Stack frame (at entry) *
   \   0000                  ; Param size: 0
   \   0000                  ; Total Auto size: 0
   2365              if (cDATTrpServiceInProgress == DatTrpExportData.AuthenticationState)
   \   0000   8E....         MOV       A,DatTrpExportData+44
   \   0003   51             DEC       A
   \   0004   BD04           BNZ       ??DATTrpPage3InvertedDataReceivedOK_Static_13
   2366              {
   2367                  TOSWriteSignal(cTOSSignalSomebodyMaintainActiveState);
   \   0006   102900         MOVW      AX,#41
   \   0009   ..             CALLT     [__T_TOSWriteSignal]
   2368              }
   2369              else
   2370              {
   2371                  //Nothing
   2372              }
   2373          }
   \                     ??DATTrpPage3InvertedDataReceivedOK_Static_13:
   \   000A   AF             RET       
   \   000B                  REQUIRE ?CL78K_V4_6_L00
   2374          
   2375          //*****************************************************************************
   2376          //  DESCRIPTION         : 
   2377          //
   2378          //  PARAMETERS          : None
   2379          //  (Type,Name,Min,Max) 
   2380          //
   2381          //  RETURN VALUE        : None
   2382          //
   2383          //  DESIGN INFORMATION  : Refer to Detailed Design Document
   2384          //
   2385          //*****************************************************************************

   \                                 In  segment CODE, align 1, keep-with-next
   2386          BOOL DATTrpAuthentInNormalMode(void)
   \                     DATTrpAuthentInNormalMode:
   2387          {
   \   0000                  ; * Stack frame (at entry) *
   \   0000                  ; Param size: 0
   \   0000                  ; Total Auto size: 0
   2388              return (cFalse == (BOOL)DatTrpExportData.AuthentInLearningMode);
   \   0000   16....         MOVW      HL,#DatTrpExportData+50
   \   0003   87             MOV       A,[HL]
   \   0004   5D01           AND       A,#1
   \   0006   7D01           XOR       A,#1
   \   0008   AF             RET       
   \   0009                  REQUIRE ?CL78K_V4_6_L00
   2389          }
   2390          //*****************************************************************************
   2391          //  DESCRIPTION         : 
   2392          //
   2393          //  PARAMETERS          : None
   2394          //  (Type,Name,Min,Max) 
   2395          //
   2396          //  RETURN VALUE        : None
   2397          //
   2398          //  DESIGN INFORMATION  : Refer to Detailed Design Document
   2399          //
   2400          //*****************************************************************************

   \                                 In  segment CODE, align 1, keep-with-next
   2401          BOOL DATTrpPage3InvertedDataReceivedOK(void)
   \                     DATTrpPage3InvertedDataReceivedOK:
   2402          {
   \   0000                  ; * Stack frame (at entry) *
   \   0000                  ; Param size: 0
   \   0000   B5             PUSH      DE
   \   0001                  ; Total Auto size: 0
   2403          #ifdef X90_PROJECT
   2404              return DATTrpPage3InvertedDataReceivedOK_Static();
   \   0001   16....         MOVW      HL,#LWRD(DATTrpPage3InvertedDataReceivedOK_Static)
   \   0004   A4..           MOV       E,#BYTE3(DATTrpPage3InvertedDataReceivedOK_Static)
   \   0006   ..             CALLT     [__T_?FAR_CALL_L07]
   \   0007   B4             POP       DE
   \   0008   AF             RET       
   \   0009                  REQUIRE ?CL78K_V4_6_L00
   2405          }
   2406          #pragma optimize=no_inline

   \                                 In  segment BCODE, align 1, keep-with-next
   2407          static MEM_TYPE BOOL DATTrpPage3InvertedDataReceivedOK_Static(void)
   \                     DATTrpPage3InvertedDataReceivedOK_Static:
   2408          {
   \   0000                  ; * Stack frame (at entry) *
   \   0000                  ; Param size: 0
   \   0000   B3             PUSH      BC
   \   0001                  ; Total Auto size: 2
   \   0001   B7             PUSH      HL
   2409          #endif
   2410          
   2411              BOOL bResultL = cFalse;
   \   0002   891C           MOVW      AX,SP
   \   0004   D6             MOVW      HL,AX
   \   0005   A100           MOV       A,#0
   \   0007   97             MOV       [HL],A
   2412          
   2413              if (mGetFlagAnswerReceivedOK())
   \   0008   16....         MOVW      HL,#DatTrpLocalData+30
   \   000B   319603         BT        [HL].1, $+6
   \   000E   9B....         BR        N:??DATTrpPage3InvertedDataReceivedOK_Static_89
   2414              {
   2415                  //----------------------------//
   2416                  // Decode data read
   2417                  //----------------------------//
   2418                  LIBPcfCipheredData = U32ReverseByteOrder(DatTrpLocalData.u32DataBuffer);
   \   0011   02....         MOVW      AX,DatTrpLocalData+2
   \   0014   D2             MOVW      BC,AX
   \   0015   02....         MOVW      AX,DatTrpLocalData
   \   0018   9A....         CALL      U32ReverseByteOrder
   \   001B   99..           MOVW      S:LIBPcfCipheredData,AX
   \   001D   C2             MOVW      AX,BC
   \   001E   99..           MOVW      S:LIBPcfCipheredData+2,AX
   2419                  LDBRefreshWatchDog();
   \   0020   9A....         CALL      LDBRefreshWatchDog
   2420                  LIBPcfCipherFunction(cPageLength);
   \   0023   A120           MOV       A,#32
   \   0025   16....         MOVW      HL,#LWRD(LIBPcfCipherFunction)
   \   0028   A4..           MOV       E,#BYTE3(LIBPcfCipherFunction)
   \   002A   ..             CALLT     [__T_?FAR_CALL_L07]
   2421                  LDBRefreshWatchDog();
   \   002B   9A....         CALL      LDBRefreshWatchDog
   2422                  LIBPcfCipheredData = U32ReverseByteOrder(LIBPcfCipheredData);
   \   002E   89..           MOVW      AX,S:LIBPcfCipheredData+2
   \   0030   D2             MOVW      BC,AX
   \   0031   89..           MOVW      AX,S:LIBPcfCipheredData
   \   0033   9A....         CALL      U32ReverseByteOrder
   \   0036   99..           MOVW      S:LIBPcfCipheredData,AX
   \   0038   C2             MOVW      AX,BC
   \   0039   99..           MOVW      S:LIBPcfCipheredData+2,AX
   2423          
   2424                  if (LIBPcfCipheredData == ~DatTrpExportData.DataRead)
   \   003B   02....         MOVW      AX,DatTrpExportData+18
   \   003E   D2             MOVW      BC,AX
   \   003F   02....         MOVW      AX,DatTrpExportData+16
   \   0042   9A....         CALL      ?L_NOT_L03
   \   0045   B3             PUSH      BC
   \   0046   B1             PUSH      AX
   \   0047   89..           MOVW      AX,S:LIBPcfCipheredData+2
   \   0049   D2             MOVW      BC,AX
   \   004A   89..           MOVW      AX,S:LIBPcfCipheredData
   \   004C   D6             MOVW      HL,AX
   \   004D   891C           MOVW      AX,SP
   \   004F   E6             XCHW      AX,HL
   \   0050   B5             PUSH      DE
   \   0051   D4             MOVW      DE,AX
   \   0052   64             MOV       A,E
   \   0053   1F             SUB       A,[HL]
   \   0054   70             MOV       X,A
   \   0055   65             MOV       A,D
   \   0056   3901           SUBC      A,[HL+0x01]
   \   0058   6160           OR        X,A
   \   005A   62             MOV       A,C
   \   005B   3902           SUBC      A,[HL+0x02]
   \   005D   6160           OR        X,A
   \   005F   63             MOV       A,B
   \   0060   3903           SUBC      A,[HL+0x03]
   \   0062   6160           OR        X,A
   \   0064   B4             POP       DE
   \   0065   B6             POP       HL
   \   0066   B6             POP       HL
   \   0067   BD70           BNZ       ??DATTrpPage3InvertedDataReceivedOK_Static_89
   2425                  {
   2426                      //---------------------------------------//
   2427                      // Update key informations
   2428                      //---------------------------------------//
   2429                      DatTrpExportData.PresentKeyLocked = ((DatTrpExportData.DataRead & cKeyLocked) == cKeyLocked);
   2430                      DatTrpExportData.KeyWithRF = ((DatTrpExportData.IdentifierOfPresentKey & cKeyWithRF) == cKeyWithRF);
   2431                      DatTrpExportData.KeyStandard = ((DatTrpExportData.IdentifierOfPresentKey & cKeyStandardMsk) == cKeyStandard);
   \   0069   02....         MOVW      AX,DatTrpExportData+12
   \   006C   60             MOV       A,X
   \   006D   5DF0           AND       A,#240
   \   006F   4D10           CMP       A,#16
   \   0071   BD04           BNZ       ??DATTrpPage3InvertedDataReceivedOK_Static_90
   \   0073   A101           MOV       A,#1
   \   0075   FA02           BR        ??DATTrpPage3InvertedDataReceivedOK_Static_91
   \                     ??DATTrpPage3InvertedDataReceivedOK_Static_90:
   \   0077   A100           MOV       A,#0
   \                     ??DATTrpPage3InvertedDataReceivedOK_Static_91:
   \   0079   A008           MOV       X,#8
   \   007B   3188           MULU      X
   \   007D   60             MOV       A,X
   \   007E   5D08           AND       A,#8
   \   0080   76             MOV       L,A
   \   0081   02....         MOVW      AX,DatTrpExportData+12
   \   0084   60             MOV       A,X
   \   0085   24             ROR       A,0x1
   \   0086   25             RORC      A,0x1
   \   0087   25             RORC      A,0x1
   \   0088   5D04           AND       A,#4
   \   008A   75             MOV       D,A
   \   008B   A41E           MOV       E,#30
   \   008D   02....         MOVW      AX,DatTrpExportData+18
   \   0090   D2             MOVW      BC,AX
   \   0091   02....         MOVW      AX,DatTrpExportData+16
   \   0094   9A....         CALL      ?UL_RSH_L03
   \   0097   60             MOV       A,X
   \   0098   21             CLR1      CY
   \   0099   27             ROLC      A,0x1
   \   009A   70             MOV       X,A
   \   009B   8E....         MOV       A,DatTrpExportData+51
   \   009E   5DFD           AND       A,#253
   \   00A0   6168           OR        A,X
   \   00A2   5DF3           AND       A,#243
   \   00A4   616D           OR        A,D
   \   00A6   616E           OR        A,L
   \   00A8   9E....         MOV       DatTrpExportData+51,A
   2432                      DatTrpExportData.FrequencyOfPresentKey = (U8)(DatTrpExportData.DataRead >> cShift16) & cFrequencyMask;
   \   00AB   02....         MOVW      AX,DatTrpExportData+18
   \   00AE   60             MOV       A,X
   \   00AF   5D30           AND       A,#48
   \   00B1   9E....         MOV       DatTrpExportData+39,A
   2433                      DatTrpExportData.KeyWithExtendedMemory = ((DatTrpExportData.DataRead & cKeyWithExtendedMemory) == cKeyWithExtendedMemory);       
   \   00B4   16....         MOVW      HL,#DatTrpExportData+50
   \   00B7   A417           MOV       E,#23
   \   00B9   8E....         MOV       A,DatTrpExportData+19
   \   00BC   D2             MOVW      BC,AX
   \   00BD   02....         MOVW      AX,DatTrpExportData+16
   \   00C0   9A....         CALL      ?UL_RSH_L03
   \   00C3   60             MOV       A,X
   \   00C4   618C           MOV1      CY,A.0
   \   00C6   71C1           MOV1      [HL].4,CY
   2434                      // Update of DiagKeyFrequency signal
   2435                      SignalCurrentKeyFrequency();
   \   00C8   16....         MOVW      HL,#LWRD(SignalCurrentKeyFrequency)
   \   00CB   A4..           MOV       E,#BYTE3(SignalCurrentKeyFrequency)
   \   00CD   ..             CALLT     [__T_?FAR_FAST_CALL_L07]
   2436          
   2437                      bResultL = cTrue;
   \   00CE   891C           MOVW      AX,SP
   \   00D0   D6             MOVW      HL,AX
   \   00D1   A101           MOV       A,#1
   \   00D3   97             MOV       [HL],A
   2438          
   2439                      DatTrpExportData.ResponseToChallengeIsValid = bResultL;
   \   00D4   16....         MOVW      HL,#DatTrpExportData+51
   \   00D7   7182           SET1      [HL].0
   2440                  }
   2441          
   2442              }
   2443          
   2444              return (bResultL);
   \                     ??DATTrpPage3InvertedDataReceivedOK_Static_89:
   \   00D9   9B....         BR        N:?Subroutine3
   \   00DC                  REQUIRE ?CL78K_V4_6_L00
   2445          }

   \                                 In  segment CLTVEC, align 2
   \                     __T_?FAR_CALL_L07:
   \   0000   ....           DW       ?FAR_CALL_L07

   \                                 In  segment CLTVEC, align 2
   \                     __T_TOSStartTimer:
   \   0000   ....           DW       TOSStartTimer

   \                                 In  segment CLTVEC, align 2
   \                     __T_TOSSeqActivateGraph:
   \   0000   ....           DW       TOSSeqActivateGraph

   \                                 In  segment CLTVEC, align 2
   \                     __T_?FAR_FAST_CALL_L07:
   \   0000   ....           DW       ?FAR_FAST_CALL_L07

   \                                 In  segment CLTVEC, align 2
   \                     __T_TOSIsTimerElapsed:
   \   0000   ....           DW       TOSIsTimerElapsed

   \                                 In  segment CLTVEC, align 2
   \                     __T_?I_LSH_L02:
   \   0000   ....           DW       ?I_LSH_L02

   \                                 In  segment CLTVEC, align 2
   \                     __T_TOSWriteSignal:
   \   0000   ....           DW       TOSWriteSignal

   Segment part sizes:

     Function/Label                 Bytes
     --------------                 -----
     DATTrpAuthentication            102
     DATTrpWriteAccess                72
     DATTrpResynchronization          18
     DATTrpTfcDiag                    18
     DatTrpLocalData                  40
     DatTrpExportData                 52
     u8DATTrpOutState                  1
     DATTrpTransportISK                6
     ComputeCommandWithPageNumber     52
     EncodeCommand                   106
     U32ReverseByteOrder              81
     SignalCurrentKeyFrequency        31
     DATTrpInit                        9
     DATTrpInit_Static                36
     ?Subroutine4                      7
     DATTrpStartAuthenticationService
                                       9
     DATTrpStartAuthenticationService_Static
                                      64
     DATTrpControl                     9
     DATTrpControl_Static            525
     DATTrpCallBackCtrl              106
     DATTrpCallBackTxWithAddr         28
     DATTrpCallBackEndCtrl            79
     DATTrpCallBackRxSpontWithoutAddr
                                      32
     DATTrpCallBackRxWithAddr         21
     DATTrpAnswerChallengeReceivedOK
                                       9
     DATTrpAnswerChallengeReceivedOK_Static
                                     335
     ?Subroutine3                      7
     DATTrpAuthenticationNotSuccess    9
     DATTrpAuthenticationNotSuccess_Static
                                      36
     DATTrpAuthenticationSuccess       9
     DATTrpAuthenticationSuccess_Static
                                      49
     DATTrpTfcDiagNotSuccess           2
     ?Subroutine0                      5
     DATTrpTfcDiagSuccess              5
     DATTrpCalculateChallenge          9
     DATTrpCalculateChallenge_Static
                                     168
     DATTrpIdentifierReceivedOK        9
     DATTrpIdentifierReceivedOK_Static
                                     163
     DATTrpTfcResponceOK               9
     DATTrpSendReadCommand             9
     DATTrpSendReadCommand_Static     48
     ?Subroutine2                      1
     ??Subroutine6_0                  11
     DATTrpSendSleepControl           42
     DATTrpSleepFinished              12
     DATTrpWakeUpFinished             13
     DATTrpSendStartAuth               9
     DATTrpSendStartAuth_Static       51
     DATTrpWriteNotSuccess             2
     ?Subroutine1                      5
     DATTrpWriteSuccess               13
     DATTrpAnswerReceivedNOKOrTimeOut
                                      31
     DATTrpOnWakeUpControlNotSuccessful
                                       7
     DATTrpSendWakeUpControl           9
     DATTrpSendWakeUpControl_Static   29
     DATTrpAuhenticationServiceFinishedNOK
                                      13
     DATTrpAuhenticationServiceFinishedOK
                                      13
     DATTrpNewAuthenticationAuthorized
                                       9
     DATTrpNewAuthenticationAuthorized_Static
                                      87
     DATTrpIncreaseRetryCounters      15
     DATTrpResynchronizationNotSuccess
                                       9
     DATTrpResynchronizationNotSuccess_Static
                                     297
     ?Subroutine5                      6
     DATTrpResynchronizationSuccess    9
     DATTrpResynchronizationSuccess_Static
                                     587
     DATTrpStartWriteServiceForResync
                                      10
     DATTrpWriteServiceFinishedNOK    13
     DATTrpWriteServiceFinishedOK     13
     DATTrpNewTryAuthorized            9
     DATTrpNewTryAuthorized_Static    28
     DATTrpInLearningModeAndLessThanMaxTrials
                                       9
     DATTrpInLearningModeAndLessThanMaxTrials_Static
                                      26
     DATTrpSendInvertedReadCommand     9
     DATTrpSendInvertedReadCommand_Static
                                      48
     DATTrpPageWrittenOK              26
     DATTrpReadAndCompareOK            9
     DATTrpReadAndCompareOK_Static   165
     DATTrpWriteNOKAction              6
     DATTrpReadNOKAction              33
     DATTrpSendWriteCommand            9
     DATTrpSendWriteCommand_Static    58
     DATTrpSendDataToWrite             9
     DATTrpSendDataToWrite_Static    122
     DATTrpWriteCommandReceivedOK      9
     DATTrpWriteCommandReceivedOK_Static
                                     180
     DATTrpMaintainActiveState        11
     DATTrpAuthentInNormalMode         9
     DATTrpPage3InvertedDataReceivedOK
                                       9
     DATTrpPage3InvertedDataReceivedOK_Static
                                     220
     __T_?FAR_CALL_L07                 2
     __T_TOSStartTimer                 2
     __T_TOSSeqActivateGraph           2
     __T_?FAR_FAST_CALL_L07            2
     __T_TOSIsTimerElapsed             2
     __T_?I_LSH_L02                    2
     __T_TOSWriteSignal                2

 
 3 651 bytes in segment BCODE
    14 bytes in segment CLTVEC
   745 bytes in segment CODE
   216 bytes in segment CONST
    93 bytes in segment NEAR_Z
 
 4 396 bytes of CODE  memory (+ 14 bytes shared)
   216 bytes of CONST memory
    93 bytes of DATA  memory

Errors: none
Warnings: none
