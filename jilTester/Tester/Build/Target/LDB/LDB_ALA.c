//******************************************************************************
// Company:      Johnson Controls Inc.
// -----------------------------------------------------------------------------
// Copyright:    This software is JCI property.
//               Duplication or disclosure without JCI written authorization
//               is prohibited.
// -----------------------------------------------------------------------------
// Project:      X90_BCM
// Language:     ANSI-C
// -----------------------------------------------------------------------------
// Component:    LDB_ALA
// -----------------------------------------------------------------------------
// $Date:   Jul 13 2009 16:28:36  $
// $Archive:   J:/_PVCSRoot/Renault/X90_BCM/SOFTWARE/PVCS/archives/DEVELOPMENT/X90_BCM/K0/L7/CMP/LDB/LDB_ALA/LDB_ALA.c-arc  $
// $Revision:   1.2  $
// -----------------------------------------------------------------------------
// $Log::   J:/_PVCSRoot/Renault/X90_BCM/SOFTWARE/PVCS/archives/DEVELOPMENT/X90_BCM/K0/L7/CMP/LDB/LDB_ALA/LDB_ALA.c-arc   $
// 
//    Rev 1.2   Jul 13 2009 16:28:36   adzhelp
// Cm005188: All timeouts generated by Timer WTI
// 
//    Rev 1.1   Jul 13 2009 16:25:32   adzhelp
// Cm005188: Code review corrections from SW1
// 
//    Rev 1.0   Apr 03 2009 08:48:56   adzhelp
// Initial revision.
// 
//******************************************************************************

//------------------------------------------------------------------------------
// Body Identification
//------------------------------------------------------------------------------
#define LDB_ALA  "LDB_ALA"

//------------------------------------------------------------------------------
// Included files to resolve specific definitions in this file
//
// #include <system_file_name.h>
// #include "project_file_name.h"
//------------------------------------------------------------------------------
#include "lib.h"
#include "ldb.h"
#include "ldb_ioc.h"
#include "ldb_int.h"
#include "ldb_har.h"
#include "ldb_ala.h"
#include "ldb_tim.h"

//------------------------------------------------------------------------------
// Local constants
//
// #define cConstantName   ((tType) ConstantValue)
//------------------------------------------------------------------------------

#define INVERSE_LOGIC // logic inversion on Bus

#define cNbDataPerMessage    4
#define cNbMessage           4
 
 

//Transmission status registers
#define cTransmitShiftRegisterFlag       0x01U
#define cTransmitBufferRegisterFlag      0x02U

// Timings of alarm timer
#define cWakeUpLowTimeout              (2)      //  2ms
#define cWakeUpHighTimeout             (18)     // 18ms
#define cLDBAlaBreakTimeOutInMs        (5)      // 5ms

// Value for  UART6 Baud  rate generator
#define cBaudRateGeneratorValue        (151)
// Interval timer divider
#define cAlarmTimerDivider              7

 
//------------------------------------------------------------------------------
// Local macros
//
// #define mMacroName   (MacroDefinition)
//------------------------------------------------------------------------------

#define mStartAlarmTimer() \
    mLDBIocStartTimer(cLDBHarAlarmTimer)

#define mLDBSelectAlarmTimerPeriod()\
    mLDBIocSelectClock(cLDBHarAlarmTimer,cAlarmTimerDivider)  
    


#define mStopAlarmTimer() \
    mLDBIocStopTimer(cLDBHarAlarmTimer)
  
  
// fXCLK6 frequency = fprs    / ((2 ^4)
#define mLDBUART6SelectClock_Timer() \
    mLDBRegWrite1BitInRegister(ASIM6, 6, 0); \
    mLDBRegWrite1BitInRegister(ASIM6, 5, 0); \
    /* //QACJ 3412: aangovt: No unrecognized code  */ \
    mLDBRegWrite8BitRegister(CKSR6,4)

 


// Baud rate generator 

#define mLDBUART6SetBRG(Value) \
    mLDBRegWrite1BitInRegister(ASIM6, 7, 0); \
    /* //QACJ 3412: aangovt: No unrecognized code  */ \
    mLDBRegWrite8BitRegister(BRGC6,Value)



//Symbol   <7>    <6>       <5>     4        3       2       1      0
//ASIM6    POWER6  TXE6     RXE6     PS61   PS60     CL6     SL6    ISRM6
 
//Transmission data  specifies
// Make sure that RXE6 = 0 when rewriting the ISRM6 bit.
#define mLDBUART6TransmitDataMode() \
    mLDBRegWrite1BitInRegister(ASIM6, 5, 0); \
    mLDBRegWrite1BitInRegister(ASIM6, 4, 0); \
    mLDBRegWrite1BitInRegister(ASIM6, 3, 0); \
    mLDBRegWrite1BitInRegister(ASIM6, 2, 1); \
    mLDBRegWrite1BitInRegister(ASIM6, 1, 0); \
    /* //QACJ 3412: aangovt: No unrecognized code  */ \
    mLDBRegWrite1BitInRegister(ASIM6, 0, 1)


//Enable UART6 transmission 
#define mLDBUART6TransmissionEnable() \
    mLDBRegWrite1BitInRegister(ASIM6, 7, 1); \
    mLDBRegWrite1BitInRegister(ASIM6, 6, 1); \
    mLDBRegWrite1BitInRegister(ASIM6, 5, 0); \
    /* port must be '1' when UART enabled: */ \
    mLDBHarWrite(cLDBHarAlarmOut,1); \
    /* Enables inverting TXD6 output - TXDLV6  - Bit 0 0f ASICL6 */ \
    /* //QACJ 3412: aangovt: No unrecognized code  */               \
    mLDBRegWrite1BitInRegister(ASICL6, 0, 1)



//Disable UART6 transmission
#define mLDBUART6TransmissionDisable() \
    mLDBRegWrite1BitInRegister(ASIM6, 7, 0); \
    mLDBRegWrite1BitInRegister(ASIM6, 6, 0); \
    /* Disable inverting TXD6 output - TXDLV6  - Bit 0 0f ASICL6 */ \
    /* //QACJ 3412: aangovt: No unrecognized code  */               \
    mLDBRegWrite1BitInRegister(ASICL6, 0, 0)



// Communication operations 
//  First-bit specification -  DIR6 - Bit 1 0f ASICL6 - 1 - LSB, 0 - MSB
#define mLDBUART6CommunicationOperations() \
    mLDBRegWrite1BitInRegister(ASICL6, 1, 1)




// Transmission  status 
 // TXBF6: Bit 1 of ASIF6
#define mLDBUART6TransmissionBufferStatus() \
    mLDBRegRead8BitRegister(ASIF6)

#define mGetTransmitBufferDataFlag() \
    ((mLDBUART6TransmissionBufferStatus() & cTransmitBufferRegisterFlag) != 0)

#define mGetTransmitShiftRegisterFlag() \
    ((mLDBUART6TransmissionBufferStatus() & cTransmitShiftRegisterFlag) != 0)

//  Set data to Transmit buffer 
#define mLDBUART6SetTransmitBuffer(Value) \
    mLDBRegWrite8BitRegister(TXB6,Value)

 
//------------------------------------------------------------------------------
// Local types
//
// typedef Expression    tTypeName;
//------------------------------------------------------------------------------
enum eTransmissionStage
{
    cStartBreakTime,
    cWakeUpLowPattern,
    cWakeUpHighPattern,
    cBreakTime,
    cDataTransmission
};

//------------------------------------------------------------------------------
// Data prefix
//
// unsigned int {u8,u16,u32} / signed int {s8,s16,s32} 
// register size unsigned int {r} / float {f32,f64}  / s for struct 
//
// -----------------------------------------------------------------------------

// -----------------------------------------------------------------------------
// Local data
//
// static  tType   u8VariableName;  
// static  tType*  pu8VariableName; 
//------------------------------------------------------------------------------
//QACJ 3207: adzhelp: Array used by macro mLDBUART6SetTransmitBuffer
static U8 Message[cNbDataPerMessage];
static U8 u8EmissionStage;
static U8 u8DataPosition;
static U8 u8MessageNumber;
static U8 u8AlarmTimerCounter;
#ifdef DEBUG
static BOOL bTransmissionIsActive;
#endif

//------------------------------------------------------------------------------
// Constant local data
//
// static const tType  VariableName;
//------------------------------------------------------------------------------

//------------------------------------------------------------------------------
// Exported data
//
// tType   u8LAYCmpVariableName; (LAY: 3 characters to identify the layer)
// tType*  pu8LAYCmpVariableName;(Cmp: 3 characters to identify the component)
//------------------------------------------------------------------------------

//------------------------------------------------------------------------------
// Constant exported data
//
//             (LAY: 3 characters to identify the layer)
//             (Cmp: 3 characters to identify this component)
// 
// const tType   LAYCmpVariableName;
//------------------------------------------------------------------------------

//------------------------------------------------------------------------------
// Local function prototypes
// 
// static tTypeRetour FunctionName(tTypeArgument1 ArgumentName1, ... );
//------------------------------------------------------------------------------
static void UART6Config(void);
static MEM_TYPE void StartOfCommunication(void);
static void DataTransmission(void);

//==============================================================================
//=========================== LOCAL FUNCTIONS ==================================
//==============================================================================

//==============================================================================
// DESCRIPTION :
//
// PARAMETERS (Type,Name,Min,Max) :   none
//
// RETURN VALUE :   none
//
// DESIGN INFORMATION : (pseudo code, algorithm ... )
//==============================================================================
static void UART6Config(void)
{
    mLDBUART6SelectClock_Timer(); // Set the CKSR6 register 
    // Set the BRGC6 register
    mLDBUART6SetBRG(cBaudRateGeneratorValue);
    //Transmission data  specifies
    mLDBUART6TransmitDataMode();
    // Communication operations 
    mLDBUART6CommunicationOperations();
}

//==============================================================================
// DESCRIPTION :
//
// PARAMETERS (Type,Name,Min,Max) :   none
//
// RETURN VALUE :   none
//
// DESIGN INFORMATION : (pseudo code, algorithm ... )
//==============================================================================
static MEM_TYPE void StartOfCommunication(void)
{
    UART6Config();

    #ifdef INVERSE_LOGIC
    mLDBHarWrite(cLDBHarAlarmOut,0); 
    #else
 	mLDBHarWrite(cLDBHarAlarmOut,1);  
 	#endif  

    // Start 5ms BreakTime at high level  Start of Communication 
    // TimerW - 18ms wait
    // select period of 1,024 ms
    //QACJ 3109: aangovt: It is not deliberate, ldb_ioc macros are used
    mLDBSelectAlarmTimerPeriod();

    mLDBIntClearIsrRequestFlag(cLDBHarInterruptAlarmTimer);
    mLDBIntEnableIsr(cLDBHarInterruptAlarmTimer);
    // start alarm timer
    mStartAlarmTimer();
}

//==============================================================================
// DESCRIPTION :
//
// PARAMETERS (Type,Name,Min,Max) :   none
//
// RETURN VALUE :   none
//
// DESIGN INFORMATION : (pseudo code, algorithm ... )
//==============================================================================
static void DataTransmission(void)
{
    mLIBassert(u8DataPosition < cNbDataPerMessage);
    mLIBassert(mGetTransmitBufferDataFlag() == 0);

    mLDBUART6SetTransmitBuffer(Message[u8DataPosition]);
    u8DataPosition++;
}

//==============================================================================
//=========================== EXPORTED FUNCTIONS ===============================
//==============================================================================

//==============================================================================
// DESCRIPTION :
//
// PARAMETERS (Type,Name,Min,Max) :   none
//
// RETURN VALUE :   none
//
// DESIGN INFORMATION : (pseudo code, algorithm ... )
//==============================================================================
void LDBAlaInit(void) 
{
#ifdef DEBUG
    bTransmissionIsActive = cFalse;
#endif
    u8AlarmTimerCounter = 0;
    // port is configured by LDB_DOU
}


//==============================================================================
// DESCRIPTION :
//
// PARAMETERS (Type,Name,Min,Max) :   none
//
// RETURN VALUE :   none
//
// DESIGN INFORMATION : (pseudo code, algorithm ... )
//==============================================================================
MEM_TYPE void LDBAlaSendWithoutAddr(const tMsg * const pMsg )
{
    if (pMsg != NULL)
    {
        mLIBmemcpy(Message,pMsg->pBuffer,cNbDataPerMessage);
    #ifdef DEBUG
        mLIBassert(bTransmissionIsActive == cFalse);
        bTransmissionIsActive = cTrue;
    #endif
        u8EmissionStage = cStartBreakTime;
        u8AlarmTimerCounter = 0;
        u8DataPosition = 0;
        u8MessageNumber = 0;
        StartOfCommunication();
 
        // Enable IT 
        mLDBIntClearIsrRequestFlag(cLDBHarInterruptAlarmUartTx);
        mLDBIntEnableIsr(cLDBHarInterruptAlarmUartTx);
    }
    else
    {
        mLIBassert(cFalse);
    }
}


//==============================================================================
// DESCRIPTION :
//
// PARAMETERS (Type,Name,Min,Max) :   none
//
// RETURN VALUE :   none
//
// DESIGN INFORMATION : (pseudo code, algorithm ... )
//==============================================================================
mLDBIntDeclareIsr(cLDBHarInterruptAlarmUartTx)
{
    mLDBIntEnterIsr(cLDBHarInterruptAlarmUartTx);

    mLIBassert(u8EmissionStage == (U8)cDataTransmission);

    if (u8DataPosition >= cNbDataPerMessage)
    {
        u8DataPosition = 0;
        u8MessageNumber++;

        u8EmissionStage = (U8)cBreakTime;
        u8AlarmTimerCounter = 0;

        if (u8MessageNumber >= cNbMessage)
        {
            // All messages transmitted
            mLDBIntDisableIsr(cLDBHarInterruptAlarmUartTx);
            mLDBUART6TransmissionDisable();
            // UART disabled, need to set high the output manually
            // Write  high level
            #ifdef INVERSE_LOGIC
            mLDBHarWrite(cLDBHarAlarmOut,0); 
            #else
            mLDBHarWrite(cLDBHarAlarmOut,1); 
            #endif
        }

        // TimerW - 5ms wait
        // select period of 1,024 ms
        //QACJ 3109: aangovt: It is not deliberate, ldb_ioc macros are used
        mLDBSelectAlarmTimerPeriod();

        mLDBIntClearIsrRequestFlag(cLDBHarInterruptAlarmTimer);
        mLDBIntEnableIsr(cLDBHarInterruptAlarmTimer);
        mStartAlarmTimer();
    }
    else
    {
        DataTransmission();
    }
    mLDBIntLeaveIsr(cLDBHarInterruptAlarmUartTx);    
}
 
//==============================================================================
// DESCRIPTION :
//
// PARAMETERS (Type,Name,Min,Max) :   none
//
// RETURN VALUE :   none
//
// DESIGN INFORMATION : (pseudo code, algorithm ... )
//==============================================================================
mLDBIntDeclareIsr(cLDBHarInterruptAlarmTimer)
{
    mLDBIntEnterIsr(cLDBHarInterruptAlarmTimer);
    // count generated interrupts  
    u8AlarmTimerCounter++;

    mLIBassert(u8AlarmTimerCounter <= cWakeUpHighTimeout); // maximal allowed timeout

    switch (u8EmissionStage)
    {
    case (U8)cStartBreakTime:
        if ((U8)cLDBAlaBreakTimeOutInMs <= u8AlarmTimerCounter)
        {
            // Send wake-up low pattern
            // Write  low level  for 2 ms     
            #ifdef INVERSE_LOGIC
            mLDBHarWrite(cLDBHarAlarmOut,1); 
            #else
            mLDBHarWrite(cLDBHarAlarmOut,0); 
            #endif

            u8EmissionStage = cWakeUpLowPattern;
            u8AlarmTimerCounter = 0;
        }
        break;
    case (U8)cWakeUpLowPattern:
        if ((U8)cWakeUpLowTimeout <= u8AlarmTimerCounter)
        {
            u8EmissionStage = cWakeUpHighPattern;
            u8AlarmTimerCounter = 0;
            // Force the first edge from low to high
            
            // Send WakeUp HighPattern
            //Enable UART transmission here, because transmit data have to  be set to TXB6 
            //at least one base clock (fXCLK6) after setting TXE6 = 1.
            mLDBUART6TransmissionEnable();
            // Write high level for 18 ms - done by UART
        }
        else
        {
            // wait
        }
        break;
    case (U8)cWakeUpHighPattern:
        if (cWakeUpHighTimeout <= u8AlarmTimerCounter)
        {
            mLDBIntDisableIsr(cLDBHarInterruptAlarmTimer);
            mStopAlarmTimer(); 
            u8AlarmTimerCounter = 0;
            // Force the data transmission
            u8EmissionStage = cDataTransmission;
            DataTransmission(); // first message
        }
        else
        {
            // wait
        }
        break;
    case (U8)cDataTransmission:
        // Check for transmission completion can be implemented here
        break;
    case (U8)cBreakTime:
        if ((U8)cLDBAlaBreakTimeOutInMs <= u8AlarmTimerCounter)
        {
            if (u8MessageNumber >= cNbMessage)
            {
                // all four messages of the frame are transmitted
            #ifdef DEBUG
                bTransmissionIsActive = cFalse;
            #endif
                mLDBIntDisableIsr(cLDBHarInterruptAlarmTimer);
                mStopAlarmTimer(); 

                DATAlaCallBackTxWithoutAddr(cLDBCorrect);
            }
            else
            {
                // Transmit next message
                mLDBIntDisableIsr(cLDBHarInterruptAlarmTimer);
                mStopAlarmTimer(); 
                u8AlarmTimerCounter = 0;
                // Force the data transmission
                u8EmissionStage = cDataTransmission;
                DataTransmission();
            }
        }
        else
        {
            // wait break time
        }
        break;
    default:
        mLIBassert(cFalse);
    }

    mLDBIntLeaveIsr(cLDBHarInterruptAlarmTimer);
}
